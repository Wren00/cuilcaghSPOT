
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model confirmed_sightings
 * 
 */
export type confirmed_sightings = {
  id: number
  organism_id: number
  user_id: number
  picture_url: string
  date: Date
  lat: Prisma.Decimal
  long: Prisma.Decimal
}

/**
 * Model flyway_schema_history
 * 
 */
export type flyway_schema_history = {
  installed_rank: number
  version: string | null
  description: string
  type: string
  script: string
  checksum: number | null
  installed_by: string
  installed_on: Date
  execution_time: number
  success: boolean
}

/**
 * Model interest_groups
 * 
 */
export type interest_groups = {
  id: number
  group_name: string
  description: string | null
}

/**
 * Model organisms
 * 
 */
export type organisms = {
  id: number
  taxon_name: string
  latin_name: string
  taxon_group_id: number
  picture_url: string | null
  description: string | null
}

/**
 * Model reactions
 * 
 */
export type reactions = {
  id: number
  reaction_name: string
}

/**
 * Model taxon_groups
 * 
 */
export type taxon_groups = {
  id: number
  taxon_group_name: string
  description: string | null
}

/**
 * Model unverified_sightings
 * 
 */
export type unverified_sightings = {
  id: number
  organism_id: number
  user_id: number
  picture_url: string
  date: Date
  lat: Prisma.Decimal
  long: Prisma.Decimal
  user_vote_id: number | null
  reaction_id: number | null
}

/**
 * Model user_levels
 * 
 */
export type user_levels = {
  id: number
  description: string
}

/**
 * Model user_profiles
 * 
 */
export type user_profiles = {
  id: number
  profile_message: string | null
  profile_picture: string | null
}

/**
 * Model user_to_reaction
 * 
 */
export type user_to_reaction = {
  id: number
  user_id: number
  reaction_id: number
}

/**
 * Model user_votes
 * 
 */
export type user_votes = {
  id: number
  user_id: number
  user_vote: number
}

/**
 * Model users
 * 
 */
export type users = {
  id: number
  user_name: string
  email_address: string
  user_password: string
  trusted_user: boolean | null
  user_level_id: number
  user_profile_id: number
}

/**
 * Model users_to_groups
 * 
 */
export type users_to_groups = {
  id: number
  group_id: number
  user_id: number
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Confirmed_sightings
 * const confirmed_sightings = await prisma.confirmed_sightings.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Confirmed_sightings
   * const confirmed_sightings = await prisma.confirmed_sightings.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.confirmed_sightings`: Exposes CRUD operations for the **confirmed_sightings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Confirmed_sightings
    * const confirmed_sightings = await prisma.confirmed_sightings.findMany()
    * ```
    */
  get confirmed_sightings(): Prisma.confirmed_sightingsDelegate<GlobalReject>;

  /**
   * `prisma.flyway_schema_history`: Exposes CRUD operations for the **flyway_schema_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Flyway_schema_histories
    * const flyway_schema_histories = await prisma.flyway_schema_history.findMany()
    * ```
    */
  get flyway_schema_history(): Prisma.flyway_schema_historyDelegate<GlobalReject>;

  /**
   * `prisma.interest_groups`: Exposes CRUD operations for the **interest_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interest_groups
    * const interest_groups = await prisma.interest_groups.findMany()
    * ```
    */
  get interest_groups(): Prisma.interest_groupsDelegate<GlobalReject>;

  /**
   * `prisma.organisms`: Exposes CRUD operations for the **organisms** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Organisms
    * const organisms = await prisma.organisms.findMany()
    * ```
    */
  get organisms(): Prisma.organismsDelegate<GlobalReject>;

  /**
   * `prisma.reactions`: Exposes CRUD operations for the **reactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reactions
    * const reactions = await prisma.reactions.findMany()
    * ```
    */
  get reactions(): Prisma.reactionsDelegate<GlobalReject>;

  /**
   * `prisma.taxon_groups`: Exposes CRUD operations for the **taxon_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Taxon_groups
    * const taxon_groups = await prisma.taxon_groups.findMany()
    * ```
    */
  get taxon_groups(): Prisma.taxon_groupsDelegate<GlobalReject>;

  /**
   * `prisma.unverified_sightings`: Exposes CRUD operations for the **unverified_sightings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Unverified_sightings
    * const unverified_sightings = await prisma.unverified_sightings.findMany()
    * ```
    */
  get unverified_sightings(): Prisma.unverified_sightingsDelegate<GlobalReject>;

  /**
   * `prisma.user_levels`: Exposes CRUD operations for the **user_levels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_levels
    * const user_levels = await prisma.user_levels.findMany()
    * ```
    */
  get user_levels(): Prisma.user_levelsDelegate<GlobalReject>;

  /**
   * `prisma.user_profiles`: Exposes CRUD operations for the **user_profiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_profiles
    * const user_profiles = await prisma.user_profiles.findMany()
    * ```
    */
  get user_profiles(): Prisma.user_profilesDelegate<GlobalReject>;

  /**
   * `prisma.user_to_reaction`: Exposes CRUD operations for the **user_to_reaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_to_reactions
    * const user_to_reactions = await prisma.user_to_reaction.findMany()
    * ```
    */
  get user_to_reaction(): Prisma.user_to_reactionDelegate<GlobalReject>;

  /**
   * `prisma.user_votes`: Exposes CRUD operations for the **user_votes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_votes
    * const user_votes = await prisma.user_votes.findMany()
    * ```
    */
  get user_votes(): Prisma.user_votesDelegate<GlobalReject>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<GlobalReject>;

  /**
   * `prisma.users_to_groups`: Exposes CRUD operations for the **users_to_groups** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users_to_groups
    * const users_to_groups = await prisma.users_to_groups.findMany()
    * ```
    */
  get users_to_groups(): Prisma.users_to_groupsDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export import Metrics = runtime.Metrics
  export import Metric = runtime.Metric
  export import MetricHistogram = runtime.MetricHistogram
  export import MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
   * Prisma Client JS version: 4.1.0
   * Query Engine version: 8d8414deb360336e4698a65aa45a1fbaf1ce13d8
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    confirmed_sightings: 'confirmed_sightings',
    flyway_schema_history: 'flyway_schema_history',
    interest_groups: 'interest_groups',
    organisms: 'organisms',
    reactions: 'reactions',
    taxon_groups: 'taxon_groups',
    unverified_sightings: 'unverified_sightings',
    user_levels: 'user_levels',
    user_profiles: 'user_profiles',
    user_to_reaction: 'user_to_reaction',
    user_votes: 'user_votes',
    users: 'users',
    users_to_groups: 'users_to_groups'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type Interest_groupsCountOutputType
   */


  export type Interest_groupsCountOutputType = {
    users_to_groups: number
  }

  export type Interest_groupsCountOutputTypeSelect = {
    users_to_groups?: boolean
  }

  export type Interest_groupsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Interest_groupsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Interest_groupsCountOutputType
    : S extends undefined
    ? never
    : S extends Interest_groupsCountOutputTypeArgs
    ?'include' extends U
    ? Interest_groupsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Interest_groupsCountOutputType ? Interest_groupsCountOutputType[P] : never
  } 
    : Interest_groupsCountOutputType
  : Interest_groupsCountOutputType




  // Custom InputTypes

  /**
   * Interest_groupsCountOutputType without action
   */
  export type Interest_groupsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Interest_groupsCountOutputType
     * 
    **/
    select?: Interest_groupsCountOutputTypeSelect | null
  }



  /**
   * Count Type OrganismsCountOutputType
   */


  export type OrganismsCountOutputType = {
    confirmed_sightings: number
    unverified_sightings: number
  }

  export type OrganismsCountOutputTypeSelect = {
    confirmed_sightings?: boolean
    unverified_sightings?: boolean
  }

  export type OrganismsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | OrganismsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? OrganismsCountOutputType
    : S extends undefined
    ? never
    : S extends OrganismsCountOutputTypeArgs
    ?'include' extends U
    ? OrganismsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof OrganismsCountOutputType ? OrganismsCountOutputType[P] : never
  } 
    : OrganismsCountOutputType
  : OrganismsCountOutputType




  // Custom InputTypes

  /**
   * OrganismsCountOutputType without action
   */
  export type OrganismsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OrganismsCountOutputType
     * 
    **/
    select?: OrganismsCountOutputTypeSelect | null
  }



  /**
   * Count Type ReactionsCountOutputType
   */


  export type ReactionsCountOutputType = {
    unverified_sightings: number
    user_to_reaction: number
  }

  export type ReactionsCountOutputTypeSelect = {
    unverified_sightings?: boolean
    user_to_reaction?: boolean
  }

  export type ReactionsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ReactionsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ReactionsCountOutputType
    : S extends undefined
    ? never
    : S extends ReactionsCountOutputTypeArgs
    ?'include' extends U
    ? ReactionsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ReactionsCountOutputType ? ReactionsCountOutputType[P] : never
  } 
    : ReactionsCountOutputType
  : ReactionsCountOutputType




  // Custom InputTypes

  /**
   * ReactionsCountOutputType without action
   */
  export type ReactionsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ReactionsCountOutputType
     * 
    **/
    select?: ReactionsCountOutputTypeSelect | null
  }



  /**
   * Count Type Taxon_groupsCountOutputType
   */


  export type Taxon_groupsCountOutputType = {
    organisms: number
  }

  export type Taxon_groupsCountOutputTypeSelect = {
    organisms?: boolean
  }

  export type Taxon_groupsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | Taxon_groupsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? Taxon_groupsCountOutputType
    : S extends undefined
    ? never
    : S extends Taxon_groupsCountOutputTypeArgs
    ?'include' extends U
    ? Taxon_groupsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Taxon_groupsCountOutputType ? Taxon_groupsCountOutputType[P] : never
  } 
    : Taxon_groupsCountOutputType
  : Taxon_groupsCountOutputType




  // Custom InputTypes

  /**
   * Taxon_groupsCountOutputType without action
   */
  export type Taxon_groupsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Taxon_groupsCountOutputType
     * 
    **/
    select?: Taxon_groupsCountOutputTypeSelect | null
  }



  /**
   * Count Type User_levelsCountOutputType
   */


  export type User_levelsCountOutputType = {
    users: number
  }

  export type User_levelsCountOutputTypeSelect = {
    users?: boolean
  }

  export type User_levelsCountOutputTypeGetPayload<
    S extends boolean | null | undefined | User_levelsCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? User_levelsCountOutputType
    : S extends undefined
    ? never
    : S extends User_levelsCountOutputTypeArgs
    ?'include' extends U
    ? User_levelsCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof User_levelsCountOutputType ? User_levelsCountOutputType[P] : never
  } 
    : User_levelsCountOutputType
  : User_levelsCountOutputType




  // Custom InputTypes

  /**
   * User_levelsCountOutputType without action
   */
  export type User_levelsCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the User_levelsCountOutputType
     * 
    **/
    select?: User_levelsCountOutputTypeSelect | null
  }



  /**
   * Count Type User_profilesCountOutputType
   */


  export type User_profilesCountOutputType = {
    users: number
  }

  export type User_profilesCountOutputTypeSelect = {
    users?: boolean
  }

  export type User_profilesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | User_profilesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? User_profilesCountOutputType
    : S extends undefined
    ? never
    : S extends User_profilesCountOutputTypeArgs
    ?'include' extends U
    ? User_profilesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof User_profilesCountOutputType ? User_profilesCountOutputType[P] : never
  } 
    : User_profilesCountOutputType
  : User_profilesCountOutputType




  // Custom InputTypes

  /**
   * User_profilesCountOutputType without action
   */
  export type User_profilesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the User_profilesCountOutputType
     * 
    **/
    select?: User_profilesCountOutputTypeSelect | null
  }



  /**
   * Count Type User_votesCountOutputType
   */


  export type User_votesCountOutputType = {
    unverified_sightings: number
  }

  export type User_votesCountOutputTypeSelect = {
    unverified_sightings?: boolean
  }

  export type User_votesCountOutputTypeGetPayload<
    S extends boolean | null | undefined | User_votesCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? User_votesCountOutputType
    : S extends undefined
    ? never
    : S extends User_votesCountOutputTypeArgs
    ?'include' extends U
    ? User_votesCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof User_votesCountOutputType ? User_votesCountOutputType[P] : never
  } 
    : User_votesCountOutputType
  : User_votesCountOutputType




  // Custom InputTypes

  /**
   * User_votesCountOutputType without action
   */
  export type User_votesCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the User_votesCountOutputType
     * 
    **/
    select?: User_votesCountOutputTypeSelect | null
  }



  /**
   * Count Type UsersCountOutputType
   */


  export type UsersCountOutputType = {
    confirmed_sightings: number
    unverified_sightings: number
    user_to_reaction: number
    user_votes: number
    users_to_groups: number
  }

  export type UsersCountOutputTypeSelect = {
    confirmed_sightings?: boolean
    unverified_sightings?: boolean
    user_to_reaction?: boolean
    user_votes?: boolean
    users_to_groups?: boolean
  }

  export type UsersCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UsersCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UsersCountOutputType
    : S extends undefined
    ? never
    : S extends UsersCountOutputTypeArgs
    ?'include' extends U
    ? UsersCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UsersCountOutputType ? UsersCountOutputType[P] : never
  } 
    : UsersCountOutputType
  : UsersCountOutputType




  // Custom InputTypes

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     * 
    **/
    select?: UsersCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model confirmed_sightings
   */


  export type AggregateConfirmed_sightings = {
    _count: Confirmed_sightingsCountAggregateOutputType | null
    _avg: Confirmed_sightingsAvgAggregateOutputType | null
    _sum: Confirmed_sightingsSumAggregateOutputType | null
    _min: Confirmed_sightingsMinAggregateOutputType | null
    _max: Confirmed_sightingsMaxAggregateOutputType | null
  }

  export type Confirmed_sightingsAvgAggregateOutputType = {
    id: number | null
    organism_id: number | null
    user_id: number | null
    lat: Decimal | null
    long: Decimal | null
  }

  export type Confirmed_sightingsSumAggregateOutputType = {
    id: number | null
    organism_id: number | null
    user_id: number | null
    lat: Decimal | null
    long: Decimal | null
  }

  export type Confirmed_sightingsMinAggregateOutputType = {
    id: number | null
    organism_id: number | null
    user_id: number | null
    picture_url: string | null
    date: Date | null
    lat: Decimal | null
    long: Decimal | null
  }

  export type Confirmed_sightingsMaxAggregateOutputType = {
    id: number | null
    organism_id: number | null
    user_id: number | null
    picture_url: string | null
    date: Date | null
    lat: Decimal | null
    long: Decimal | null
  }

  export type Confirmed_sightingsCountAggregateOutputType = {
    id: number
    organism_id: number
    user_id: number
    picture_url: number
    date: number
    lat: number
    long: number
    _all: number
  }


  export type Confirmed_sightingsAvgAggregateInputType = {
    id?: true
    organism_id?: true
    user_id?: true
    lat?: true
    long?: true
  }

  export type Confirmed_sightingsSumAggregateInputType = {
    id?: true
    organism_id?: true
    user_id?: true
    lat?: true
    long?: true
  }

  export type Confirmed_sightingsMinAggregateInputType = {
    id?: true
    organism_id?: true
    user_id?: true
    picture_url?: true
    date?: true
    lat?: true
    long?: true
  }

  export type Confirmed_sightingsMaxAggregateInputType = {
    id?: true
    organism_id?: true
    user_id?: true
    picture_url?: true
    date?: true
    lat?: true
    long?: true
  }

  export type Confirmed_sightingsCountAggregateInputType = {
    id?: true
    organism_id?: true
    user_id?: true
    picture_url?: true
    date?: true
    lat?: true
    long?: true
    _all?: true
  }

  export type Confirmed_sightingsAggregateArgs = {
    /**
     * Filter which confirmed_sightings to aggregate.
     * 
    **/
    where?: confirmed_sightingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confirmed_sightings to fetch.
     * 
    **/
    orderBy?: Enumerable<confirmed_sightingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: confirmed_sightingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confirmed_sightings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confirmed_sightings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned confirmed_sightings
    **/
    _count?: true | Confirmed_sightingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Confirmed_sightingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Confirmed_sightingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Confirmed_sightingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Confirmed_sightingsMaxAggregateInputType
  }

  export type GetConfirmed_sightingsAggregateType<T extends Confirmed_sightingsAggregateArgs> = {
        [P in keyof T & keyof AggregateConfirmed_sightings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfirmed_sightings[P]>
      : GetScalarType<T[P], AggregateConfirmed_sightings[P]>
  }




  export type Confirmed_sightingsGroupByArgs = {
    where?: confirmed_sightingsWhereInput
    orderBy?: Enumerable<confirmed_sightingsOrderByWithAggregationInput>
    by: Array<Confirmed_sightingsScalarFieldEnum>
    having?: confirmed_sightingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Confirmed_sightingsCountAggregateInputType | true
    _avg?: Confirmed_sightingsAvgAggregateInputType
    _sum?: Confirmed_sightingsSumAggregateInputType
    _min?: Confirmed_sightingsMinAggregateInputType
    _max?: Confirmed_sightingsMaxAggregateInputType
  }


  export type Confirmed_sightingsGroupByOutputType = {
    id: number
    organism_id: number
    user_id: number
    picture_url: string
    date: Date
    lat: Decimal
    long: Decimal
    _count: Confirmed_sightingsCountAggregateOutputType | null
    _avg: Confirmed_sightingsAvgAggregateOutputType | null
    _sum: Confirmed_sightingsSumAggregateOutputType | null
    _min: Confirmed_sightingsMinAggregateOutputType | null
    _max: Confirmed_sightingsMaxAggregateOutputType | null
  }

  type GetConfirmed_sightingsGroupByPayload<T extends Confirmed_sightingsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Confirmed_sightingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Confirmed_sightingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Confirmed_sightingsGroupByOutputType[P]>
            : GetScalarType<T[P], Confirmed_sightingsGroupByOutputType[P]>
        }
      >
    >


  export type confirmed_sightingsSelect = {
    id?: boolean
    organism_id?: boolean
    user_id?: boolean
    picture_url?: boolean
    date?: boolean
    lat?: boolean
    long?: boolean
    organisms?: boolean | organismsArgs
    users?: boolean | usersArgs
  }

  export type confirmed_sightingsInclude = {
    organisms?: boolean | organismsArgs
    users?: boolean | usersArgs
  }

  export type confirmed_sightingsGetPayload<
    S extends boolean | null | undefined | confirmed_sightingsArgs,
    U = keyof S
      > = S extends true
        ? confirmed_sightings
    : S extends undefined
    ? never
    : S extends confirmed_sightingsArgs | confirmed_sightingsFindManyArgs
    ?'include' extends U
    ? confirmed_sightings  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organisms' ? organismsGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organisms' ? organismsGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof confirmed_sightings ? confirmed_sightings[P] : never
  } 
    : confirmed_sightings
  : confirmed_sightings


  type confirmed_sightingsCountArgs = Merge<
    Omit<confirmed_sightingsFindManyArgs, 'select' | 'include'> & {
      select?: Confirmed_sightingsCountAggregateInputType | true
    }
  >

  export interface confirmed_sightingsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Confirmed_sightings that matches the filter.
     * @param {confirmed_sightingsFindUniqueArgs} args - Arguments to find a Confirmed_sightings
     * @example
     * // Get one Confirmed_sightings
     * const confirmed_sightings = await prisma.confirmed_sightings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends confirmed_sightingsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, confirmed_sightingsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'confirmed_sightings'> extends True ? CheckSelect<T, Prisma__confirmed_sightingsClient<confirmed_sightings>, Prisma__confirmed_sightingsClient<confirmed_sightingsGetPayload<T>>> : CheckSelect<T, Prisma__confirmed_sightingsClient<confirmed_sightings | null >, Prisma__confirmed_sightingsClient<confirmed_sightingsGetPayload<T> | null >>

    /**
     * Find the first Confirmed_sightings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmed_sightingsFindFirstArgs} args - Arguments to find a Confirmed_sightings
     * @example
     * // Get one Confirmed_sightings
     * const confirmed_sightings = await prisma.confirmed_sightings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends confirmed_sightingsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, confirmed_sightingsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'confirmed_sightings'> extends True ? CheckSelect<T, Prisma__confirmed_sightingsClient<confirmed_sightings>, Prisma__confirmed_sightingsClient<confirmed_sightingsGetPayload<T>>> : CheckSelect<T, Prisma__confirmed_sightingsClient<confirmed_sightings | null >, Prisma__confirmed_sightingsClient<confirmed_sightingsGetPayload<T> | null >>

    /**
     * Find zero or more Confirmed_sightings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmed_sightingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Confirmed_sightings
     * const confirmed_sightings = await prisma.confirmed_sightings.findMany()
     * 
     * // Get first 10 Confirmed_sightings
     * const confirmed_sightings = await prisma.confirmed_sightings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const confirmed_sightingsWithIdOnly = await prisma.confirmed_sightings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends confirmed_sightingsFindManyArgs>(
      args?: SelectSubset<T, confirmed_sightingsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<confirmed_sightings>>, PrismaPromise<Array<confirmed_sightingsGetPayload<T>>>>

    /**
     * Create a Confirmed_sightings.
     * @param {confirmed_sightingsCreateArgs} args - Arguments to create a Confirmed_sightings.
     * @example
     * // Create one Confirmed_sightings
     * const Confirmed_sightings = await prisma.confirmed_sightings.create({
     *   data: {
     *     // ... data to create a Confirmed_sightings
     *   }
     * })
     * 
    **/
    create<T extends confirmed_sightingsCreateArgs>(
      args: SelectSubset<T, confirmed_sightingsCreateArgs>
    ): CheckSelect<T, Prisma__confirmed_sightingsClient<confirmed_sightings>, Prisma__confirmed_sightingsClient<confirmed_sightingsGetPayload<T>>>

    /**
     * Create many Confirmed_sightings.
     *     @param {confirmed_sightingsCreateManyArgs} args - Arguments to create many Confirmed_sightings.
     *     @example
     *     // Create many Confirmed_sightings
     *     const confirmed_sightings = await prisma.confirmed_sightings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends confirmed_sightingsCreateManyArgs>(
      args?: SelectSubset<T, confirmed_sightingsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Confirmed_sightings.
     * @param {confirmed_sightingsDeleteArgs} args - Arguments to delete one Confirmed_sightings.
     * @example
     * // Delete one Confirmed_sightings
     * const Confirmed_sightings = await prisma.confirmed_sightings.delete({
     *   where: {
     *     // ... filter to delete one Confirmed_sightings
     *   }
     * })
     * 
    **/
    delete<T extends confirmed_sightingsDeleteArgs>(
      args: SelectSubset<T, confirmed_sightingsDeleteArgs>
    ): CheckSelect<T, Prisma__confirmed_sightingsClient<confirmed_sightings>, Prisma__confirmed_sightingsClient<confirmed_sightingsGetPayload<T>>>

    /**
     * Update one Confirmed_sightings.
     * @param {confirmed_sightingsUpdateArgs} args - Arguments to update one Confirmed_sightings.
     * @example
     * // Update one Confirmed_sightings
     * const confirmed_sightings = await prisma.confirmed_sightings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends confirmed_sightingsUpdateArgs>(
      args: SelectSubset<T, confirmed_sightingsUpdateArgs>
    ): CheckSelect<T, Prisma__confirmed_sightingsClient<confirmed_sightings>, Prisma__confirmed_sightingsClient<confirmed_sightingsGetPayload<T>>>

    /**
     * Delete zero or more Confirmed_sightings.
     * @param {confirmed_sightingsDeleteManyArgs} args - Arguments to filter Confirmed_sightings to delete.
     * @example
     * // Delete a few Confirmed_sightings
     * const { count } = await prisma.confirmed_sightings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends confirmed_sightingsDeleteManyArgs>(
      args?: SelectSubset<T, confirmed_sightingsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Confirmed_sightings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmed_sightingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Confirmed_sightings
     * const confirmed_sightings = await prisma.confirmed_sightings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends confirmed_sightingsUpdateManyArgs>(
      args: SelectSubset<T, confirmed_sightingsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Confirmed_sightings.
     * @param {confirmed_sightingsUpsertArgs} args - Arguments to update or create a Confirmed_sightings.
     * @example
     * // Update or create a Confirmed_sightings
     * const confirmed_sightings = await prisma.confirmed_sightings.upsert({
     *   create: {
     *     // ... data to create a Confirmed_sightings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Confirmed_sightings we want to update
     *   }
     * })
    **/
    upsert<T extends confirmed_sightingsUpsertArgs>(
      args: SelectSubset<T, confirmed_sightingsUpsertArgs>
    ): CheckSelect<T, Prisma__confirmed_sightingsClient<confirmed_sightings>, Prisma__confirmed_sightingsClient<confirmed_sightingsGetPayload<T>>>

    /**
     * Find one Confirmed_sightings that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {confirmed_sightingsFindUniqueOrThrowArgs} args - Arguments to find a Confirmed_sightings
     * @example
     * // Get one Confirmed_sightings
     * const confirmed_sightings = await prisma.confirmed_sightings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends confirmed_sightingsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, confirmed_sightingsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__confirmed_sightingsClient<confirmed_sightings>, Prisma__confirmed_sightingsClient<confirmed_sightingsGetPayload<T>>>

    /**
     * Find the first Confirmed_sightings that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmed_sightingsFindFirstOrThrowArgs} args - Arguments to find a Confirmed_sightings
     * @example
     * // Get one Confirmed_sightings
     * const confirmed_sightings = await prisma.confirmed_sightings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends confirmed_sightingsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, confirmed_sightingsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__confirmed_sightingsClient<confirmed_sightings>, Prisma__confirmed_sightingsClient<confirmed_sightingsGetPayload<T>>>

    /**
     * Count the number of Confirmed_sightings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {confirmed_sightingsCountArgs} args - Arguments to filter Confirmed_sightings to count.
     * @example
     * // Count the number of Confirmed_sightings
     * const count = await prisma.confirmed_sightings.count({
     *   where: {
     *     // ... the filter for the Confirmed_sightings we want to count
     *   }
     * })
    **/
    count<T extends confirmed_sightingsCountArgs>(
      args?: Subset<T, confirmed_sightingsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Confirmed_sightingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Confirmed_sightings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Confirmed_sightingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Confirmed_sightingsAggregateArgs>(args: Subset<T, Confirmed_sightingsAggregateArgs>): PrismaPromise<GetConfirmed_sightingsAggregateType<T>>

    /**
     * Group by Confirmed_sightings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Confirmed_sightingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Confirmed_sightingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Confirmed_sightingsGroupByArgs['orderBy'] }
        : { orderBy?: Confirmed_sightingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Confirmed_sightingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfirmed_sightingsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for confirmed_sightings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__confirmed_sightingsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organisms<T extends organismsArgs = {}>(args?: Subset<T, organismsArgs>): CheckSelect<T, Prisma__organismsClient<organisms | null >, Prisma__organismsClient<organismsGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * confirmed_sightings base type for findUnique actions
   */
  export type confirmed_sightingsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the confirmed_sightings
     * 
    **/
    select?: confirmed_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: confirmed_sightingsInclude | null
    /**
     * Filter, which confirmed_sightings to fetch.
     * 
    **/
    where: confirmed_sightingsWhereUniqueInput
  }

  /**
   * confirmed_sightings: findUnique
   */
  export interface confirmed_sightingsFindUniqueArgs extends confirmed_sightingsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * confirmed_sightings base type for findFirst actions
   */
  export type confirmed_sightingsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the confirmed_sightings
     * 
    **/
    select?: confirmed_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: confirmed_sightingsInclude | null
    /**
     * Filter, which confirmed_sightings to fetch.
     * 
    **/
    where?: confirmed_sightingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confirmed_sightings to fetch.
     * 
    **/
    orderBy?: Enumerable<confirmed_sightingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for confirmed_sightings.
     * 
    **/
    cursor?: confirmed_sightingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confirmed_sightings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confirmed_sightings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of confirmed_sightings.
     * 
    **/
    distinct?: Enumerable<Confirmed_sightingsScalarFieldEnum>
  }

  /**
   * confirmed_sightings: findFirst
   */
  export interface confirmed_sightingsFindFirstArgs extends confirmed_sightingsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * confirmed_sightings findMany
   */
  export type confirmed_sightingsFindManyArgs = {
    /**
     * Select specific fields to fetch from the confirmed_sightings
     * 
    **/
    select?: confirmed_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: confirmed_sightingsInclude | null
    /**
     * Filter, which confirmed_sightings to fetch.
     * 
    **/
    where?: confirmed_sightingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of confirmed_sightings to fetch.
     * 
    **/
    orderBy?: Enumerable<confirmed_sightingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing confirmed_sightings.
     * 
    **/
    cursor?: confirmed_sightingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` confirmed_sightings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` confirmed_sightings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Confirmed_sightingsScalarFieldEnum>
  }


  /**
   * confirmed_sightings create
   */
  export type confirmed_sightingsCreateArgs = {
    /**
     * Select specific fields to fetch from the confirmed_sightings
     * 
    **/
    select?: confirmed_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: confirmed_sightingsInclude | null
    /**
     * The data needed to create a confirmed_sightings.
     * 
    **/
    data: XOR<confirmed_sightingsCreateInput, confirmed_sightingsUncheckedCreateInput>
  }


  /**
   * confirmed_sightings createMany
   */
  export type confirmed_sightingsCreateManyArgs = {
    /**
     * The data used to create many confirmed_sightings.
     * 
    **/
    data: Enumerable<confirmed_sightingsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * confirmed_sightings update
   */
  export type confirmed_sightingsUpdateArgs = {
    /**
     * Select specific fields to fetch from the confirmed_sightings
     * 
    **/
    select?: confirmed_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: confirmed_sightingsInclude | null
    /**
     * The data needed to update a confirmed_sightings.
     * 
    **/
    data: XOR<confirmed_sightingsUpdateInput, confirmed_sightingsUncheckedUpdateInput>
    /**
     * Choose, which confirmed_sightings to update.
     * 
    **/
    where: confirmed_sightingsWhereUniqueInput
  }


  /**
   * confirmed_sightings updateMany
   */
  export type confirmed_sightingsUpdateManyArgs = {
    /**
     * The data used to update confirmed_sightings.
     * 
    **/
    data: XOR<confirmed_sightingsUpdateManyMutationInput, confirmed_sightingsUncheckedUpdateManyInput>
    /**
     * Filter which confirmed_sightings to update
     * 
    **/
    where?: confirmed_sightingsWhereInput
  }


  /**
   * confirmed_sightings upsert
   */
  export type confirmed_sightingsUpsertArgs = {
    /**
     * Select specific fields to fetch from the confirmed_sightings
     * 
    **/
    select?: confirmed_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: confirmed_sightingsInclude | null
    /**
     * The filter to search for the confirmed_sightings to update in case it exists.
     * 
    **/
    where: confirmed_sightingsWhereUniqueInput
    /**
     * In case the confirmed_sightings found by the `where` argument doesn't exist, create a new confirmed_sightings with this data.
     * 
    **/
    create: XOR<confirmed_sightingsCreateInput, confirmed_sightingsUncheckedCreateInput>
    /**
     * In case the confirmed_sightings was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<confirmed_sightingsUpdateInput, confirmed_sightingsUncheckedUpdateInput>
  }


  /**
   * confirmed_sightings delete
   */
  export type confirmed_sightingsDeleteArgs = {
    /**
     * Select specific fields to fetch from the confirmed_sightings
     * 
    **/
    select?: confirmed_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: confirmed_sightingsInclude | null
    /**
     * Filter which confirmed_sightings to delete.
     * 
    **/
    where: confirmed_sightingsWhereUniqueInput
  }


  /**
   * confirmed_sightings deleteMany
   */
  export type confirmed_sightingsDeleteManyArgs = {
    /**
     * Filter which confirmed_sightings to delete
     * 
    **/
    where?: confirmed_sightingsWhereInput
  }


  /**
   * confirmed_sightings: findUniqueOrThrow
   */
  export type confirmed_sightingsFindUniqueOrThrowArgs = confirmed_sightingsFindUniqueArgsBase
      

  /**
   * confirmed_sightings: findFirstOrThrow
   */
  export type confirmed_sightingsFindFirstOrThrowArgs = confirmed_sightingsFindFirstArgsBase
      

  /**
   * confirmed_sightings without action
   */
  export type confirmed_sightingsArgs = {
    /**
     * Select specific fields to fetch from the confirmed_sightings
     * 
    **/
    select?: confirmed_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: confirmed_sightingsInclude | null
  }



  /**
   * Model flyway_schema_history
   */


  export type AggregateFlyway_schema_history = {
    _count: Flyway_schema_historyCountAggregateOutputType | null
    _avg: Flyway_schema_historyAvgAggregateOutputType | null
    _sum: Flyway_schema_historySumAggregateOutputType | null
    _min: Flyway_schema_historyMinAggregateOutputType | null
    _max: Flyway_schema_historyMaxAggregateOutputType | null
  }

  export type Flyway_schema_historyAvgAggregateOutputType = {
    installed_rank: number | null
    checksum: number | null
    execution_time: number | null
  }

  export type Flyway_schema_historySumAggregateOutputType = {
    installed_rank: number | null
    checksum: number | null
    execution_time: number | null
  }

  export type Flyway_schema_historyMinAggregateOutputType = {
    installed_rank: number | null
    version: string | null
    description: string | null
    type: string | null
    script: string | null
    checksum: number | null
    installed_by: string | null
    installed_on: Date | null
    execution_time: number | null
    success: boolean | null
  }

  export type Flyway_schema_historyMaxAggregateOutputType = {
    installed_rank: number | null
    version: string | null
    description: string | null
    type: string | null
    script: string | null
    checksum: number | null
    installed_by: string | null
    installed_on: Date | null
    execution_time: number | null
    success: boolean | null
  }

  export type Flyway_schema_historyCountAggregateOutputType = {
    installed_rank: number
    version: number
    description: number
    type: number
    script: number
    checksum: number
    installed_by: number
    installed_on: number
    execution_time: number
    success: number
    _all: number
  }


  export type Flyway_schema_historyAvgAggregateInputType = {
    installed_rank?: true
    checksum?: true
    execution_time?: true
  }

  export type Flyway_schema_historySumAggregateInputType = {
    installed_rank?: true
    checksum?: true
    execution_time?: true
  }

  export type Flyway_schema_historyMinAggregateInputType = {
    installed_rank?: true
    version?: true
    description?: true
    type?: true
    script?: true
    checksum?: true
    installed_by?: true
    installed_on?: true
    execution_time?: true
    success?: true
  }

  export type Flyway_schema_historyMaxAggregateInputType = {
    installed_rank?: true
    version?: true
    description?: true
    type?: true
    script?: true
    checksum?: true
    installed_by?: true
    installed_on?: true
    execution_time?: true
    success?: true
  }

  export type Flyway_schema_historyCountAggregateInputType = {
    installed_rank?: true
    version?: true
    description?: true
    type?: true
    script?: true
    checksum?: true
    installed_by?: true
    installed_on?: true
    execution_time?: true
    success?: true
    _all?: true
  }

  export type Flyway_schema_historyAggregateArgs = {
    /**
     * Filter which flyway_schema_history to aggregate.
     * 
    **/
    where?: flyway_schema_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flyway_schema_histories to fetch.
     * 
    **/
    orderBy?: Enumerable<flyway_schema_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: flyway_schema_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flyway_schema_histories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flyway_schema_histories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned flyway_schema_histories
    **/
    _count?: true | Flyway_schema_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Flyway_schema_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Flyway_schema_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Flyway_schema_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Flyway_schema_historyMaxAggregateInputType
  }

  export type GetFlyway_schema_historyAggregateType<T extends Flyway_schema_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateFlyway_schema_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFlyway_schema_history[P]>
      : GetScalarType<T[P], AggregateFlyway_schema_history[P]>
  }




  export type Flyway_schema_historyGroupByArgs = {
    where?: flyway_schema_historyWhereInput
    orderBy?: Enumerable<flyway_schema_historyOrderByWithAggregationInput>
    by: Array<Flyway_schema_historyScalarFieldEnum>
    having?: flyway_schema_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Flyway_schema_historyCountAggregateInputType | true
    _avg?: Flyway_schema_historyAvgAggregateInputType
    _sum?: Flyway_schema_historySumAggregateInputType
    _min?: Flyway_schema_historyMinAggregateInputType
    _max?: Flyway_schema_historyMaxAggregateInputType
  }


  export type Flyway_schema_historyGroupByOutputType = {
    installed_rank: number
    version: string | null
    description: string
    type: string
    script: string
    checksum: number | null
    installed_by: string
    installed_on: Date
    execution_time: number
    success: boolean
    _count: Flyway_schema_historyCountAggregateOutputType | null
    _avg: Flyway_schema_historyAvgAggregateOutputType | null
    _sum: Flyway_schema_historySumAggregateOutputType | null
    _min: Flyway_schema_historyMinAggregateOutputType | null
    _max: Flyway_schema_historyMaxAggregateOutputType | null
  }

  type GetFlyway_schema_historyGroupByPayload<T extends Flyway_schema_historyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Flyway_schema_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Flyway_schema_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Flyway_schema_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Flyway_schema_historyGroupByOutputType[P]>
        }
      >
    >


  export type flyway_schema_historySelect = {
    installed_rank?: boolean
    version?: boolean
    description?: boolean
    type?: boolean
    script?: boolean
    checksum?: boolean
    installed_by?: boolean
    installed_on?: boolean
    execution_time?: boolean
    success?: boolean
  }

  export type flyway_schema_historyGetPayload<
    S extends boolean | null | undefined | flyway_schema_historyArgs,
    U = keyof S
      > = S extends true
        ? flyway_schema_history
    : S extends undefined
    ? never
    : S extends flyway_schema_historyArgs | flyway_schema_historyFindManyArgs
    ?'include' extends U
    ? flyway_schema_history 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof flyway_schema_history ? flyway_schema_history[P] : never
  } 
    : flyway_schema_history
  : flyway_schema_history


  type flyway_schema_historyCountArgs = Merge<
    Omit<flyway_schema_historyFindManyArgs, 'select' | 'include'> & {
      select?: Flyway_schema_historyCountAggregateInputType | true
    }
  >

  export interface flyway_schema_historyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Flyway_schema_history that matches the filter.
     * @param {flyway_schema_historyFindUniqueArgs} args - Arguments to find a Flyway_schema_history
     * @example
     * // Get one Flyway_schema_history
     * const flyway_schema_history = await prisma.flyway_schema_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends flyway_schema_historyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, flyway_schema_historyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'flyway_schema_history'> extends True ? CheckSelect<T, Prisma__flyway_schema_historyClient<flyway_schema_history>, Prisma__flyway_schema_historyClient<flyway_schema_historyGetPayload<T>>> : CheckSelect<T, Prisma__flyway_schema_historyClient<flyway_schema_history | null >, Prisma__flyway_schema_historyClient<flyway_schema_historyGetPayload<T> | null >>

    /**
     * Find the first Flyway_schema_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flyway_schema_historyFindFirstArgs} args - Arguments to find a Flyway_schema_history
     * @example
     * // Get one Flyway_schema_history
     * const flyway_schema_history = await prisma.flyway_schema_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends flyway_schema_historyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, flyway_schema_historyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'flyway_schema_history'> extends True ? CheckSelect<T, Prisma__flyway_schema_historyClient<flyway_schema_history>, Prisma__flyway_schema_historyClient<flyway_schema_historyGetPayload<T>>> : CheckSelect<T, Prisma__flyway_schema_historyClient<flyway_schema_history | null >, Prisma__flyway_schema_historyClient<flyway_schema_historyGetPayload<T> | null >>

    /**
     * Find zero or more Flyway_schema_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flyway_schema_historyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Flyway_schema_histories
     * const flyway_schema_histories = await prisma.flyway_schema_history.findMany()
     * 
     * // Get first 10 Flyway_schema_histories
     * const flyway_schema_histories = await prisma.flyway_schema_history.findMany({ take: 10 })
     * 
     * // Only select the `installed_rank`
     * const flyway_schema_historyWithInstalled_rankOnly = await prisma.flyway_schema_history.findMany({ select: { installed_rank: true } })
     * 
    **/
    findMany<T extends flyway_schema_historyFindManyArgs>(
      args?: SelectSubset<T, flyway_schema_historyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<flyway_schema_history>>, PrismaPromise<Array<flyway_schema_historyGetPayload<T>>>>

    /**
     * Create a Flyway_schema_history.
     * @param {flyway_schema_historyCreateArgs} args - Arguments to create a Flyway_schema_history.
     * @example
     * // Create one Flyway_schema_history
     * const Flyway_schema_history = await prisma.flyway_schema_history.create({
     *   data: {
     *     // ... data to create a Flyway_schema_history
     *   }
     * })
     * 
    **/
    create<T extends flyway_schema_historyCreateArgs>(
      args: SelectSubset<T, flyway_schema_historyCreateArgs>
    ): CheckSelect<T, Prisma__flyway_schema_historyClient<flyway_schema_history>, Prisma__flyway_schema_historyClient<flyway_schema_historyGetPayload<T>>>

    /**
     * Create many Flyway_schema_histories.
     *     @param {flyway_schema_historyCreateManyArgs} args - Arguments to create many Flyway_schema_histories.
     *     @example
     *     // Create many Flyway_schema_histories
     *     const flyway_schema_history = await prisma.flyway_schema_history.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends flyway_schema_historyCreateManyArgs>(
      args?: SelectSubset<T, flyway_schema_historyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Flyway_schema_history.
     * @param {flyway_schema_historyDeleteArgs} args - Arguments to delete one Flyway_schema_history.
     * @example
     * // Delete one Flyway_schema_history
     * const Flyway_schema_history = await prisma.flyway_schema_history.delete({
     *   where: {
     *     // ... filter to delete one Flyway_schema_history
     *   }
     * })
     * 
    **/
    delete<T extends flyway_schema_historyDeleteArgs>(
      args: SelectSubset<T, flyway_schema_historyDeleteArgs>
    ): CheckSelect<T, Prisma__flyway_schema_historyClient<flyway_schema_history>, Prisma__flyway_schema_historyClient<flyway_schema_historyGetPayload<T>>>

    /**
     * Update one Flyway_schema_history.
     * @param {flyway_schema_historyUpdateArgs} args - Arguments to update one Flyway_schema_history.
     * @example
     * // Update one Flyway_schema_history
     * const flyway_schema_history = await prisma.flyway_schema_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends flyway_schema_historyUpdateArgs>(
      args: SelectSubset<T, flyway_schema_historyUpdateArgs>
    ): CheckSelect<T, Prisma__flyway_schema_historyClient<flyway_schema_history>, Prisma__flyway_schema_historyClient<flyway_schema_historyGetPayload<T>>>

    /**
     * Delete zero or more Flyway_schema_histories.
     * @param {flyway_schema_historyDeleteManyArgs} args - Arguments to filter Flyway_schema_histories to delete.
     * @example
     * // Delete a few Flyway_schema_histories
     * const { count } = await prisma.flyway_schema_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends flyway_schema_historyDeleteManyArgs>(
      args?: SelectSubset<T, flyway_schema_historyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Flyway_schema_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flyway_schema_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Flyway_schema_histories
     * const flyway_schema_history = await prisma.flyway_schema_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends flyway_schema_historyUpdateManyArgs>(
      args: SelectSubset<T, flyway_schema_historyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Flyway_schema_history.
     * @param {flyway_schema_historyUpsertArgs} args - Arguments to update or create a Flyway_schema_history.
     * @example
     * // Update or create a Flyway_schema_history
     * const flyway_schema_history = await prisma.flyway_schema_history.upsert({
     *   create: {
     *     // ... data to create a Flyway_schema_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Flyway_schema_history we want to update
     *   }
     * })
    **/
    upsert<T extends flyway_schema_historyUpsertArgs>(
      args: SelectSubset<T, flyway_schema_historyUpsertArgs>
    ): CheckSelect<T, Prisma__flyway_schema_historyClient<flyway_schema_history>, Prisma__flyway_schema_historyClient<flyway_schema_historyGetPayload<T>>>

    /**
     * Find one Flyway_schema_history that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {flyway_schema_historyFindUniqueOrThrowArgs} args - Arguments to find a Flyway_schema_history
     * @example
     * // Get one Flyway_schema_history
     * const flyway_schema_history = await prisma.flyway_schema_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends flyway_schema_historyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, flyway_schema_historyFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__flyway_schema_historyClient<flyway_schema_history>, Prisma__flyway_schema_historyClient<flyway_schema_historyGetPayload<T>>>

    /**
     * Find the first Flyway_schema_history that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flyway_schema_historyFindFirstOrThrowArgs} args - Arguments to find a Flyway_schema_history
     * @example
     * // Get one Flyway_schema_history
     * const flyway_schema_history = await prisma.flyway_schema_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends flyway_schema_historyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, flyway_schema_historyFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__flyway_schema_historyClient<flyway_schema_history>, Prisma__flyway_schema_historyClient<flyway_schema_historyGetPayload<T>>>

    /**
     * Count the number of Flyway_schema_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {flyway_schema_historyCountArgs} args - Arguments to filter Flyway_schema_histories to count.
     * @example
     * // Count the number of Flyway_schema_histories
     * const count = await prisma.flyway_schema_history.count({
     *   where: {
     *     // ... the filter for the Flyway_schema_histories we want to count
     *   }
     * })
    **/
    count<T extends flyway_schema_historyCountArgs>(
      args?: Subset<T, flyway_schema_historyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Flyway_schema_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Flyway_schema_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Flyway_schema_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Flyway_schema_historyAggregateArgs>(args: Subset<T, Flyway_schema_historyAggregateArgs>): PrismaPromise<GetFlyway_schema_historyAggregateType<T>>

    /**
     * Group by Flyway_schema_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Flyway_schema_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Flyway_schema_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Flyway_schema_historyGroupByArgs['orderBy'] }
        : { orderBy?: Flyway_schema_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Flyway_schema_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFlyway_schema_historyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for flyway_schema_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__flyway_schema_historyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * flyway_schema_history base type for findUnique actions
   */
  export type flyway_schema_historyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     * 
    **/
    select?: flyway_schema_historySelect | null
    /**
     * Filter, which flyway_schema_history to fetch.
     * 
    **/
    where: flyway_schema_historyWhereUniqueInput
  }

  /**
   * flyway_schema_history: findUnique
   */
  export interface flyway_schema_historyFindUniqueArgs extends flyway_schema_historyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * flyway_schema_history base type for findFirst actions
   */
  export type flyway_schema_historyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     * 
    **/
    select?: flyway_schema_historySelect | null
    /**
     * Filter, which flyway_schema_history to fetch.
     * 
    **/
    where?: flyway_schema_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flyway_schema_histories to fetch.
     * 
    **/
    orderBy?: Enumerable<flyway_schema_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for flyway_schema_histories.
     * 
    **/
    cursor?: flyway_schema_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flyway_schema_histories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flyway_schema_histories.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of flyway_schema_histories.
     * 
    **/
    distinct?: Enumerable<Flyway_schema_historyScalarFieldEnum>
  }

  /**
   * flyway_schema_history: findFirst
   */
  export interface flyway_schema_historyFindFirstArgs extends flyway_schema_historyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * flyway_schema_history findMany
   */
  export type flyway_schema_historyFindManyArgs = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     * 
    **/
    select?: flyway_schema_historySelect | null
    /**
     * Filter, which flyway_schema_histories to fetch.
     * 
    **/
    where?: flyway_schema_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of flyway_schema_histories to fetch.
     * 
    **/
    orderBy?: Enumerable<flyway_schema_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing flyway_schema_histories.
     * 
    **/
    cursor?: flyway_schema_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` flyway_schema_histories from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` flyway_schema_histories.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Flyway_schema_historyScalarFieldEnum>
  }


  /**
   * flyway_schema_history create
   */
  export type flyway_schema_historyCreateArgs = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     * 
    **/
    select?: flyway_schema_historySelect | null
    /**
     * The data needed to create a flyway_schema_history.
     * 
    **/
    data: XOR<flyway_schema_historyCreateInput, flyway_schema_historyUncheckedCreateInput>
  }


  /**
   * flyway_schema_history createMany
   */
  export type flyway_schema_historyCreateManyArgs = {
    /**
     * The data used to create many flyway_schema_histories.
     * 
    **/
    data: Enumerable<flyway_schema_historyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * flyway_schema_history update
   */
  export type flyway_schema_historyUpdateArgs = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     * 
    **/
    select?: flyway_schema_historySelect | null
    /**
     * The data needed to update a flyway_schema_history.
     * 
    **/
    data: XOR<flyway_schema_historyUpdateInput, flyway_schema_historyUncheckedUpdateInput>
    /**
     * Choose, which flyway_schema_history to update.
     * 
    **/
    where: flyway_schema_historyWhereUniqueInput
  }


  /**
   * flyway_schema_history updateMany
   */
  export type flyway_schema_historyUpdateManyArgs = {
    /**
     * The data used to update flyway_schema_histories.
     * 
    **/
    data: XOR<flyway_schema_historyUpdateManyMutationInput, flyway_schema_historyUncheckedUpdateManyInput>
    /**
     * Filter which flyway_schema_histories to update
     * 
    **/
    where?: flyway_schema_historyWhereInput
  }


  /**
   * flyway_schema_history upsert
   */
  export type flyway_schema_historyUpsertArgs = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     * 
    **/
    select?: flyway_schema_historySelect | null
    /**
     * The filter to search for the flyway_schema_history to update in case it exists.
     * 
    **/
    where: flyway_schema_historyWhereUniqueInput
    /**
     * In case the flyway_schema_history found by the `where` argument doesn't exist, create a new flyway_schema_history with this data.
     * 
    **/
    create: XOR<flyway_schema_historyCreateInput, flyway_schema_historyUncheckedCreateInput>
    /**
     * In case the flyway_schema_history was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<flyway_schema_historyUpdateInput, flyway_schema_historyUncheckedUpdateInput>
  }


  /**
   * flyway_schema_history delete
   */
  export type flyway_schema_historyDeleteArgs = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     * 
    **/
    select?: flyway_schema_historySelect | null
    /**
     * Filter which flyway_schema_history to delete.
     * 
    **/
    where: flyway_schema_historyWhereUniqueInput
  }


  /**
   * flyway_schema_history deleteMany
   */
  export type flyway_schema_historyDeleteManyArgs = {
    /**
     * Filter which flyway_schema_histories to delete
     * 
    **/
    where?: flyway_schema_historyWhereInput
  }


  /**
   * flyway_schema_history: findUniqueOrThrow
   */
  export type flyway_schema_historyFindUniqueOrThrowArgs = flyway_schema_historyFindUniqueArgsBase
      

  /**
   * flyway_schema_history: findFirstOrThrow
   */
  export type flyway_schema_historyFindFirstOrThrowArgs = flyway_schema_historyFindFirstArgsBase
      

  /**
   * flyway_schema_history without action
   */
  export type flyway_schema_historyArgs = {
    /**
     * Select specific fields to fetch from the flyway_schema_history
     * 
    **/
    select?: flyway_schema_historySelect | null
  }



  /**
   * Model interest_groups
   */


  export type AggregateInterest_groups = {
    _count: Interest_groupsCountAggregateOutputType | null
    _avg: Interest_groupsAvgAggregateOutputType | null
    _sum: Interest_groupsSumAggregateOutputType | null
    _min: Interest_groupsMinAggregateOutputType | null
    _max: Interest_groupsMaxAggregateOutputType | null
  }

  export type Interest_groupsAvgAggregateOutputType = {
    id: number | null
  }

  export type Interest_groupsSumAggregateOutputType = {
    id: number | null
  }

  export type Interest_groupsMinAggregateOutputType = {
    id: number | null
    group_name: string | null
    description: string | null
  }

  export type Interest_groupsMaxAggregateOutputType = {
    id: number | null
    group_name: string | null
    description: string | null
  }

  export type Interest_groupsCountAggregateOutputType = {
    id: number
    group_name: number
    description: number
    _all: number
  }


  export type Interest_groupsAvgAggregateInputType = {
    id?: true
  }

  export type Interest_groupsSumAggregateInputType = {
    id?: true
  }

  export type Interest_groupsMinAggregateInputType = {
    id?: true
    group_name?: true
    description?: true
  }

  export type Interest_groupsMaxAggregateInputType = {
    id?: true
    group_name?: true
    description?: true
  }

  export type Interest_groupsCountAggregateInputType = {
    id?: true
    group_name?: true
    description?: true
    _all?: true
  }

  export type Interest_groupsAggregateArgs = {
    /**
     * Filter which interest_groups to aggregate.
     * 
    **/
    where?: interest_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of interest_groups to fetch.
     * 
    **/
    orderBy?: Enumerable<interest_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: interest_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` interest_groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` interest_groups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned interest_groups
    **/
    _count?: true | Interest_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Interest_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Interest_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Interest_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Interest_groupsMaxAggregateInputType
  }

  export type GetInterest_groupsAggregateType<T extends Interest_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateInterest_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInterest_groups[P]>
      : GetScalarType<T[P], AggregateInterest_groups[P]>
  }




  export type Interest_groupsGroupByArgs = {
    where?: interest_groupsWhereInput
    orderBy?: Enumerable<interest_groupsOrderByWithAggregationInput>
    by: Array<Interest_groupsScalarFieldEnum>
    having?: interest_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Interest_groupsCountAggregateInputType | true
    _avg?: Interest_groupsAvgAggregateInputType
    _sum?: Interest_groupsSumAggregateInputType
    _min?: Interest_groupsMinAggregateInputType
    _max?: Interest_groupsMaxAggregateInputType
  }


  export type Interest_groupsGroupByOutputType = {
    id: number
    group_name: string
    description: string | null
    _count: Interest_groupsCountAggregateOutputType | null
    _avg: Interest_groupsAvgAggregateOutputType | null
    _sum: Interest_groupsSumAggregateOutputType | null
    _min: Interest_groupsMinAggregateOutputType | null
    _max: Interest_groupsMaxAggregateOutputType | null
  }

  type GetInterest_groupsGroupByPayload<T extends Interest_groupsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Interest_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Interest_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Interest_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Interest_groupsGroupByOutputType[P]>
        }
      >
    >


  export type interest_groupsSelect = {
    id?: boolean
    group_name?: boolean
    description?: boolean
    users_to_groups?: boolean | users_to_groupsFindManyArgs
    _count?: boolean | Interest_groupsCountOutputTypeArgs
  }

  export type interest_groupsInclude = {
    users_to_groups?: boolean | users_to_groupsFindManyArgs
    _count?: boolean | Interest_groupsCountOutputTypeArgs
  }

  export type interest_groupsGetPayload<
    S extends boolean | null | undefined | interest_groupsArgs,
    U = keyof S
      > = S extends true
        ? interest_groups
    : S extends undefined
    ? never
    : S extends interest_groupsArgs | interest_groupsFindManyArgs
    ?'include' extends U
    ? interest_groups  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users_to_groups' ? Array < users_to_groupsGetPayload<S['include'][P]>>  :
        P extends '_count' ? Interest_groupsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users_to_groups' ? Array < users_to_groupsGetPayload<S['select'][P]>>  :
        P extends '_count' ? Interest_groupsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof interest_groups ? interest_groups[P] : never
  } 
    : interest_groups
  : interest_groups


  type interest_groupsCountArgs = Merge<
    Omit<interest_groupsFindManyArgs, 'select' | 'include'> & {
      select?: Interest_groupsCountAggregateInputType | true
    }
  >

  export interface interest_groupsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Interest_groups that matches the filter.
     * @param {interest_groupsFindUniqueArgs} args - Arguments to find a Interest_groups
     * @example
     * // Get one Interest_groups
     * const interest_groups = await prisma.interest_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends interest_groupsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, interest_groupsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'interest_groups'> extends True ? CheckSelect<T, Prisma__interest_groupsClient<interest_groups>, Prisma__interest_groupsClient<interest_groupsGetPayload<T>>> : CheckSelect<T, Prisma__interest_groupsClient<interest_groups | null >, Prisma__interest_groupsClient<interest_groupsGetPayload<T> | null >>

    /**
     * Find the first Interest_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interest_groupsFindFirstArgs} args - Arguments to find a Interest_groups
     * @example
     * // Get one Interest_groups
     * const interest_groups = await prisma.interest_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends interest_groupsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, interest_groupsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'interest_groups'> extends True ? CheckSelect<T, Prisma__interest_groupsClient<interest_groups>, Prisma__interest_groupsClient<interest_groupsGetPayload<T>>> : CheckSelect<T, Prisma__interest_groupsClient<interest_groups | null >, Prisma__interest_groupsClient<interest_groupsGetPayload<T> | null >>

    /**
     * Find zero or more Interest_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interest_groupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interest_groups
     * const interest_groups = await prisma.interest_groups.findMany()
     * 
     * // Get first 10 Interest_groups
     * const interest_groups = await prisma.interest_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interest_groupsWithIdOnly = await prisma.interest_groups.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends interest_groupsFindManyArgs>(
      args?: SelectSubset<T, interest_groupsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<interest_groups>>, PrismaPromise<Array<interest_groupsGetPayload<T>>>>

    /**
     * Create a Interest_groups.
     * @param {interest_groupsCreateArgs} args - Arguments to create a Interest_groups.
     * @example
     * // Create one Interest_groups
     * const Interest_groups = await prisma.interest_groups.create({
     *   data: {
     *     // ... data to create a Interest_groups
     *   }
     * })
     * 
    **/
    create<T extends interest_groupsCreateArgs>(
      args: SelectSubset<T, interest_groupsCreateArgs>
    ): CheckSelect<T, Prisma__interest_groupsClient<interest_groups>, Prisma__interest_groupsClient<interest_groupsGetPayload<T>>>

    /**
     * Create many Interest_groups.
     *     @param {interest_groupsCreateManyArgs} args - Arguments to create many Interest_groups.
     *     @example
     *     // Create many Interest_groups
     *     const interest_groups = await prisma.interest_groups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends interest_groupsCreateManyArgs>(
      args?: SelectSubset<T, interest_groupsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Interest_groups.
     * @param {interest_groupsDeleteArgs} args - Arguments to delete one Interest_groups.
     * @example
     * // Delete one Interest_groups
     * const Interest_groups = await prisma.interest_groups.delete({
     *   where: {
     *     // ... filter to delete one Interest_groups
     *   }
     * })
     * 
    **/
    delete<T extends interest_groupsDeleteArgs>(
      args: SelectSubset<T, interest_groupsDeleteArgs>
    ): CheckSelect<T, Prisma__interest_groupsClient<interest_groups>, Prisma__interest_groupsClient<interest_groupsGetPayload<T>>>

    /**
     * Update one Interest_groups.
     * @param {interest_groupsUpdateArgs} args - Arguments to update one Interest_groups.
     * @example
     * // Update one Interest_groups
     * const interest_groups = await prisma.interest_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends interest_groupsUpdateArgs>(
      args: SelectSubset<T, interest_groupsUpdateArgs>
    ): CheckSelect<T, Prisma__interest_groupsClient<interest_groups>, Prisma__interest_groupsClient<interest_groupsGetPayload<T>>>

    /**
     * Delete zero or more Interest_groups.
     * @param {interest_groupsDeleteManyArgs} args - Arguments to filter Interest_groups to delete.
     * @example
     * // Delete a few Interest_groups
     * const { count } = await prisma.interest_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends interest_groupsDeleteManyArgs>(
      args?: SelectSubset<T, interest_groupsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interest_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interest_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interest_groups
     * const interest_groups = await prisma.interest_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends interest_groupsUpdateManyArgs>(
      args: SelectSubset<T, interest_groupsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Interest_groups.
     * @param {interest_groupsUpsertArgs} args - Arguments to update or create a Interest_groups.
     * @example
     * // Update or create a Interest_groups
     * const interest_groups = await prisma.interest_groups.upsert({
     *   create: {
     *     // ... data to create a Interest_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interest_groups we want to update
     *   }
     * })
    **/
    upsert<T extends interest_groupsUpsertArgs>(
      args: SelectSubset<T, interest_groupsUpsertArgs>
    ): CheckSelect<T, Prisma__interest_groupsClient<interest_groups>, Prisma__interest_groupsClient<interest_groupsGetPayload<T>>>

    /**
     * Find one Interest_groups that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {interest_groupsFindUniqueOrThrowArgs} args - Arguments to find a Interest_groups
     * @example
     * // Get one Interest_groups
     * const interest_groups = await prisma.interest_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends interest_groupsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, interest_groupsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__interest_groupsClient<interest_groups>, Prisma__interest_groupsClient<interest_groupsGetPayload<T>>>

    /**
     * Find the first Interest_groups that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interest_groupsFindFirstOrThrowArgs} args - Arguments to find a Interest_groups
     * @example
     * // Get one Interest_groups
     * const interest_groups = await prisma.interest_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends interest_groupsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, interest_groupsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__interest_groupsClient<interest_groups>, Prisma__interest_groupsClient<interest_groupsGetPayload<T>>>

    /**
     * Count the number of Interest_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {interest_groupsCountArgs} args - Arguments to filter Interest_groups to count.
     * @example
     * // Count the number of Interest_groups
     * const count = await prisma.interest_groups.count({
     *   where: {
     *     // ... the filter for the Interest_groups we want to count
     *   }
     * })
    **/
    count<T extends interest_groupsCountArgs>(
      args?: Subset<T, interest_groupsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Interest_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interest_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Interest_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Interest_groupsAggregateArgs>(args: Subset<T, Interest_groupsAggregateArgs>): PrismaPromise<GetInterest_groupsAggregateType<T>>

    /**
     * Group by Interest_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Interest_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Interest_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Interest_groupsGroupByArgs['orderBy'] }
        : { orderBy?: Interest_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Interest_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInterest_groupsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for interest_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__interest_groupsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users_to_groups<T extends users_to_groupsFindManyArgs = {}>(args?: Subset<T, users_to_groupsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<users_to_groups>>, PrismaPromise<Array<users_to_groupsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * interest_groups base type for findUnique actions
   */
  export type interest_groupsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the interest_groups
     * 
    **/
    select?: interest_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: interest_groupsInclude | null
    /**
     * Filter, which interest_groups to fetch.
     * 
    **/
    where: interest_groupsWhereUniqueInput
  }

  /**
   * interest_groups: findUnique
   */
  export interface interest_groupsFindUniqueArgs extends interest_groupsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * interest_groups base type for findFirst actions
   */
  export type interest_groupsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the interest_groups
     * 
    **/
    select?: interest_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: interest_groupsInclude | null
    /**
     * Filter, which interest_groups to fetch.
     * 
    **/
    where?: interest_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of interest_groups to fetch.
     * 
    **/
    orderBy?: Enumerable<interest_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for interest_groups.
     * 
    **/
    cursor?: interest_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` interest_groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` interest_groups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of interest_groups.
     * 
    **/
    distinct?: Enumerable<Interest_groupsScalarFieldEnum>
  }

  /**
   * interest_groups: findFirst
   */
  export interface interest_groupsFindFirstArgs extends interest_groupsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * interest_groups findMany
   */
  export type interest_groupsFindManyArgs = {
    /**
     * Select specific fields to fetch from the interest_groups
     * 
    **/
    select?: interest_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: interest_groupsInclude | null
    /**
     * Filter, which interest_groups to fetch.
     * 
    **/
    where?: interest_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of interest_groups to fetch.
     * 
    **/
    orderBy?: Enumerable<interest_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing interest_groups.
     * 
    **/
    cursor?: interest_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` interest_groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` interest_groups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Interest_groupsScalarFieldEnum>
  }


  /**
   * interest_groups create
   */
  export type interest_groupsCreateArgs = {
    /**
     * Select specific fields to fetch from the interest_groups
     * 
    **/
    select?: interest_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: interest_groupsInclude | null
    /**
     * The data needed to create a interest_groups.
     * 
    **/
    data: XOR<interest_groupsCreateInput, interest_groupsUncheckedCreateInput>
  }


  /**
   * interest_groups createMany
   */
  export type interest_groupsCreateManyArgs = {
    /**
     * The data used to create many interest_groups.
     * 
    **/
    data: Enumerable<interest_groupsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * interest_groups update
   */
  export type interest_groupsUpdateArgs = {
    /**
     * Select specific fields to fetch from the interest_groups
     * 
    **/
    select?: interest_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: interest_groupsInclude | null
    /**
     * The data needed to update a interest_groups.
     * 
    **/
    data: XOR<interest_groupsUpdateInput, interest_groupsUncheckedUpdateInput>
    /**
     * Choose, which interest_groups to update.
     * 
    **/
    where: interest_groupsWhereUniqueInput
  }


  /**
   * interest_groups updateMany
   */
  export type interest_groupsUpdateManyArgs = {
    /**
     * The data used to update interest_groups.
     * 
    **/
    data: XOR<interest_groupsUpdateManyMutationInput, interest_groupsUncheckedUpdateManyInput>
    /**
     * Filter which interest_groups to update
     * 
    **/
    where?: interest_groupsWhereInput
  }


  /**
   * interest_groups upsert
   */
  export type interest_groupsUpsertArgs = {
    /**
     * Select specific fields to fetch from the interest_groups
     * 
    **/
    select?: interest_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: interest_groupsInclude | null
    /**
     * The filter to search for the interest_groups to update in case it exists.
     * 
    **/
    where: interest_groupsWhereUniqueInput
    /**
     * In case the interest_groups found by the `where` argument doesn't exist, create a new interest_groups with this data.
     * 
    **/
    create: XOR<interest_groupsCreateInput, interest_groupsUncheckedCreateInput>
    /**
     * In case the interest_groups was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<interest_groupsUpdateInput, interest_groupsUncheckedUpdateInput>
  }


  /**
   * interest_groups delete
   */
  export type interest_groupsDeleteArgs = {
    /**
     * Select specific fields to fetch from the interest_groups
     * 
    **/
    select?: interest_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: interest_groupsInclude | null
    /**
     * Filter which interest_groups to delete.
     * 
    **/
    where: interest_groupsWhereUniqueInput
  }


  /**
   * interest_groups deleteMany
   */
  export type interest_groupsDeleteManyArgs = {
    /**
     * Filter which interest_groups to delete
     * 
    **/
    where?: interest_groupsWhereInput
  }


  /**
   * interest_groups: findUniqueOrThrow
   */
  export type interest_groupsFindUniqueOrThrowArgs = interest_groupsFindUniqueArgsBase
      

  /**
   * interest_groups: findFirstOrThrow
   */
  export type interest_groupsFindFirstOrThrowArgs = interest_groupsFindFirstArgsBase
      

  /**
   * interest_groups without action
   */
  export type interest_groupsArgs = {
    /**
     * Select specific fields to fetch from the interest_groups
     * 
    **/
    select?: interest_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: interest_groupsInclude | null
  }



  /**
   * Model organisms
   */


  export type AggregateOrganisms = {
    _count: OrganismsCountAggregateOutputType | null
    _avg: OrganismsAvgAggregateOutputType | null
    _sum: OrganismsSumAggregateOutputType | null
    _min: OrganismsMinAggregateOutputType | null
    _max: OrganismsMaxAggregateOutputType | null
  }

  export type OrganismsAvgAggregateOutputType = {
    id: number | null
    taxon_group_id: number | null
  }

  export type OrganismsSumAggregateOutputType = {
    id: number | null
    taxon_group_id: number | null
  }

  export type OrganismsMinAggregateOutputType = {
    id: number | null
    taxon_name: string | null
    latin_name: string | null
    taxon_group_id: number | null
    picture_url: string | null
    description: string | null
  }

  export type OrganismsMaxAggregateOutputType = {
    id: number | null
    taxon_name: string | null
    latin_name: string | null
    taxon_group_id: number | null
    picture_url: string | null
    description: string | null
  }

  export type OrganismsCountAggregateOutputType = {
    id: number
    taxon_name: number
    latin_name: number
    taxon_group_id: number
    picture_url: number
    description: number
    _all: number
  }


  export type OrganismsAvgAggregateInputType = {
    id?: true
    taxon_group_id?: true
  }

  export type OrganismsSumAggregateInputType = {
    id?: true
    taxon_group_id?: true
  }

  export type OrganismsMinAggregateInputType = {
    id?: true
    taxon_name?: true
    latin_name?: true
    taxon_group_id?: true
    picture_url?: true
    description?: true
  }

  export type OrganismsMaxAggregateInputType = {
    id?: true
    taxon_name?: true
    latin_name?: true
    taxon_group_id?: true
    picture_url?: true
    description?: true
  }

  export type OrganismsCountAggregateInputType = {
    id?: true
    taxon_name?: true
    latin_name?: true
    taxon_group_id?: true
    picture_url?: true
    description?: true
    _all?: true
  }

  export type OrganismsAggregateArgs = {
    /**
     * Filter which organisms to aggregate.
     * 
    **/
    where?: organismsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organisms to fetch.
     * 
    **/
    orderBy?: Enumerable<organismsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: organismsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organisms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organisms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned organisms
    **/
    _count?: true | OrganismsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrganismsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrganismsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrganismsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrganismsMaxAggregateInputType
  }

  export type GetOrganismsAggregateType<T extends OrganismsAggregateArgs> = {
        [P in keyof T & keyof AggregateOrganisms]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrganisms[P]>
      : GetScalarType<T[P], AggregateOrganisms[P]>
  }




  export type OrganismsGroupByArgs = {
    where?: organismsWhereInput
    orderBy?: Enumerable<organismsOrderByWithAggregationInput>
    by: Array<OrganismsScalarFieldEnum>
    having?: organismsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrganismsCountAggregateInputType | true
    _avg?: OrganismsAvgAggregateInputType
    _sum?: OrganismsSumAggregateInputType
    _min?: OrganismsMinAggregateInputType
    _max?: OrganismsMaxAggregateInputType
  }


  export type OrganismsGroupByOutputType = {
    id: number
    taxon_name: string
    latin_name: string
    taxon_group_id: number
    picture_url: string | null
    description: string | null
    _count: OrganismsCountAggregateOutputType | null
    _avg: OrganismsAvgAggregateOutputType | null
    _sum: OrganismsSumAggregateOutputType | null
    _min: OrganismsMinAggregateOutputType | null
    _max: OrganismsMaxAggregateOutputType | null
  }

  type GetOrganismsGroupByPayload<T extends OrganismsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<OrganismsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrganismsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrganismsGroupByOutputType[P]>
            : GetScalarType<T[P], OrganismsGroupByOutputType[P]>
        }
      >
    >


  export type organismsSelect = {
    id?: boolean
    taxon_name?: boolean
    latin_name?: boolean
    taxon_group_id?: boolean
    picture_url?: boolean
    description?: boolean
    taxon_groups?: boolean | taxon_groupsArgs
    confirmed_sightings?: boolean | confirmed_sightingsFindManyArgs
    unverified_sightings?: boolean | unverified_sightingsFindManyArgs
    _count?: boolean | OrganismsCountOutputTypeArgs
  }

  export type organismsInclude = {
    taxon_groups?: boolean | taxon_groupsArgs
    confirmed_sightings?: boolean | confirmed_sightingsFindManyArgs
    unverified_sightings?: boolean | unverified_sightingsFindManyArgs
    _count?: boolean | OrganismsCountOutputTypeArgs
  }

  export type organismsGetPayload<
    S extends boolean | null | undefined | organismsArgs,
    U = keyof S
      > = S extends true
        ? organisms
    : S extends undefined
    ? never
    : S extends organismsArgs | organismsFindManyArgs
    ?'include' extends U
    ? organisms  & {
    [P in TrueKeys<S['include']>]:
        P extends 'taxon_groups' ? taxon_groupsGetPayload<S['include'][P]> :
        P extends 'confirmed_sightings' ? Array < confirmed_sightingsGetPayload<S['include'][P]>>  :
        P extends 'unverified_sightings' ? Array < unverified_sightingsGetPayload<S['include'][P]>>  :
        P extends '_count' ? OrganismsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'taxon_groups' ? taxon_groupsGetPayload<S['select'][P]> :
        P extends 'confirmed_sightings' ? Array < confirmed_sightingsGetPayload<S['select'][P]>>  :
        P extends 'unverified_sightings' ? Array < unverified_sightingsGetPayload<S['select'][P]>>  :
        P extends '_count' ? OrganismsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof organisms ? organisms[P] : never
  } 
    : organisms
  : organisms


  type organismsCountArgs = Merge<
    Omit<organismsFindManyArgs, 'select' | 'include'> & {
      select?: OrganismsCountAggregateInputType | true
    }
  >

  export interface organismsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Organisms that matches the filter.
     * @param {organismsFindUniqueArgs} args - Arguments to find a Organisms
     * @example
     * // Get one Organisms
     * const organisms = await prisma.organisms.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends organismsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, organismsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'organisms'> extends True ? CheckSelect<T, Prisma__organismsClient<organisms>, Prisma__organismsClient<organismsGetPayload<T>>> : CheckSelect<T, Prisma__organismsClient<organisms | null >, Prisma__organismsClient<organismsGetPayload<T> | null >>

    /**
     * Find the first Organisms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organismsFindFirstArgs} args - Arguments to find a Organisms
     * @example
     * // Get one Organisms
     * const organisms = await prisma.organisms.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends organismsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, organismsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'organisms'> extends True ? CheckSelect<T, Prisma__organismsClient<organisms>, Prisma__organismsClient<organismsGetPayload<T>>> : CheckSelect<T, Prisma__organismsClient<organisms | null >, Prisma__organismsClient<organismsGetPayload<T> | null >>

    /**
     * Find zero or more Organisms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organismsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Organisms
     * const organisms = await prisma.organisms.findMany()
     * 
     * // Get first 10 Organisms
     * const organisms = await prisma.organisms.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const organismsWithIdOnly = await prisma.organisms.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends organismsFindManyArgs>(
      args?: SelectSubset<T, organismsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<organisms>>, PrismaPromise<Array<organismsGetPayload<T>>>>

    /**
     * Create a Organisms.
     * @param {organismsCreateArgs} args - Arguments to create a Organisms.
     * @example
     * // Create one Organisms
     * const Organisms = await prisma.organisms.create({
     *   data: {
     *     // ... data to create a Organisms
     *   }
     * })
     * 
    **/
    create<T extends organismsCreateArgs>(
      args: SelectSubset<T, organismsCreateArgs>
    ): CheckSelect<T, Prisma__organismsClient<organisms>, Prisma__organismsClient<organismsGetPayload<T>>>

    /**
     * Create many Organisms.
     *     @param {organismsCreateManyArgs} args - Arguments to create many Organisms.
     *     @example
     *     // Create many Organisms
     *     const organisms = await prisma.organisms.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends organismsCreateManyArgs>(
      args?: SelectSubset<T, organismsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Organisms.
     * @param {organismsDeleteArgs} args - Arguments to delete one Organisms.
     * @example
     * // Delete one Organisms
     * const Organisms = await prisma.organisms.delete({
     *   where: {
     *     // ... filter to delete one Organisms
     *   }
     * })
     * 
    **/
    delete<T extends organismsDeleteArgs>(
      args: SelectSubset<T, organismsDeleteArgs>
    ): CheckSelect<T, Prisma__organismsClient<organisms>, Prisma__organismsClient<organismsGetPayload<T>>>

    /**
     * Update one Organisms.
     * @param {organismsUpdateArgs} args - Arguments to update one Organisms.
     * @example
     * // Update one Organisms
     * const organisms = await prisma.organisms.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends organismsUpdateArgs>(
      args: SelectSubset<T, organismsUpdateArgs>
    ): CheckSelect<T, Prisma__organismsClient<organisms>, Prisma__organismsClient<organismsGetPayload<T>>>

    /**
     * Delete zero or more Organisms.
     * @param {organismsDeleteManyArgs} args - Arguments to filter Organisms to delete.
     * @example
     * // Delete a few Organisms
     * const { count } = await prisma.organisms.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends organismsDeleteManyArgs>(
      args?: SelectSubset<T, organismsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Organisms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organismsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Organisms
     * const organisms = await prisma.organisms.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends organismsUpdateManyArgs>(
      args: SelectSubset<T, organismsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Organisms.
     * @param {organismsUpsertArgs} args - Arguments to update or create a Organisms.
     * @example
     * // Update or create a Organisms
     * const organisms = await prisma.organisms.upsert({
     *   create: {
     *     // ... data to create a Organisms
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Organisms we want to update
     *   }
     * })
    **/
    upsert<T extends organismsUpsertArgs>(
      args: SelectSubset<T, organismsUpsertArgs>
    ): CheckSelect<T, Prisma__organismsClient<organisms>, Prisma__organismsClient<organismsGetPayload<T>>>

    /**
     * Find one Organisms that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {organismsFindUniqueOrThrowArgs} args - Arguments to find a Organisms
     * @example
     * // Get one Organisms
     * const organisms = await prisma.organisms.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends organismsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, organismsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__organismsClient<organisms>, Prisma__organismsClient<organismsGetPayload<T>>>

    /**
     * Find the first Organisms that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organismsFindFirstOrThrowArgs} args - Arguments to find a Organisms
     * @example
     * // Get one Organisms
     * const organisms = await prisma.organisms.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends organismsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, organismsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__organismsClient<organisms>, Prisma__organismsClient<organismsGetPayload<T>>>

    /**
     * Count the number of Organisms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {organismsCountArgs} args - Arguments to filter Organisms to count.
     * @example
     * // Count the number of Organisms
     * const count = await prisma.organisms.count({
     *   where: {
     *     // ... the filter for the Organisms we want to count
     *   }
     * })
    **/
    count<T extends organismsCountArgs>(
      args?: Subset<T, organismsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrganismsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Organisms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganismsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrganismsAggregateArgs>(args: Subset<T, OrganismsAggregateArgs>): PrismaPromise<GetOrganismsAggregateType<T>>

    /**
     * Group by Organisms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrganismsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrganismsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrganismsGroupByArgs['orderBy'] }
        : { orderBy?: OrganismsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrganismsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrganismsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for organisms.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__organismsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    taxon_groups<T extends taxon_groupsArgs = {}>(args?: Subset<T, taxon_groupsArgs>): CheckSelect<T, Prisma__taxon_groupsClient<taxon_groups | null >, Prisma__taxon_groupsClient<taxon_groupsGetPayload<T> | null >>;

    confirmed_sightings<T extends confirmed_sightingsFindManyArgs = {}>(args?: Subset<T, confirmed_sightingsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<confirmed_sightings>>, PrismaPromise<Array<confirmed_sightingsGetPayload<T>>>>;

    unverified_sightings<T extends unverified_sightingsFindManyArgs = {}>(args?: Subset<T, unverified_sightingsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<unverified_sightings>>, PrismaPromise<Array<unverified_sightingsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * organisms base type for findUnique actions
   */
  export type organismsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the organisms
     * 
    **/
    select?: organismsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organismsInclude | null
    /**
     * Filter, which organisms to fetch.
     * 
    **/
    where: organismsWhereUniqueInput
  }

  /**
   * organisms: findUnique
   */
  export interface organismsFindUniqueArgs extends organismsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organisms base type for findFirst actions
   */
  export type organismsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the organisms
     * 
    **/
    select?: organismsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organismsInclude | null
    /**
     * Filter, which organisms to fetch.
     * 
    **/
    where?: organismsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organisms to fetch.
     * 
    **/
    orderBy?: Enumerable<organismsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for organisms.
     * 
    **/
    cursor?: organismsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organisms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organisms.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of organisms.
     * 
    **/
    distinct?: Enumerable<OrganismsScalarFieldEnum>
  }

  /**
   * organisms: findFirst
   */
  export interface organismsFindFirstArgs extends organismsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * organisms findMany
   */
  export type organismsFindManyArgs = {
    /**
     * Select specific fields to fetch from the organisms
     * 
    **/
    select?: organismsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organismsInclude | null
    /**
     * Filter, which organisms to fetch.
     * 
    **/
    where?: organismsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of organisms to fetch.
     * 
    **/
    orderBy?: Enumerable<organismsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing organisms.
     * 
    **/
    cursor?: organismsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` organisms from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` organisms.
     * 
    **/
    skip?: number
    distinct?: Enumerable<OrganismsScalarFieldEnum>
  }


  /**
   * organisms create
   */
  export type organismsCreateArgs = {
    /**
     * Select specific fields to fetch from the organisms
     * 
    **/
    select?: organismsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organismsInclude | null
    /**
     * The data needed to create a organisms.
     * 
    **/
    data: XOR<organismsCreateInput, organismsUncheckedCreateInput>
  }


  /**
   * organisms createMany
   */
  export type organismsCreateManyArgs = {
    /**
     * The data used to create many organisms.
     * 
    **/
    data: Enumerable<organismsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * organisms update
   */
  export type organismsUpdateArgs = {
    /**
     * Select specific fields to fetch from the organisms
     * 
    **/
    select?: organismsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organismsInclude | null
    /**
     * The data needed to update a organisms.
     * 
    **/
    data: XOR<organismsUpdateInput, organismsUncheckedUpdateInput>
    /**
     * Choose, which organisms to update.
     * 
    **/
    where: organismsWhereUniqueInput
  }


  /**
   * organisms updateMany
   */
  export type organismsUpdateManyArgs = {
    /**
     * The data used to update organisms.
     * 
    **/
    data: XOR<organismsUpdateManyMutationInput, organismsUncheckedUpdateManyInput>
    /**
     * Filter which organisms to update
     * 
    **/
    where?: organismsWhereInput
  }


  /**
   * organisms upsert
   */
  export type organismsUpsertArgs = {
    /**
     * Select specific fields to fetch from the organisms
     * 
    **/
    select?: organismsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organismsInclude | null
    /**
     * The filter to search for the organisms to update in case it exists.
     * 
    **/
    where: organismsWhereUniqueInput
    /**
     * In case the organisms found by the `where` argument doesn't exist, create a new organisms with this data.
     * 
    **/
    create: XOR<organismsCreateInput, organismsUncheckedCreateInput>
    /**
     * In case the organisms was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<organismsUpdateInput, organismsUncheckedUpdateInput>
  }


  /**
   * organisms delete
   */
  export type organismsDeleteArgs = {
    /**
     * Select specific fields to fetch from the organisms
     * 
    **/
    select?: organismsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organismsInclude | null
    /**
     * Filter which organisms to delete.
     * 
    **/
    where: organismsWhereUniqueInput
  }


  /**
   * organisms deleteMany
   */
  export type organismsDeleteManyArgs = {
    /**
     * Filter which organisms to delete
     * 
    **/
    where?: organismsWhereInput
  }


  /**
   * organisms: findUniqueOrThrow
   */
  export type organismsFindUniqueOrThrowArgs = organismsFindUniqueArgsBase
      

  /**
   * organisms: findFirstOrThrow
   */
  export type organismsFindFirstOrThrowArgs = organismsFindFirstArgsBase
      

  /**
   * organisms without action
   */
  export type organismsArgs = {
    /**
     * Select specific fields to fetch from the organisms
     * 
    **/
    select?: organismsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: organismsInclude | null
  }



  /**
   * Model reactions
   */


  export type AggregateReactions = {
    _count: ReactionsCountAggregateOutputType | null
    _avg: ReactionsAvgAggregateOutputType | null
    _sum: ReactionsSumAggregateOutputType | null
    _min: ReactionsMinAggregateOutputType | null
    _max: ReactionsMaxAggregateOutputType | null
  }

  export type ReactionsAvgAggregateOutputType = {
    id: number | null
  }

  export type ReactionsSumAggregateOutputType = {
    id: number | null
  }

  export type ReactionsMinAggregateOutputType = {
    id: number | null
    reaction_name: string | null
  }

  export type ReactionsMaxAggregateOutputType = {
    id: number | null
    reaction_name: string | null
  }

  export type ReactionsCountAggregateOutputType = {
    id: number
    reaction_name: number
    _all: number
  }


  export type ReactionsAvgAggregateInputType = {
    id?: true
  }

  export type ReactionsSumAggregateInputType = {
    id?: true
  }

  export type ReactionsMinAggregateInputType = {
    id?: true
    reaction_name?: true
  }

  export type ReactionsMaxAggregateInputType = {
    id?: true
    reaction_name?: true
  }

  export type ReactionsCountAggregateInputType = {
    id?: true
    reaction_name?: true
    _all?: true
  }

  export type ReactionsAggregateArgs = {
    /**
     * Filter which reactions to aggregate.
     * 
    **/
    where?: reactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reactions to fetch.
     * 
    **/
    orderBy?: Enumerable<reactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: reactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reactions
    **/
    _count?: true | ReactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReactionsMaxAggregateInputType
  }

  export type GetReactionsAggregateType<T extends ReactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateReactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReactions[P]>
      : GetScalarType<T[P], AggregateReactions[P]>
  }




  export type ReactionsGroupByArgs = {
    where?: reactionsWhereInput
    orderBy?: Enumerable<reactionsOrderByWithAggregationInput>
    by: Array<ReactionsScalarFieldEnum>
    having?: reactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReactionsCountAggregateInputType | true
    _avg?: ReactionsAvgAggregateInputType
    _sum?: ReactionsSumAggregateInputType
    _min?: ReactionsMinAggregateInputType
    _max?: ReactionsMaxAggregateInputType
  }


  export type ReactionsGroupByOutputType = {
    id: number
    reaction_name: string
    _count: ReactionsCountAggregateOutputType | null
    _avg: ReactionsAvgAggregateOutputType | null
    _sum: ReactionsSumAggregateOutputType | null
    _min: ReactionsMinAggregateOutputType | null
    _max: ReactionsMaxAggregateOutputType | null
  }

  type GetReactionsGroupByPayload<T extends ReactionsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ReactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReactionsGroupByOutputType[P]>
            : GetScalarType<T[P], ReactionsGroupByOutputType[P]>
        }
      >
    >


  export type reactionsSelect = {
    id?: boolean
    reaction_name?: boolean
    unverified_sightings?: boolean | unverified_sightingsFindManyArgs
    user_to_reaction?: boolean | user_to_reactionFindManyArgs
    _count?: boolean | ReactionsCountOutputTypeArgs
  }

  export type reactionsInclude = {
    unverified_sightings?: boolean | unverified_sightingsFindManyArgs
    user_to_reaction?: boolean | user_to_reactionFindManyArgs
    _count?: boolean | ReactionsCountOutputTypeArgs
  }

  export type reactionsGetPayload<
    S extends boolean | null | undefined | reactionsArgs,
    U = keyof S
      > = S extends true
        ? reactions
    : S extends undefined
    ? never
    : S extends reactionsArgs | reactionsFindManyArgs
    ?'include' extends U
    ? reactions  & {
    [P in TrueKeys<S['include']>]:
        P extends 'unverified_sightings' ? Array < unverified_sightingsGetPayload<S['include'][P]>>  :
        P extends 'user_to_reaction' ? Array < user_to_reactionGetPayload<S['include'][P]>>  :
        P extends '_count' ? ReactionsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'unverified_sightings' ? Array < unverified_sightingsGetPayload<S['select'][P]>>  :
        P extends 'user_to_reaction' ? Array < user_to_reactionGetPayload<S['select'][P]>>  :
        P extends '_count' ? ReactionsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof reactions ? reactions[P] : never
  } 
    : reactions
  : reactions


  type reactionsCountArgs = Merge<
    Omit<reactionsFindManyArgs, 'select' | 'include'> & {
      select?: ReactionsCountAggregateInputType | true
    }
  >

  export interface reactionsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Reactions that matches the filter.
     * @param {reactionsFindUniqueArgs} args - Arguments to find a Reactions
     * @example
     * // Get one Reactions
     * const reactions = await prisma.reactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reactionsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reactionsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'reactions'> extends True ? CheckSelect<T, Prisma__reactionsClient<reactions>, Prisma__reactionsClient<reactionsGetPayload<T>>> : CheckSelect<T, Prisma__reactionsClient<reactions | null >, Prisma__reactionsClient<reactionsGetPayload<T> | null >>

    /**
     * Find the first Reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reactionsFindFirstArgs} args - Arguments to find a Reactions
     * @example
     * // Get one Reactions
     * const reactions = await prisma.reactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reactionsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reactionsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'reactions'> extends True ? CheckSelect<T, Prisma__reactionsClient<reactions>, Prisma__reactionsClient<reactionsGetPayload<T>>> : CheckSelect<T, Prisma__reactionsClient<reactions | null >, Prisma__reactionsClient<reactionsGetPayload<T> | null >>

    /**
     * Find zero or more Reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reactionsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reactions
     * const reactions = await prisma.reactions.findMany()
     * 
     * // Get first 10 Reactions
     * const reactions = await prisma.reactions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reactionsWithIdOnly = await prisma.reactions.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reactionsFindManyArgs>(
      args?: SelectSubset<T, reactionsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<reactions>>, PrismaPromise<Array<reactionsGetPayload<T>>>>

    /**
     * Create a Reactions.
     * @param {reactionsCreateArgs} args - Arguments to create a Reactions.
     * @example
     * // Create one Reactions
     * const Reactions = await prisma.reactions.create({
     *   data: {
     *     // ... data to create a Reactions
     *   }
     * })
     * 
    **/
    create<T extends reactionsCreateArgs>(
      args: SelectSubset<T, reactionsCreateArgs>
    ): CheckSelect<T, Prisma__reactionsClient<reactions>, Prisma__reactionsClient<reactionsGetPayload<T>>>

    /**
     * Create many Reactions.
     *     @param {reactionsCreateManyArgs} args - Arguments to create many Reactions.
     *     @example
     *     // Create many Reactions
     *     const reactions = await prisma.reactions.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends reactionsCreateManyArgs>(
      args?: SelectSubset<T, reactionsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Reactions.
     * @param {reactionsDeleteArgs} args - Arguments to delete one Reactions.
     * @example
     * // Delete one Reactions
     * const Reactions = await prisma.reactions.delete({
     *   where: {
     *     // ... filter to delete one Reactions
     *   }
     * })
     * 
    **/
    delete<T extends reactionsDeleteArgs>(
      args: SelectSubset<T, reactionsDeleteArgs>
    ): CheckSelect<T, Prisma__reactionsClient<reactions>, Prisma__reactionsClient<reactionsGetPayload<T>>>

    /**
     * Update one Reactions.
     * @param {reactionsUpdateArgs} args - Arguments to update one Reactions.
     * @example
     * // Update one Reactions
     * const reactions = await prisma.reactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reactionsUpdateArgs>(
      args: SelectSubset<T, reactionsUpdateArgs>
    ): CheckSelect<T, Prisma__reactionsClient<reactions>, Prisma__reactionsClient<reactionsGetPayload<T>>>

    /**
     * Delete zero or more Reactions.
     * @param {reactionsDeleteManyArgs} args - Arguments to filter Reactions to delete.
     * @example
     * // Delete a few Reactions
     * const { count } = await prisma.reactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reactionsDeleteManyArgs>(
      args?: SelectSubset<T, reactionsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reactions
     * const reactions = await prisma.reactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reactionsUpdateManyArgs>(
      args: SelectSubset<T, reactionsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Reactions.
     * @param {reactionsUpsertArgs} args - Arguments to update or create a Reactions.
     * @example
     * // Update or create a Reactions
     * const reactions = await prisma.reactions.upsert({
     *   create: {
     *     // ... data to create a Reactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reactions we want to update
     *   }
     * })
    **/
    upsert<T extends reactionsUpsertArgs>(
      args: SelectSubset<T, reactionsUpsertArgs>
    ): CheckSelect<T, Prisma__reactionsClient<reactions>, Prisma__reactionsClient<reactionsGetPayload<T>>>

    /**
     * Find one Reactions that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {reactionsFindUniqueOrThrowArgs} args - Arguments to find a Reactions
     * @example
     * // Get one Reactions
     * const reactions = await prisma.reactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reactionsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reactionsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__reactionsClient<reactions>, Prisma__reactionsClient<reactionsGetPayload<T>>>

    /**
     * Find the first Reactions that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reactionsFindFirstOrThrowArgs} args - Arguments to find a Reactions
     * @example
     * // Get one Reactions
     * const reactions = await prisma.reactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reactionsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reactionsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__reactionsClient<reactions>, Prisma__reactionsClient<reactionsGetPayload<T>>>

    /**
     * Count the number of Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reactionsCountArgs} args - Arguments to filter Reactions to count.
     * @example
     * // Count the number of Reactions
     * const count = await prisma.reactions.count({
     *   where: {
     *     // ... the filter for the Reactions we want to count
     *   }
     * })
    **/
    count<T extends reactionsCountArgs>(
      args?: Subset<T, reactionsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReactionsAggregateArgs>(args: Subset<T, ReactionsAggregateArgs>): PrismaPromise<GetReactionsAggregateType<T>>

    /**
     * Group by Reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReactionsGroupByArgs['orderBy'] }
        : { orderBy?: ReactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReactionsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for reactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reactionsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    unverified_sightings<T extends unverified_sightingsFindManyArgs = {}>(args?: Subset<T, unverified_sightingsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<unverified_sightings>>, PrismaPromise<Array<unverified_sightingsGetPayload<T>>>>;

    user_to_reaction<T extends user_to_reactionFindManyArgs = {}>(args?: Subset<T, user_to_reactionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<user_to_reaction>>, PrismaPromise<Array<user_to_reactionGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * reactions base type for findUnique actions
   */
  export type reactionsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the reactions
     * 
    **/
    select?: reactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reactionsInclude | null
    /**
     * Filter, which reactions to fetch.
     * 
    **/
    where: reactionsWhereUniqueInput
  }

  /**
   * reactions: findUnique
   */
  export interface reactionsFindUniqueArgs extends reactionsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reactions base type for findFirst actions
   */
  export type reactionsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the reactions
     * 
    **/
    select?: reactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reactionsInclude | null
    /**
     * Filter, which reactions to fetch.
     * 
    **/
    where?: reactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reactions to fetch.
     * 
    **/
    orderBy?: Enumerable<reactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reactions.
     * 
    **/
    cursor?: reactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reactions.
     * 
    **/
    distinct?: Enumerable<ReactionsScalarFieldEnum>
  }

  /**
   * reactions: findFirst
   */
  export interface reactionsFindFirstArgs extends reactionsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * reactions findMany
   */
  export type reactionsFindManyArgs = {
    /**
     * Select specific fields to fetch from the reactions
     * 
    **/
    select?: reactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reactionsInclude | null
    /**
     * Filter, which reactions to fetch.
     * 
    **/
    where?: reactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reactions to fetch.
     * 
    **/
    orderBy?: Enumerable<reactionsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reactions.
     * 
    **/
    cursor?: reactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ReactionsScalarFieldEnum>
  }


  /**
   * reactions create
   */
  export type reactionsCreateArgs = {
    /**
     * Select specific fields to fetch from the reactions
     * 
    **/
    select?: reactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reactionsInclude | null
    /**
     * The data needed to create a reactions.
     * 
    **/
    data: XOR<reactionsCreateInput, reactionsUncheckedCreateInput>
  }


  /**
   * reactions createMany
   */
  export type reactionsCreateManyArgs = {
    /**
     * The data used to create many reactions.
     * 
    **/
    data: Enumerable<reactionsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * reactions update
   */
  export type reactionsUpdateArgs = {
    /**
     * Select specific fields to fetch from the reactions
     * 
    **/
    select?: reactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reactionsInclude | null
    /**
     * The data needed to update a reactions.
     * 
    **/
    data: XOR<reactionsUpdateInput, reactionsUncheckedUpdateInput>
    /**
     * Choose, which reactions to update.
     * 
    **/
    where: reactionsWhereUniqueInput
  }


  /**
   * reactions updateMany
   */
  export type reactionsUpdateManyArgs = {
    /**
     * The data used to update reactions.
     * 
    **/
    data: XOR<reactionsUpdateManyMutationInput, reactionsUncheckedUpdateManyInput>
    /**
     * Filter which reactions to update
     * 
    **/
    where?: reactionsWhereInput
  }


  /**
   * reactions upsert
   */
  export type reactionsUpsertArgs = {
    /**
     * Select specific fields to fetch from the reactions
     * 
    **/
    select?: reactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reactionsInclude | null
    /**
     * The filter to search for the reactions to update in case it exists.
     * 
    **/
    where: reactionsWhereUniqueInput
    /**
     * In case the reactions found by the `where` argument doesn't exist, create a new reactions with this data.
     * 
    **/
    create: XOR<reactionsCreateInput, reactionsUncheckedCreateInput>
    /**
     * In case the reactions was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<reactionsUpdateInput, reactionsUncheckedUpdateInput>
  }


  /**
   * reactions delete
   */
  export type reactionsDeleteArgs = {
    /**
     * Select specific fields to fetch from the reactions
     * 
    **/
    select?: reactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reactionsInclude | null
    /**
     * Filter which reactions to delete.
     * 
    **/
    where: reactionsWhereUniqueInput
  }


  /**
   * reactions deleteMany
   */
  export type reactionsDeleteManyArgs = {
    /**
     * Filter which reactions to delete
     * 
    **/
    where?: reactionsWhereInput
  }


  /**
   * reactions: findUniqueOrThrow
   */
  export type reactionsFindUniqueOrThrowArgs = reactionsFindUniqueArgsBase
      

  /**
   * reactions: findFirstOrThrow
   */
  export type reactionsFindFirstOrThrowArgs = reactionsFindFirstArgsBase
      

  /**
   * reactions without action
   */
  export type reactionsArgs = {
    /**
     * Select specific fields to fetch from the reactions
     * 
    **/
    select?: reactionsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: reactionsInclude | null
  }



  /**
   * Model taxon_groups
   */


  export type AggregateTaxon_groups = {
    _count: Taxon_groupsCountAggregateOutputType | null
    _avg: Taxon_groupsAvgAggregateOutputType | null
    _sum: Taxon_groupsSumAggregateOutputType | null
    _min: Taxon_groupsMinAggregateOutputType | null
    _max: Taxon_groupsMaxAggregateOutputType | null
  }

  export type Taxon_groupsAvgAggregateOutputType = {
    id: number | null
  }

  export type Taxon_groupsSumAggregateOutputType = {
    id: number | null
  }

  export type Taxon_groupsMinAggregateOutputType = {
    id: number | null
    taxon_group_name: string | null
    description: string | null
  }

  export type Taxon_groupsMaxAggregateOutputType = {
    id: number | null
    taxon_group_name: string | null
    description: string | null
  }

  export type Taxon_groupsCountAggregateOutputType = {
    id: number
    taxon_group_name: number
    description: number
    _all: number
  }


  export type Taxon_groupsAvgAggregateInputType = {
    id?: true
  }

  export type Taxon_groupsSumAggregateInputType = {
    id?: true
  }

  export type Taxon_groupsMinAggregateInputType = {
    id?: true
    taxon_group_name?: true
    description?: true
  }

  export type Taxon_groupsMaxAggregateInputType = {
    id?: true
    taxon_group_name?: true
    description?: true
  }

  export type Taxon_groupsCountAggregateInputType = {
    id?: true
    taxon_group_name?: true
    description?: true
    _all?: true
  }

  export type Taxon_groupsAggregateArgs = {
    /**
     * Filter which taxon_groups to aggregate.
     * 
    **/
    where?: taxon_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxon_groups to fetch.
     * 
    **/
    orderBy?: Enumerable<taxon_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: taxon_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxon_groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxon_groups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned taxon_groups
    **/
    _count?: true | Taxon_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Taxon_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Taxon_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Taxon_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Taxon_groupsMaxAggregateInputType
  }

  export type GetTaxon_groupsAggregateType<T extends Taxon_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateTaxon_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTaxon_groups[P]>
      : GetScalarType<T[P], AggregateTaxon_groups[P]>
  }




  export type Taxon_groupsGroupByArgs = {
    where?: taxon_groupsWhereInput
    orderBy?: Enumerable<taxon_groupsOrderByWithAggregationInput>
    by: Array<Taxon_groupsScalarFieldEnum>
    having?: taxon_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Taxon_groupsCountAggregateInputType | true
    _avg?: Taxon_groupsAvgAggregateInputType
    _sum?: Taxon_groupsSumAggregateInputType
    _min?: Taxon_groupsMinAggregateInputType
    _max?: Taxon_groupsMaxAggregateInputType
  }


  export type Taxon_groupsGroupByOutputType = {
    id: number
    taxon_group_name: string
    description: string | null
    _count: Taxon_groupsCountAggregateOutputType | null
    _avg: Taxon_groupsAvgAggregateOutputType | null
    _sum: Taxon_groupsSumAggregateOutputType | null
    _min: Taxon_groupsMinAggregateOutputType | null
    _max: Taxon_groupsMaxAggregateOutputType | null
  }

  type GetTaxon_groupsGroupByPayload<T extends Taxon_groupsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Taxon_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Taxon_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Taxon_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Taxon_groupsGroupByOutputType[P]>
        }
      >
    >


  export type taxon_groupsSelect = {
    id?: boolean
    taxon_group_name?: boolean
    description?: boolean
    organisms?: boolean | organismsFindManyArgs
    _count?: boolean | Taxon_groupsCountOutputTypeArgs
  }

  export type taxon_groupsInclude = {
    organisms?: boolean | organismsFindManyArgs
    _count?: boolean | Taxon_groupsCountOutputTypeArgs
  }

  export type taxon_groupsGetPayload<
    S extends boolean | null | undefined | taxon_groupsArgs,
    U = keyof S
      > = S extends true
        ? taxon_groups
    : S extends undefined
    ? never
    : S extends taxon_groupsArgs | taxon_groupsFindManyArgs
    ?'include' extends U
    ? taxon_groups  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organisms' ? Array < organismsGetPayload<S['include'][P]>>  :
        P extends '_count' ? Taxon_groupsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organisms' ? Array < organismsGetPayload<S['select'][P]>>  :
        P extends '_count' ? Taxon_groupsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof taxon_groups ? taxon_groups[P] : never
  } 
    : taxon_groups
  : taxon_groups


  type taxon_groupsCountArgs = Merge<
    Omit<taxon_groupsFindManyArgs, 'select' | 'include'> & {
      select?: Taxon_groupsCountAggregateInputType | true
    }
  >

  export interface taxon_groupsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Taxon_groups that matches the filter.
     * @param {taxon_groupsFindUniqueArgs} args - Arguments to find a Taxon_groups
     * @example
     * // Get one Taxon_groups
     * const taxon_groups = await prisma.taxon_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends taxon_groupsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, taxon_groupsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'taxon_groups'> extends True ? CheckSelect<T, Prisma__taxon_groupsClient<taxon_groups>, Prisma__taxon_groupsClient<taxon_groupsGetPayload<T>>> : CheckSelect<T, Prisma__taxon_groupsClient<taxon_groups | null >, Prisma__taxon_groupsClient<taxon_groupsGetPayload<T> | null >>

    /**
     * Find the first Taxon_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxon_groupsFindFirstArgs} args - Arguments to find a Taxon_groups
     * @example
     * // Get one Taxon_groups
     * const taxon_groups = await prisma.taxon_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends taxon_groupsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, taxon_groupsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'taxon_groups'> extends True ? CheckSelect<T, Prisma__taxon_groupsClient<taxon_groups>, Prisma__taxon_groupsClient<taxon_groupsGetPayload<T>>> : CheckSelect<T, Prisma__taxon_groupsClient<taxon_groups | null >, Prisma__taxon_groupsClient<taxon_groupsGetPayload<T> | null >>

    /**
     * Find zero or more Taxon_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxon_groupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Taxon_groups
     * const taxon_groups = await prisma.taxon_groups.findMany()
     * 
     * // Get first 10 Taxon_groups
     * const taxon_groups = await prisma.taxon_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taxon_groupsWithIdOnly = await prisma.taxon_groups.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends taxon_groupsFindManyArgs>(
      args?: SelectSubset<T, taxon_groupsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<taxon_groups>>, PrismaPromise<Array<taxon_groupsGetPayload<T>>>>

    /**
     * Create a Taxon_groups.
     * @param {taxon_groupsCreateArgs} args - Arguments to create a Taxon_groups.
     * @example
     * // Create one Taxon_groups
     * const Taxon_groups = await prisma.taxon_groups.create({
     *   data: {
     *     // ... data to create a Taxon_groups
     *   }
     * })
     * 
    **/
    create<T extends taxon_groupsCreateArgs>(
      args: SelectSubset<T, taxon_groupsCreateArgs>
    ): CheckSelect<T, Prisma__taxon_groupsClient<taxon_groups>, Prisma__taxon_groupsClient<taxon_groupsGetPayload<T>>>

    /**
     * Create many Taxon_groups.
     *     @param {taxon_groupsCreateManyArgs} args - Arguments to create many Taxon_groups.
     *     @example
     *     // Create many Taxon_groups
     *     const taxon_groups = await prisma.taxon_groups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends taxon_groupsCreateManyArgs>(
      args?: SelectSubset<T, taxon_groupsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Taxon_groups.
     * @param {taxon_groupsDeleteArgs} args - Arguments to delete one Taxon_groups.
     * @example
     * // Delete one Taxon_groups
     * const Taxon_groups = await prisma.taxon_groups.delete({
     *   where: {
     *     // ... filter to delete one Taxon_groups
     *   }
     * })
     * 
    **/
    delete<T extends taxon_groupsDeleteArgs>(
      args: SelectSubset<T, taxon_groupsDeleteArgs>
    ): CheckSelect<T, Prisma__taxon_groupsClient<taxon_groups>, Prisma__taxon_groupsClient<taxon_groupsGetPayload<T>>>

    /**
     * Update one Taxon_groups.
     * @param {taxon_groupsUpdateArgs} args - Arguments to update one Taxon_groups.
     * @example
     * // Update one Taxon_groups
     * const taxon_groups = await prisma.taxon_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends taxon_groupsUpdateArgs>(
      args: SelectSubset<T, taxon_groupsUpdateArgs>
    ): CheckSelect<T, Prisma__taxon_groupsClient<taxon_groups>, Prisma__taxon_groupsClient<taxon_groupsGetPayload<T>>>

    /**
     * Delete zero or more Taxon_groups.
     * @param {taxon_groupsDeleteManyArgs} args - Arguments to filter Taxon_groups to delete.
     * @example
     * // Delete a few Taxon_groups
     * const { count } = await prisma.taxon_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends taxon_groupsDeleteManyArgs>(
      args?: SelectSubset<T, taxon_groupsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Taxon_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxon_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Taxon_groups
     * const taxon_groups = await prisma.taxon_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends taxon_groupsUpdateManyArgs>(
      args: SelectSubset<T, taxon_groupsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Taxon_groups.
     * @param {taxon_groupsUpsertArgs} args - Arguments to update or create a Taxon_groups.
     * @example
     * // Update or create a Taxon_groups
     * const taxon_groups = await prisma.taxon_groups.upsert({
     *   create: {
     *     // ... data to create a Taxon_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Taxon_groups we want to update
     *   }
     * })
    **/
    upsert<T extends taxon_groupsUpsertArgs>(
      args: SelectSubset<T, taxon_groupsUpsertArgs>
    ): CheckSelect<T, Prisma__taxon_groupsClient<taxon_groups>, Prisma__taxon_groupsClient<taxon_groupsGetPayload<T>>>

    /**
     * Find one Taxon_groups that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {taxon_groupsFindUniqueOrThrowArgs} args - Arguments to find a Taxon_groups
     * @example
     * // Get one Taxon_groups
     * const taxon_groups = await prisma.taxon_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends taxon_groupsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, taxon_groupsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__taxon_groupsClient<taxon_groups>, Prisma__taxon_groupsClient<taxon_groupsGetPayload<T>>>

    /**
     * Find the first Taxon_groups that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxon_groupsFindFirstOrThrowArgs} args - Arguments to find a Taxon_groups
     * @example
     * // Get one Taxon_groups
     * const taxon_groups = await prisma.taxon_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends taxon_groupsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, taxon_groupsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__taxon_groupsClient<taxon_groups>, Prisma__taxon_groupsClient<taxon_groupsGetPayload<T>>>

    /**
     * Count the number of Taxon_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {taxon_groupsCountArgs} args - Arguments to filter Taxon_groups to count.
     * @example
     * // Count the number of Taxon_groups
     * const count = await prisma.taxon_groups.count({
     *   where: {
     *     // ... the filter for the Taxon_groups we want to count
     *   }
     * })
    **/
    count<T extends taxon_groupsCountArgs>(
      args?: Subset<T, taxon_groupsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Taxon_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Taxon_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Taxon_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Taxon_groupsAggregateArgs>(args: Subset<T, Taxon_groupsAggregateArgs>): PrismaPromise<GetTaxon_groupsAggregateType<T>>

    /**
     * Group by Taxon_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Taxon_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Taxon_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Taxon_groupsGroupByArgs['orderBy'] }
        : { orderBy?: Taxon_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Taxon_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaxon_groupsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for taxon_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__taxon_groupsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organisms<T extends organismsFindManyArgs = {}>(args?: Subset<T, organismsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<organisms>>, PrismaPromise<Array<organismsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * taxon_groups base type for findUnique actions
   */
  export type taxon_groupsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the taxon_groups
     * 
    **/
    select?: taxon_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: taxon_groupsInclude | null
    /**
     * Filter, which taxon_groups to fetch.
     * 
    **/
    where: taxon_groupsWhereUniqueInput
  }

  /**
   * taxon_groups: findUnique
   */
  export interface taxon_groupsFindUniqueArgs extends taxon_groupsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * taxon_groups base type for findFirst actions
   */
  export type taxon_groupsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the taxon_groups
     * 
    **/
    select?: taxon_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: taxon_groupsInclude | null
    /**
     * Filter, which taxon_groups to fetch.
     * 
    **/
    where?: taxon_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxon_groups to fetch.
     * 
    **/
    orderBy?: Enumerable<taxon_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for taxon_groups.
     * 
    **/
    cursor?: taxon_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxon_groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxon_groups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of taxon_groups.
     * 
    **/
    distinct?: Enumerable<Taxon_groupsScalarFieldEnum>
  }

  /**
   * taxon_groups: findFirst
   */
  export interface taxon_groupsFindFirstArgs extends taxon_groupsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * taxon_groups findMany
   */
  export type taxon_groupsFindManyArgs = {
    /**
     * Select specific fields to fetch from the taxon_groups
     * 
    **/
    select?: taxon_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: taxon_groupsInclude | null
    /**
     * Filter, which taxon_groups to fetch.
     * 
    **/
    where?: taxon_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of taxon_groups to fetch.
     * 
    **/
    orderBy?: Enumerable<taxon_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing taxon_groups.
     * 
    **/
    cursor?: taxon_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` taxon_groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` taxon_groups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Taxon_groupsScalarFieldEnum>
  }


  /**
   * taxon_groups create
   */
  export type taxon_groupsCreateArgs = {
    /**
     * Select specific fields to fetch from the taxon_groups
     * 
    **/
    select?: taxon_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: taxon_groupsInclude | null
    /**
     * The data needed to create a taxon_groups.
     * 
    **/
    data: XOR<taxon_groupsCreateInput, taxon_groupsUncheckedCreateInput>
  }


  /**
   * taxon_groups createMany
   */
  export type taxon_groupsCreateManyArgs = {
    /**
     * The data used to create many taxon_groups.
     * 
    **/
    data: Enumerable<taxon_groupsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * taxon_groups update
   */
  export type taxon_groupsUpdateArgs = {
    /**
     * Select specific fields to fetch from the taxon_groups
     * 
    **/
    select?: taxon_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: taxon_groupsInclude | null
    /**
     * The data needed to update a taxon_groups.
     * 
    **/
    data: XOR<taxon_groupsUpdateInput, taxon_groupsUncheckedUpdateInput>
    /**
     * Choose, which taxon_groups to update.
     * 
    **/
    where: taxon_groupsWhereUniqueInput
  }


  /**
   * taxon_groups updateMany
   */
  export type taxon_groupsUpdateManyArgs = {
    /**
     * The data used to update taxon_groups.
     * 
    **/
    data: XOR<taxon_groupsUpdateManyMutationInput, taxon_groupsUncheckedUpdateManyInput>
    /**
     * Filter which taxon_groups to update
     * 
    **/
    where?: taxon_groupsWhereInput
  }


  /**
   * taxon_groups upsert
   */
  export type taxon_groupsUpsertArgs = {
    /**
     * Select specific fields to fetch from the taxon_groups
     * 
    **/
    select?: taxon_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: taxon_groupsInclude | null
    /**
     * The filter to search for the taxon_groups to update in case it exists.
     * 
    **/
    where: taxon_groupsWhereUniqueInput
    /**
     * In case the taxon_groups found by the `where` argument doesn't exist, create a new taxon_groups with this data.
     * 
    **/
    create: XOR<taxon_groupsCreateInput, taxon_groupsUncheckedCreateInput>
    /**
     * In case the taxon_groups was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<taxon_groupsUpdateInput, taxon_groupsUncheckedUpdateInput>
  }


  /**
   * taxon_groups delete
   */
  export type taxon_groupsDeleteArgs = {
    /**
     * Select specific fields to fetch from the taxon_groups
     * 
    **/
    select?: taxon_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: taxon_groupsInclude | null
    /**
     * Filter which taxon_groups to delete.
     * 
    **/
    where: taxon_groupsWhereUniqueInput
  }


  /**
   * taxon_groups deleteMany
   */
  export type taxon_groupsDeleteManyArgs = {
    /**
     * Filter which taxon_groups to delete
     * 
    **/
    where?: taxon_groupsWhereInput
  }


  /**
   * taxon_groups: findUniqueOrThrow
   */
  export type taxon_groupsFindUniqueOrThrowArgs = taxon_groupsFindUniqueArgsBase
      

  /**
   * taxon_groups: findFirstOrThrow
   */
  export type taxon_groupsFindFirstOrThrowArgs = taxon_groupsFindFirstArgsBase
      

  /**
   * taxon_groups without action
   */
  export type taxon_groupsArgs = {
    /**
     * Select specific fields to fetch from the taxon_groups
     * 
    **/
    select?: taxon_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: taxon_groupsInclude | null
  }



  /**
   * Model unverified_sightings
   */


  export type AggregateUnverified_sightings = {
    _count: Unverified_sightingsCountAggregateOutputType | null
    _avg: Unverified_sightingsAvgAggregateOutputType | null
    _sum: Unverified_sightingsSumAggregateOutputType | null
    _min: Unverified_sightingsMinAggregateOutputType | null
    _max: Unverified_sightingsMaxAggregateOutputType | null
  }

  export type Unverified_sightingsAvgAggregateOutputType = {
    id: number | null
    organism_id: number | null
    user_id: number | null
    lat: Decimal | null
    long: Decimal | null
    user_vote_id: number | null
    reaction_id: number | null
  }

  export type Unverified_sightingsSumAggregateOutputType = {
    id: number | null
    organism_id: number | null
    user_id: number | null
    lat: Decimal | null
    long: Decimal | null
    user_vote_id: number | null
    reaction_id: number | null
  }

  export type Unverified_sightingsMinAggregateOutputType = {
    id: number | null
    organism_id: number | null
    user_id: number | null
    picture_url: string | null
    date: Date | null
    lat: Decimal | null
    long: Decimal | null
    user_vote_id: number | null
    reaction_id: number | null
  }

  export type Unverified_sightingsMaxAggregateOutputType = {
    id: number | null
    organism_id: number | null
    user_id: number | null
    picture_url: string | null
    date: Date | null
    lat: Decimal | null
    long: Decimal | null
    user_vote_id: number | null
    reaction_id: number | null
  }

  export type Unverified_sightingsCountAggregateOutputType = {
    id: number
    organism_id: number
    user_id: number
    picture_url: number
    date: number
    lat: number
    long: number
    user_vote_id: number
    reaction_id: number
    _all: number
  }


  export type Unverified_sightingsAvgAggregateInputType = {
    id?: true
    organism_id?: true
    user_id?: true
    lat?: true
    long?: true
    user_vote_id?: true
    reaction_id?: true
  }

  export type Unverified_sightingsSumAggregateInputType = {
    id?: true
    organism_id?: true
    user_id?: true
    lat?: true
    long?: true
    user_vote_id?: true
    reaction_id?: true
  }

  export type Unverified_sightingsMinAggregateInputType = {
    id?: true
    organism_id?: true
    user_id?: true
    picture_url?: true
    date?: true
    lat?: true
    long?: true
    user_vote_id?: true
    reaction_id?: true
  }

  export type Unverified_sightingsMaxAggregateInputType = {
    id?: true
    organism_id?: true
    user_id?: true
    picture_url?: true
    date?: true
    lat?: true
    long?: true
    user_vote_id?: true
    reaction_id?: true
  }

  export type Unverified_sightingsCountAggregateInputType = {
    id?: true
    organism_id?: true
    user_id?: true
    picture_url?: true
    date?: true
    lat?: true
    long?: true
    user_vote_id?: true
    reaction_id?: true
    _all?: true
  }

  export type Unverified_sightingsAggregateArgs = {
    /**
     * Filter which unverified_sightings to aggregate.
     * 
    **/
    where?: unverified_sightingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unverified_sightings to fetch.
     * 
    **/
    orderBy?: Enumerable<unverified_sightingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: unverified_sightingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unverified_sightings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unverified_sightings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned unverified_sightings
    **/
    _count?: true | Unverified_sightingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Unverified_sightingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Unverified_sightingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Unverified_sightingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Unverified_sightingsMaxAggregateInputType
  }

  export type GetUnverified_sightingsAggregateType<T extends Unverified_sightingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUnverified_sightings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnverified_sightings[P]>
      : GetScalarType<T[P], AggregateUnverified_sightings[P]>
  }




  export type Unverified_sightingsGroupByArgs = {
    where?: unverified_sightingsWhereInput
    orderBy?: Enumerable<unverified_sightingsOrderByWithAggregationInput>
    by: Array<Unverified_sightingsScalarFieldEnum>
    having?: unverified_sightingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Unverified_sightingsCountAggregateInputType | true
    _avg?: Unverified_sightingsAvgAggregateInputType
    _sum?: Unverified_sightingsSumAggregateInputType
    _min?: Unverified_sightingsMinAggregateInputType
    _max?: Unverified_sightingsMaxAggregateInputType
  }


  export type Unverified_sightingsGroupByOutputType = {
    id: number
    organism_id: number
    user_id: number
    picture_url: string
    date: Date
    lat: Decimal
    long: Decimal
    user_vote_id: number | null
    reaction_id: number | null
    _count: Unverified_sightingsCountAggregateOutputType | null
    _avg: Unverified_sightingsAvgAggregateOutputType | null
    _sum: Unverified_sightingsSumAggregateOutputType | null
    _min: Unverified_sightingsMinAggregateOutputType | null
    _max: Unverified_sightingsMaxAggregateOutputType | null
  }

  type GetUnverified_sightingsGroupByPayload<T extends Unverified_sightingsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Unverified_sightingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Unverified_sightingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Unverified_sightingsGroupByOutputType[P]>
            : GetScalarType<T[P], Unverified_sightingsGroupByOutputType[P]>
        }
      >
    >


  export type unverified_sightingsSelect = {
    id?: boolean
    organism_id?: boolean
    user_id?: boolean
    picture_url?: boolean
    date?: boolean
    lat?: boolean
    long?: boolean
    user_vote_id?: boolean
    reaction_id?: boolean
    organisms?: boolean | organismsArgs
    reactions?: boolean | reactionsArgs
    users?: boolean | usersArgs
    user_votes?: boolean | user_votesArgs
  }

  export type unverified_sightingsInclude = {
    organisms?: boolean | organismsArgs
    reactions?: boolean | reactionsArgs
    users?: boolean | usersArgs
    user_votes?: boolean | user_votesArgs
  }

  export type unverified_sightingsGetPayload<
    S extends boolean | null | undefined | unverified_sightingsArgs,
    U = keyof S
      > = S extends true
        ? unverified_sightings
    : S extends undefined
    ? never
    : S extends unverified_sightingsArgs | unverified_sightingsFindManyArgs
    ?'include' extends U
    ? unverified_sightings  & {
    [P in TrueKeys<S['include']>]:
        P extends 'organisms' ? organismsGetPayload<S['include'][P]> :
        P extends 'reactions' ? reactionsGetPayload<S['include'][P]> | null :
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'user_votes' ? user_votesGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'organisms' ? organismsGetPayload<S['select'][P]> :
        P extends 'reactions' ? reactionsGetPayload<S['select'][P]> | null :
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'user_votes' ? user_votesGetPayload<S['select'][P]> | null :  P extends keyof unverified_sightings ? unverified_sightings[P] : never
  } 
    : unverified_sightings
  : unverified_sightings


  type unverified_sightingsCountArgs = Merge<
    Omit<unverified_sightingsFindManyArgs, 'select' | 'include'> & {
      select?: Unverified_sightingsCountAggregateInputType | true
    }
  >

  export interface unverified_sightingsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Unverified_sightings that matches the filter.
     * @param {unverified_sightingsFindUniqueArgs} args - Arguments to find a Unverified_sightings
     * @example
     * // Get one Unverified_sightings
     * const unverified_sightings = await prisma.unverified_sightings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends unverified_sightingsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, unverified_sightingsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'unverified_sightings'> extends True ? CheckSelect<T, Prisma__unverified_sightingsClient<unverified_sightings>, Prisma__unverified_sightingsClient<unverified_sightingsGetPayload<T>>> : CheckSelect<T, Prisma__unverified_sightingsClient<unverified_sightings | null >, Prisma__unverified_sightingsClient<unverified_sightingsGetPayload<T> | null >>

    /**
     * Find the first Unverified_sightings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unverified_sightingsFindFirstArgs} args - Arguments to find a Unverified_sightings
     * @example
     * // Get one Unverified_sightings
     * const unverified_sightings = await prisma.unverified_sightings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends unverified_sightingsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, unverified_sightingsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'unverified_sightings'> extends True ? CheckSelect<T, Prisma__unverified_sightingsClient<unverified_sightings>, Prisma__unverified_sightingsClient<unverified_sightingsGetPayload<T>>> : CheckSelect<T, Prisma__unverified_sightingsClient<unverified_sightings | null >, Prisma__unverified_sightingsClient<unverified_sightingsGetPayload<T> | null >>

    /**
     * Find zero or more Unverified_sightings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unverified_sightingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Unverified_sightings
     * const unverified_sightings = await prisma.unverified_sightings.findMany()
     * 
     * // Get first 10 Unverified_sightings
     * const unverified_sightings = await prisma.unverified_sightings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unverified_sightingsWithIdOnly = await prisma.unverified_sightings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends unverified_sightingsFindManyArgs>(
      args?: SelectSubset<T, unverified_sightingsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<unverified_sightings>>, PrismaPromise<Array<unverified_sightingsGetPayload<T>>>>

    /**
     * Create a Unverified_sightings.
     * @param {unverified_sightingsCreateArgs} args - Arguments to create a Unverified_sightings.
     * @example
     * // Create one Unverified_sightings
     * const Unverified_sightings = await prisma.unverified_sightings.create({
     *   data: {
     *     // ... data to create a Unverified_sightings
     *   }
     * })
     * 
    **/
    create<T extends unverified_sightingsCreateArgs>(
      args: SelectSubset<T, unverified_sightingsCreateArgs>
    ): CheckSelect<T, Prisma__unverified_sightingsClient<unverified_sightings>, Prisma__unverified_sightingsClient<unverified_sightingsGetPayload<T>>>

    /**
     * Create many Unverified_sightings.
     *     @param {unverified_sightingsCreateManyArgs} args - Arguments to create many Unverified_sightings.
     *     @example
     *     // Create many Unverified_sightings
     *     const unverified_sightings = await prisma.unverified_sightings.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends unverified_sightingsCreateManyArgs>(
      args?: SelectSubset<T, unverified_sightingsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Unverified_sightings.
     * @param {unverified_sightingsDeleteArgs} args - Arguments to delete one Unverified_sightings.
     * @example
     * // Delete one Unverified_sightings
     * const Unverified_sightings = await prisma.unverified_sightings.delete({
     *   where: {
     *     // ... filter to delete one Unverified_sightings
     *   }
     * })
     * 
    **/
    delete<T extends unverified_sightingsDeleteArgs>(
      args: SelectSubset<T, unverified_sightingsDeleteArgs>
    ): CheckSelect<T, Prisma__unverified_sightingsClient<unverified_sightings>, Prisma__unverified_sightingsClient<unverified_sightingsGetPayload<T>>>

    /**
     * Update one Unverified_sightings.
     * @param {unverified_sightingsUpdateArgs} args - Arguments to update one Unverified_sightings.
     * @example
     * // Update one Unverified_sightings
     * const unverified_sightings = await prisma.unverified_sightings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends unverified_sightingsUpdateArgs>(
      args: SelectSubset<T, unverified_sightingsUpdateArgs>
    ): CheckSelect<T, Prisma__unverified_sightingsClient<unverified_sightings>, Prisma__unverified_sightingsClient<unverified_sightingsGetPayload<T>>>

    /**
     * Delete zero or more Unverified_sightings.
     * @param {unverified_sightingsDeleteManyArgs} args - Arguments to filter Unverified_sightings to delete.
     * @example
     * // Delete a few Unverified_sightings
     * const { count } = await prisma.unverified_sightings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends unverified_sightingsDeleteManyArgs>(
      args?: SelectSubset<T, unverified_sightingsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Unverified_sightings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unverified_sightingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Unverified_sightings
     * const unverified_sightings = await prisma.unverified_sightings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends unverified_sightingsUpdateManyArgs>(
      args: SelectSubset<T, unverified_sightingsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Unverified_sightings.
     * @param {unverified_sightingsUpsertArgs} args - Arguments to update or create a Unverified_sightings.
     * @example
     * // Update or create a Unverified_sightings
     * const unverified_sightings = await prisma.unverified_sightings.upsert({
     *   create: {
     *     // ... data to create a Unverified_sightings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unverified_sightings we want to update
     *   }
     * })
    **/
    upsert<T extends unverified_sightingsUpsertArgs>(
      args: SelectSubset<T, unverified_sightingsUpsertArgs>
    ): CheckSelect<T, Prisma__unverified_sightingsClient<unverified_sightings>, Prisma__unverified_sightingsClient<unverified_sightingsGetPayload<T>>>

    /**
     * Find one Unverified_sightings that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {unverified_sightingsFindUniqueOrThrowArgs} args - Arguments to find a Unverified_sightings
     * @example
     * // Get one Unverified_sightings
     * const unverified_sightings = await prisma.unverified_sightings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends unverified_sightingsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, unverified_sightingsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__unverified_sightingsClient<unverified_sightings>, Prisma__unverified_sightingsClient<unverified_sightingsGetPayload<T>>>

    /**
     * Find the first Unverified_sightings that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unverified_sightingsFindFirstOrThrowArgs} args - Arguments to find a Unverified_sightings
     * @example
     * // Get one Unverified_sightings
     * const unverified_sightings = await prisma.unverified_sightings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends unverified_sightingsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, unverified_sightingsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__unverified_sightingsClient<unverified_sightings>, Prisma__unverified_sightingsClient<unverified_sightingsGetPayload<T>>>

    /**
     * Count the number of Unverified_sightings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {unverified_sightingsCountArgs} args - Arguments to filter Unverified_sightings to count.
     * @example
     * // Count the number of Unverified_sightings
     * const count = await prisma.unverified_sightings.count({
     *   where: {
     *     // ... the filter for the Unverified_sightings we want to count
     *   }
     * })
    **/
    count<T extends unverified_sightingsCountArgs>(
      args?: Subset<T, unverified_sightingsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Unverified_sightingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unverified_sightings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unverified_sightingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Unverified_sightingsAggregateArgs>(args: Subset<T, Unverified_sightingsAggregateArgs>): PrismaPromise<GetUnverified_sightingsAggregateType<T>>

    /**
     * Group by Unverified_sightings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Unverified_sightingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Unverified_sightingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Unverified_sightingsGroupByArgs['orderBy'] }
        : { orderBy?: Unverified_sightingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Unverified_sightingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnverified_sightingsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for unverified_sightings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__unverified_sightingsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    organisms<T extends organismsArgs = {}>(args?: Subset<T, organismsArgs>): CheckSelect<T, Prisma__organismsClient<organisms | null >, Prisma__organismsClient<organismsGetPayload<T> | null >>;

    reactions<T extends reactionsArgs = {}>(args?: Subset<T, reactionsArgs>): CheckSelect<T, Prisma__reactionsClient<reactions | null >, Prisma__reactionsClient<reactionsGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    user_votes<T extends user_votesArgs = {}>(args?: Subset<T, user_votesArgs>): CheckSelect<T, Prisma__user_votesClient<user_votes | null >, Prisma__user_votesClient<user_votesGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * unverified_sightings base type for findUnique actions
   */
  export type unverified_sightingsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the unverified_sightings
     * 
    **/
    select?: unverified_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: unverified_sightingsInclude | null
    /**
     * Filter, which unverified_sightings to fetch.
     * 
    **/
    where: unverified_sightingsWhereUniqueInput
  }

  /**
   * unverified_sightings: findUnique
   */
  export interface unverified_sightingsFindUniqueArgs extends unverified_sightingsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * unverified_sightings base type for findFirst actions
   */
  export type unverified_sightingsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the unverified_sightings
     * 
    **/
    select?: unverified_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: unverified_sightingsInclude | null
    /**
     * Filter, which unverified_sightings to fetch.
     * 
    **/
    where?: unverified_sightingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unverified_sightings to fetch.
     * 
    **/
    orderBy?: Enumerable<unverified_sightingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for unverified_sightings.
     * 
    **/
    cursor?: unverified_sightingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unverified_sightings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unverified_sightings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of unverified_sightings.
     * 
    **/
    distinct?: Enumerable<Unverified_sightingsScalarFieldEnum>
  }

  /**
   * unverified_sightings: findFirst
   */
  export interface unverified_sightingsFindFirstArgs extends unverified_sightingsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * unverified_sightings findMany
   */
  export type unverified_sightingsFindManyArgs = {
    /**
     * Select specific fields to fetch from the unverified_sightings
     * 
    **/
    select?: unverified_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: unverified_sightingsInclude | null
    /**
     * Filter, which unverified_sightings to fetch.
     * 
    **/
    where?: unverified_sightingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of unverified_sightings to fetch.
     * 
    **/
    orderBy?: Enumerable<unverified_sightingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing unverified_sightings.
     * 
    **/
    cursor?: unverified_sightingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` unverified_sightings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` unverified_sightings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Unverified_sightingsScalarFieldEnum>
  }


  /**
   * unverified_sightings create
   */
  export type unverified_sightingsCreateArgs = {
    /**
     * Select specific fields to fetch from the unverified_sightings
     * 
    **/
    select?: unverified_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: unverified_sightingsInclude | null
    /**
     * The data needed to create a unverified_sightings.
     * 
    **/
    data: XOR<unverified_sightingsCreateInput, unverified_sightingsUncheckedCreateInput>
  }


  /**
   * unverified_sightings createMany
   */
  export type unverified_sightingsCreateManyArgs = {
    /**
     * The data used to create many unverified_sightings.
     * 
    **/
    data: Enumerable<unverified_sightingsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * unverified_sightings update
   */
  export type unverified_sightingsUpdateArgs = {
    /**
     * Select specific fields to fetch from the unverified_sightings
     * 
    **/
    select?: unverified_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: unverified_sightingsInclude | null
    /**
     * The data needed to update a unverified_sightings.
     * 
    **/
    data: XOR<unverified_sightingsUpdateInput, unverified_sightingsUncheckedUpdateInput>
    /**
     * Choose, which unverified_sightings to update.
     * 
    **/
    where: unverified_sightingsWhereUniqueInput
  }


  /**
   * unverified_sightings updateMany
   */
  export type unverified_sightingsUpdateManyArgs = {
    /**
     * The data used to update unverified_sightings.
     * 
    **/
    data: XOR<unverified_sightingsUpdateManyMutationInput, unverified_sightingsUncheckedUpdateManyInput>
    /**
     * Filter which unverified_sightings to update
     * 
    **/
    where?: unverified_sightingsWhereInput
  }


  /**
   * unverified_sightings upsert
   */
  export type unverified_sightingsUpsertArgs = {
    /**
     * Select specific fields to fetch from the unverified_sightings
     * 
    **/
    select?: unverified_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: unverified_sightingsInclude | null
    /**
     * The filter to search for the unverified_sightings to update in case it exists.
     * 
    **/
    where: unverified_sightingsWhereUniqueInput
    /**
     * In case the unverified_sightings found by the `where` argument doesn't exist, create a new unverified_sightings with this data.
     * 
    **/
    create: XOR<unverified_sightingsCreateInput, unverified_sightingsUncheckedCreateInput>
    /**
     * In case the unverified_sightings was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<unverified_sightingsUpdateInput, unverified_sightingsUncheckedUpdateInput>
  }


  /**
   * unverified_sightings delete
   */
  export type unverified_sightingsDeleteArgs = {
    /**
     * Select specific fields to fetch from the unverified_sightings
     * 
    **/
    select?: unverified_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: unverified_sightingsInclude | null
    /**
     * Filter which unverified_sightings to delete.
     * 
    **/
    where: unverified_sightingsWhereUniqueInput
  }


  /**
   * unverified_sightings deleteMany
   */
  export type unverified_sightingsDeleteManyArgs = {
    /**
     * Filter which unverified_sightings to delete
     * 
    **/
    where?: unverified_sightingsWhereInput
  }


  /**
   * unverified_sightings: findUniqueOrThrow
   */
  export type unverified_sightingsFindUniqueOrThrowArgs = unverified_sightingsFindUniqueArgsBase
      

  /**
   * unverified_sightings: findFirstOrThrow
   */
  export type unverified_sightingsFindFirstOrThrowArgs = unverified_sightingsFindFirstArgsBase
      

  /**
   * unverified_sightings without action
   */
  export type unverified_sightingsArgs = {
    /**
     * Select specific fields to fetch from the unverified_sightings
     * 
    **/
    select?: unverified_sightingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: unverified_sightingsInclude | null
  }



  /**
   * Model user_levels
   */


  export type AggregateUser_levels = {
    _count: User_levelsCountAggregateOutputType | null
    _avg: User_levelsAvgAggregateOutputType | null
    _sum: User_levelsSumAggregateOutputType | null
    _min: User_levelsMinAggregateOutputType | null
    _max: User_levelsMaxAggregateOutputType | null
  }

  export type User_levelsAvgAggregateOutputType = {
    id: number | null
  }

  export type User_levelsSumAggregateOutputType = {
    id: number | null
  }

  export type User_levelsMinAggregateOutputType = {
    id: number | null
    description: string | null
  }

  export type User_levelsMaxAggregateOutputType = {
    id: number | null
    description: string | null
  }

  export type User_levelsCountAggregateOutputType = {
    id: number
    description: number
    _all: number
  }


  export type User_levelsAvgAggregateInputType = {
    id?: true
  }

  export type User_levelsSumAggregateInputType = {
    id?: true
  }

  export type User_levelsMinAggregateInputType = {
    id?: true
    description?: true
  }

  export type User_levelsMaxAggregateInputType = {
    id?: true
    description?: true
  }

  export type User_levelsCountAggregateInputType = {
    id?: true
    description?: true
    _all?: true
  }

  export type User_levelsAggregateArgs = {
    /**
     * Filter which user_levels to aggregate.
     * 
    **/
    where?: user_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_levels to fetch.
     * 
    **/
    orderBy?: Enumerable<user_levelsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: user_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_levels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_levels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_levels
    **/
    _count?: true | User_levelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_levelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_levelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_levelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_levelsMaxAggregateInputType
  }

  export type GetUser_levelsAggregateType<T extends User_levelsAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_levels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_levels[P]>
      : GetScalarType<T[P], AggregateUser_levels[P]>
  }




  export type User_levelsGroupByArgs = {
    where?: user_levelsWhereInput
    orderBy?: Enumerable<user_levelsOrderByWithAggregationInput>
    by: Array<User_levelsScalarFieldEnum>
    having?: user_levelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_levelsCountAggregateInputType | true
    _avg?: User_levelsAvgAggregateInputType
    _sum?: User_levelsSumAggregateInputType
    _min?: User_levelsMinAggregateInputType
    _max?: User_levelsMaxAggregateInputType
  }


  export type User_levelsGroupByOutputType = {
    id: number
    description: string
    _count: User_levelsCountAggregateOutputType | null
    _avg: User_levelsAvgAggregateOutputType | null
    _sum: User_levelsSumAggregateOutputType | null
    _min: User_levelsMinAggregateOutputType | null
    _max: User_levelsMaxAggregateOutputType | null
  }

  type GetUser_levelsGroupByPayload<T extends User_levelsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<User_levelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_levelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_levelsGroupByOutputType[P]>
            : GetScalarType<T[P], User_levelsGroupByOutputType[P]>
        }
      >
    >


  export type user_levelsSelect = {
    id?: boolean
    description?: boolean
    users?: boolean | usersFindManyArgs
    _count?: boolean | User_levelsCountOutputTypeArgs
  }

  export type user_levelsInclude = {
    users?: boolean | usersFindManyArgs
    _count?: boolean | User_levelsCountOutputTypeArgs
  }

  export type user_levelsGetPayload<
    S extends boolean | null | undefined | user_levelsArgs,
    U = keyof S
      > = S extends true
        ? user_levels
    : S extends undefined
    ? never
    : S extends user_levelsArgs | user_levelsFindManyArgs
    ?'include' extends U
    ? user_levels  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? Array < usersGetPayload<S['include'][P]>>  :
        P extends '_count' ? User_levelsCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? Array < usersGetPayload<S['select'][P]>>  :
        P extends '_count' ? User_levelsCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof user_levels ? user_levels[P] : never
  } 
    : user_levels
  : user_levels


  type user_levelsCountArgs = Merge<
    Omit<user_levelsFindManyArgs, 'select' | 'include'> & {
      select?: User_levelsCountAggregateInputType | true
    }
  >

  export interface user_levelsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User_levels that matches the filter.
     * @param {user_levelsFindUniqueArgs} args - Arguments to find a User_levels
     * @example
     * // Get one User_levels
     * const user_levels = await prisma.user_levels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_levelsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_levelsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_levels'> extends True ? CheckSelect<T, Prisma__user_levelsClient<user_levels>, Prisma__user_levelsClient<user_levelsGetPayload<T>>> : CheckSelect<T, Prisma__user_levelsClient<user_levels | null >, Prisma__user_levelsClient<user_levelsGetPayload<T> | null >>

    /**
     * Find the first User_levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_levelsFindFirstArgs} args - Arguments to find a User_levels
     * @example
     * // Get one User_levels
     * const user_levels = await prisma.user_levels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_levelsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_levelsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_levels'> extends True ? CheckSelect<T, Prisma__user_levelsClient<user_levels>, Prisma__user_levelsClient<user_levelsGetPayload<T>>> : CheckSelect<T, Prisma__user_levelsClient<user_levels | null >, Prisma__user_levelsClient<user_levelsGetPayload<T> | null >>

    /**
     * Find zero or more User_levels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_levelsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_levels
     * const user_levels = await prisma.user_levels.findMany()
     * 
     * // Get first 10 User_levels
     * const user_levels = await prisma.user_levels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_levelsWithIdOnly = await prisma.user_levels.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_levelsFindManyArgs>(
      args?: SelectSubset<T, user_levelsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<user_levels>>, PrismaPromise<Array<user_levelsGetPayload<T>>>>

    /**
     * Create a User_levels.
     * @param {user_levelsCreateArgs} args - Arguments to create a User_levels.
     * @example
     * // Create one User_levels
     * const User_levels = await prisma.user_levels.create({
     *   data: {
     *     // ... data to create a User_levels
     *   }
     * })
     * 
    **/
    create<T extends user_levelsCreateArgs>(
      args: SelectSubset<T, user_levelsCreateArgs>
    ): CheckSelect<T, Prisma__user_levelsClient<user_levels>, Prisma__user_levelsClient<user_levelsGetPayload<T>>>

    /**
     * Create many User_levels.
     *     @param {user_levelsCreateManyArgs} args - Arguments to create many User_levels.
     *     @example
     *     // Create many User_levels
     *     const user_levels = await prisma.user_levels.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_levelsCreateManyArgs>(
      args?: SelectSubset<T, user_levelsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_levels.
     * @param {user_levelsDeleteArgs} args - Arguments to delete one User_levels.
     * @example
     * // Delete one User_levels
     * const User_levels = await prisma.user_levels.delete({
     *   where: {
     *     // ... filter to delete one User_levels
     *   }
     * })
     * 
    **/
    delete<T extends user_levelsDeleteArgs>(
      args: SelectSubset<T, user_levelsDeleteArgs>
    ): CheckSelect<T, Prisma__user_levelsClient<user_levels>, Prisma__user_levelsClient<user_levelsGetPayload<T>>>

    /**
     * Update one User_levels.
     * @param {user_levelsUpdateArgs} args - Arguments to update one User_levels.
     * @example
     * // Update one User_levels
     * const user_levels = await prisma.user_levels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_levelsUpdateArgs>(
      args: SelectSubset<T, user_levelsUpdateArgs>
    ): CheckSelect<T, Prisma__user_levelsClient<user_levels>, Prisma__user_levelsClient<user_levelsGetPayload<T>>>

    /**
     * Delete zero or more User_levels.
     * @param {user_levelsDeleteManyArgs} args - Arguments to filter User_levels to delete.
     * @example
     * // Delete a few User_levels
     * const { count } = await prisma.user_levels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_levelsDeleteManyArgs>(
      args?: SelectSubset<T, user_levelsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_levelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_levels
     * const user_levels = await prisma.user_levels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_levelsUpdateManyArgs>(
      args: SelectSubset<T, user_levelsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_levels.
     * @param {user_levelsUpsertArgs} args - Arguments to update or create a User_levels.
     * @example
     * // Update or create a User_levels
     * const user_levels = await prisma.user_levels.upsert({
     *   create: {
     *     // ... data to create a User_levels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_levels we want to update
     *   }
     * })
    **/
    upsert<T extends user_levelsUpsertArgs>(
      args: SelectSubset<T, user_levelsUpsertArgs>
    ): CheckSelect<T, Prisma__user_levelsClient<user_levels>, Prisma__user_levelsClient<user_levelsGetPayload<T>>>

    /**
     * Find one User_levels that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {user_levelsFindUniqueOrThrowArgs} args - Arguments to find a User_levels
     * @example
     * // Get one User_levels
     * const user_levels = await prisma.user_levels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_levelsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, user_levelsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__user_levelsClient<user_levels>, Prisma__user_levelsClient<user_levelsGetPayload<T>>>

    /**
     * Find the first User_levels that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_levelsFindFirstOrThrowArgs} args - Arguments to find a User_levels
     * @example
     * // Get one User_levels
     * const user_levels = await prisma.user_levels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_levelsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, user_levelsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__user_levelsClient<user_levels>, Prisma__user_levelsClient<user_levelsGetPayload<T>>>

    /**
     * Count the number of User_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_levelsCountArgs} args - Arguments to filter User_levels to count.
     * @example
     * // Count the number of User_levels
     * const count = await prisma.user_levels.count({
     *   where: {
     *     // ... the filter for the User_levels we want to count
     *   }
     * })
    **/
    count<T extends user_levelsCountArgs>(
      args?: Subset<T, user_levelsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_levelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_levelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_levelsAggregateArgs>(args: Subset<T, User_levelsAggregateArgs>): PrismaPromise<GetUser_levelsAggregateType<T>>

    /**
     * Group by User_levels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_levelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_levelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_levelsGroupByArgs['orderBy'] }
        : { orderBy?: User_levelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_levelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_levelsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_levels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_levelsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersFindManyArgs = {}>(args?: Subset<T, usersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<users>>, PrismaPromise<Array<usersGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user_levels base type for findUnique actions
   */
  export type user_levelsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user_levels
     * 
    **/
    select?: user_levelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_levelsInclude | null
    /**
     * Filter, which user_levels to fetch.
     * 
    **/
    where: user_levelsWhereUniqueInput
  }

  /**
   * user_levels: findUnique
   */
  export interface user_levelsFindUniqueArgs extends user_levelsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_levels base type for findFirst actions
   */
  export type user_levelsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user_levels
     * 
    **/
    select?: user_levelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_levelsInclude | null
    /**
     * Filter, which user_levels to fetch.
     * 
    **/
    where?: user_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_levels to fetch.
     * 
    **/
    orderBy?: Enumerable<user_levelsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_levels.
     * 
    **/
    cursor?: user_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_levels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_levels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_levels.
     * 
    **/
    distinct?: Enumerable<User_levelsScalarFieldEnum>
  }

  /**
   * user_levels: findFirst
   */
  export interface user_levelsFindFirstArgs extends user_levelsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_levels findMany
   */
  export type user_levelsFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_levels
     * 
    **/
    select?: user_levelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_levelsInclude | null
    /**
     * Filter, which user_levels to fetch.
     * 
    **/
    where?: user_levelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_levels to fetch.
     * 
    **/
    orderBy?: Enumerable<user_levelsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_levels.
     * 
    **/
    cursor?: user_levelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_levels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_levels.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_levelsScalarFieldEnum>
  }


  /**
   * user_levels create
   */
  export type user_levelsCreateArgs = {
    /**
     * Select specific fields to fetch from the user_levels
     * 
    **/
    select?: user_levelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_levelsInclude | null
    /**
     * The data needed to create a user_levels.
     * 
    **/
    data: XOR<user_levelsCreateInput, user_levelsUncheckedCreateInput>
  }


  /**
   * user_levels createMany
   */
  export type user_levelsCreateManyArgs = {
    /**
     * The data used to create many user_levels.
     * 
    **/
    data: Enumerable<user_levelsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_levels update
   */
  export type user_levelsUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_levels
     * 
    **/
    select?: user_levelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_levelsInclude | null
    /**
     * The data needed to update a user_levels.
     * 
    **/
    data: XOR<user_levelsUpdateInput, user_levelsUncheckedUpdateInput>
    /**
     * Choose, which user_levels to update.
     * 
    **/
    where: user_levelsWhereUniqueInput
  }


  /**
   * user_levels updateMany
   */
  export type user_levelsUpdateManyArgs = {
    /**
     * The data used to update user_levels.
     * 
    **/
    data: XOR<user_levelsUpdateManyMutationInput, user_levelsUncheckedUpdateManyInput>
    /**
     * Filter which user_levels to update
     * 
    **/
    where?: user_levelsWhereInput
  }


  /**
   * user_levels upsert
   */
  export type user_levelsUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_levels
     * 
    **/
    select?: user_levelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_levelsInclude | null
    /**
     * The filter to search for the user_levels to update in case it exists.
     * 
    **/
    where: user_levelsWhereUniqueInput
    /**
     * In case the user_levels found by the `where` argument doesn't exist, create a new user_levels with this data.
     * 
    **/
    create: XOR<user_levelsCreateInput, user_levelsUncheckedCreateInput>
    /**
     * In case the user_levels was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<user_levelsUpdateInput, user_levelsUncheckedUpdateInput>
  }


  /**
   * user_levels delete
   */
  export type user_levelsDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_levels
     * 
    **/
    select?: user_levelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_levelsInclude | null
    /**
     * Filter which user_levels to delete.
     * 
    **/
    where: user_levelsWhereUniqueInput
  }


  /**
   * user_levels deleteMany
   */
  export type user_levelsDeleteManyArgs = {
    /**
     * Filter which user_levels to delete
     * 
    **/
    where?: user_levelsWhereInput
  }


  /**
   * user_levels: findUniqueOrThrow
   */
  export type user_levelsFindUniqueOrThrowArgs = user_levelsFindUniqueArgsBase
      

  /**
   * user_levels: findFirstOrThrow
   */
  export type user_levelsFindFirstOrThrowArgs = user_levelsFindFirstArgsBase
      

  /**
   * user_levels without action
   */
  export type user_levelsArgs = {
    /**
     * Select specific fields to fetch from the user_levels
     * 
    **/
    select?: user_levelsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_levelsInclude | null
  }



  /**
   * Model user_profiles
   */


  export type AggregateUser_profiles = {
    _count: User_profilesCountAggregateOutputType | null
    _avg: User_profilesAvgAggregateOutputType | null
    _sum: User_profilesSumAggregateOutputType | null
    _min: User_profilesMinAggregateOutputType | null
    _max: User_profilesMaxAggregateOutputType | null
  }

  export type User_profilesAvgAggregateOutputType = {
    id: number | null
  }

  export type User_profilesSumAggregateOutputType = {
    id: number | null
  }

  export type User_profilesMinAggregateOutputType = {
    id: number | null
    profile_message: string | null
    profile_picture: string | null
  }

  export type User_profilesMaxAggregateOutputType = {
    id: number | null
    profile_message: string | null
    profile_picture: string | null
  }

  export type User_profilesCountAggregateOutputType = {
    id: number
    profile_message: number
    profile_picture: number
    _all: number
  }


  export type User_profilesAvgAggregateInputType = {
    id?: true
  }

  export type User_profilesSumAggregateInputType = {
    id?: true
  }

  export type User_profilesMinAggregateInputType = {
    id?: true
    profile_message?: true
    profile_picture?: true
  }

  export type User_profilesMaxAggregateInputType = {
    id?: true
    profile_message?: true
    profile_picture?: true
  }

  export type User_profilesCountAggregateInputType = {
    id?: true
    profile_message?: true
    profile_picture?: true
    _all?: true
  }

  export type User_profilesAggregateArgs = {
    /**
     * Filter which user_profiles to aggregate.
     * 
    **/
    where?: user_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<user_profilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: user_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_profiles
    **/
    _count?: true | User_profilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_profilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_profilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_profilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_profilesMaxAggregateInputType
  }

  export type GetUser_profilesAggregateType<T extends User_profilesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_profiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_profiles[P]>
      : GetScalarType<T[P], AggregateUser_profiles[P]>
  }




  export type User_profilesGroupByArgs = {
    where?: user_profilesWhereInput
    orderBy?: Enumerable<user_profilesOrderByWithAggregationInput>
    by: Array<User_profilesScalarFieldEnum>
    having?: user_profilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_profilesCountAggregateInputType | true
    _avg?: User_profilesAvgAggregateInputType
    _sum?: User_profilesSumAggregateInputType
    _min?: User_profilesMinAggregateInputType
    _max?: User_profilesMaxAggregateInputType
  }


  export type User_profilesGroupByOutputType = {
    id: number
    profile_message: string | null
    profile_picture: string | null
    _count: User_profilesCountAggregateOutputType | null
    _avg: User_profilesAvgAggregateOutputType | null
    _sum: User_profilesSumAggregateOutputType | null
    _min: User_profilesMinAggregateOutputType | null
    _max: User_profilesMaxAggregateOutputType | null
  }

  type GetUser_profilesGroupByPayload<T extends User_profilesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<User_profilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_profilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_profilesGroupByOutputType[P]>
            : GetScalarType<T[P], User_profilesGroupByOutputType[P]>
        }
      >
    >


  export type user_profilesSelect = {
    id?: boolean
    profile_message?: boolean
    profile_picture?: boolean
    users?: boolean | usersFindManyArgs
    _count?: boolean | User_profilesCountOutputTypeArgs
  }

  export type user_profilesInclude = {
    users?: boolean | usersFindManyArgs
    _count?: boolean | User_profilesCountOutputTypeArgs
  }

  export type user_profilesGetPayload<
    S extends boolean | null | undefined | user_profilesArgs,
    U = keyof S
      > = S extends true
        ? user_profiles
    : S extends undefined
    ? never
    : S extends user_profilesArgs | user_profilesFindManyArgs
    ?'include' extends U
    ? user_profiles  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? Array < usersGetPayload<S['include'][P]>>  :
        P extends '_count' ? User_profilesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? Array < usersGetPayload<S['select'][P]>>  :
        P extends '_count' ? User_profilesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof user_profiles ? user_profiles[P] : never
  } 
    : user_profiles
  : user_profiles


  type user_profilesCountArgs = Merge<
    Omit<user_profilesFindManyArgs, 'select' | 'include'> & {
      select?: User_profilesCountAggregateInputType | true
    }
  >

  export interface user_profilesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User_profiles that matches the filter.
     * @param {user_profilesFindUniqueArgs} args - Arguments to find a User_profiles
     * @example
     * // Get one User_profiles
     * const user_profiles = await prisma.user_profiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_profilesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_profilesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_profiles'> extends True ? CheckSelect<T, Prisma__user_profilesClient<user_profiles>, Prisma__user_profilesClient<user_profilesGetPayload<T>>> : CheckSelect<T, Prisma__user_profilesClient<user_profiles | null >, Prisma__user_profilesClient<user_profilesGetPayload<T> | null >>

    /**
     * Find the first User_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_profilesFindFirstArgs} args - Arguments to find a User_profiles
     * @example
     * // Get one User_profiles
     * const user_profiles = await prisma.user_profiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_profilesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_profilesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_profiles'> extends True ? CheckSelect<T, Prisma__user_profilesClient<user_profiles>, Prisma__user_profilesClient<user_profilesGetPayload<T>>> : CheckSelect<T, Prisma__user_profilesClient<user_profiles | null >, Prisma__user_profilesClient<user_profilesGetPayload<T> | null >>

    /**
     * Find zero or more User_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_profilesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_profiles
     * const user_profiles = await prisma.user_profiles.findMany()
     * 
     * // Get first 10 User_profiles
     * const user_profiles = await prisma.user_profiles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_profilesWithIdOnly = await prisma.user_profiles.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_profilesFindManyArgs>(
      args?: SelectSubset<T, user_profilesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<user_profiles>>, PrismaPromise<Array<user_profilesGetPayload<T>>>>

    /**
     * Create a User_profiles.
     * @param {user_profilesCreateArgs} args - Arguments to create a User_profiles.
     * @example
     * // Create one User_profiles
     * const User_profiles = await prisma.user_profiles.create({
     *   data: {
     *     // ... data to create a User_profiles
     *   }
     * })
     * 
    **/
    create<T extends user_profilesCreateArgs>(
      args: SelectSubset<T, user_profilesCreateArgs>
    ): CheckSelect<T, Prisma__user_profilesClient<user_profiles>, Prisma__user_profilesClient<user_profilesGetPayload<T>>>

    /**
     * Create many User_profiles.
     *     @param {user_profilesCreateManyArgs} args - Arguments to create many User_profiles.
     *     @example
     *     // Create many User_profiles
     *     const user_profiles = await prisma.user_profiles.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_profilesCreateManyArgs>(
      args?: SelectSubset<T, user_profilesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_profiles.
     * @param {user_profilesDeleteArgs} args - Arguments to delete one User_profiles.
     * @example
     * // Delete one User_profiles
     * const User_profiles = await prisma.user_profiles.delete({
     *   where: {
     *     // ... filter to delete one User_profiles
     *   }
     * })
     * 
    **/
    delete<T extends user_profilesDeleteArgs>(
      args: SelectSubset<T, user_profilesDeleteArgs>
    ): CheckSelect<T, Prisma__user_profilesClient<user_profiles>, Prisma__user_profilesClient<user_profilesGetPayload<T>>>

    /**
     * Update one User_profiles.
     * @param {user_profilesUpdateArgs} args - Arguments to update one User_profiles.
     * @example
     * // Update one User_profiles
     * const user_profiles = await prisma.user_profiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_profilesUpdateArgs>(
      args: SelectSubset<T, user_profilesUpdateArgs>
    ): CheckSelect<T, Prisma__user_profilesClient<user_profiles>, Prisma__user_profilesClient<user_profilesGetPayload<T>>>

    /**
     * Delete zero or more User_profiles.
     * @param {user_profilesDeleteManyArgs} args - Arguments to filter User_profiles to delete.
     * @example
     * // Delete a few User_profiles
     * const { count } = await prisma.user_profiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_profilesDeleteManyArgs>(
      args?: SelectSubset<T, user_profilesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_profilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_profiles
     * const user_profiles = await prisma.user_profiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_profilesUpdateManyArgs>(
      args: SelectSubset<T, user_profilesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_profiles.
     * @param {user_profilesUpsertArgs} args - Arguments to update or create a User_profiles.
     * @example
     * // Update or create a User_profiles
     * const user_profiles = await prisma.user_profiles.upsert({
     *   create: {
     *     // ... data to create a User_profiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_profiles we want to update
     *   }
     * })
    **/
    upsert<T extends user_profilesUpsertArgs>(
      args: SelectSubset<T, user_profilesUpsertArgs>
    ): CheckSelect<T, Prisma__user_profilesClient<user_profiles>, Prisma__user_profilesClient<user_profilesGetPayload<T>>>

    /**
     * Find one User_profiles that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {user_profilesFindUniqueOrThrowArgs} args - Arguments to find a User_profiles
     * @example
     * // Get one User_profiles
     * const user_profiles = await prisma.user_profiles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_profilesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, user_profilesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__user_profilesClient<user_profiles>, Prisma__user_profilesClient<user_profilesGetPayload<T>>>

    /**
     * Find the first User_profiles that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_profilesFindFirstOrThrowArgs} args - Arguments to find a User_profiles
     * @example
     * // Get one User_profiles
     * const user_profiles = await prisma.user_profiles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_profilesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, user_profilesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__user_profilesClient<user_profiles>, Prisma__user_profilesClient<user_profilesGetPayload<T>>>

    /**
     * Count the number of User_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_profilesCountArgs} args - Arguments to filter User_profiles to count.
     * @example
     * // Count the number of User_profiles
     * const count = await prisma.user_profiles.count({
     *   where: {
     *     // ... the filter for the User_profiles we want to count
     *   }
     * })
    **/
    count<T extends user_profilesCountArgs>(
      args?: Subset<T, user_profilesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_profilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_profilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_profilesAggregateArgs>(args: Subset<T, User_profilesAggregateArgs>): PrismaPromise<GetUser_profilesAggregateType<T>>

    /**
     * Group by User_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_profilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_profilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_profilesGroupByArgs['orderBy'] }
        : { orderBy?: User_profilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_profilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_profilesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_profiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_profilesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersFindManyArgs = {}>(args?: Subset<T, usersFindManyArgs>): CheckSelect<T, PrismaPromise<Array<users>>, PrismaPromise<Array<usersGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user_profiles base type for findUnique actions
   */
  export type user_profilesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user_profiles
     * 
    **/
    select?: user_profilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_profilesInclude | null
    /**
     * Filter, which user_profiles to fetch.
     * 
    **/
    where: user_profilesWhereUniqueInput
  }

  /**
   * user_profiles: findUnique
   */
  export interface user_profilesFindUniqueArgs extends user_profilesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_profiles base type for findFirst actions
   */
  export type user_profilesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user_profiles
     * 
    **/
    select?: user_profilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_profilesInclude | null
    /**
     * Filter, which user_profiles to fetch.
     * 
    **/
    where?: user_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<user_profilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_profiles.
     * 
    **/
    cursor?: user_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_profiles.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_profiles.
     * 
    **/
    distinct?: Enumerable<User_profilesScalarFieldEnum>
  }

  /**
   * user_profiles: findFirst
   */
  export interface user_profilesFindFirstArgs extends user_profilesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_profiles findMany
   */
  export type user_profilesFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_profiles
     * 
    **/
    select?: user_profilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_profilesInclude | null
    /**
     * Filter, which user_profiles to fetch.
     * 
    **/
    where?: user_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_profiles to fetch.
     * 
    **/
    orderBy?: Enumerable<user_profilesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_profiles.
     * 
    **/
    cursor?: user_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_profiles from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_profiles.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_profilesScalarFieldEnum>
  }


  /**
   * user_profiles create
   */
  export type user_profilesCreateArgs = {
    /**
     * Select specific fields to fetch from the user_profiles
     * 
    **/
    select?: user_profilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_profilesInclude | null
    /**
     * The data needed to create a user_profiles.
     * 
    **/
    data: XOR<user_profilesCreateInput, user_profilesUncheckedCreateInput>
  }


  /**
   * user_profiles createMany
   */
  export type user_profilesCreateManyArgs = {
    /**
     * The data used to create many user_profiles.
     * 
    **/
    data: Enumerable<user_profilesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_profiles update
   */
  export type user_profilesUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_profiles
     * 
    **/
    select?: user_profilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_profilesInclude | null
    /**
     * The data needed to update a user_profiles.
     * 
    **/
    data: XOR<user_profilesUpdateInput, user_profilesUncheckedUpdateInput>
    /**
     * Choose, which user_profiles to update.
     * 
    **/
    where: user_profilesWhereUniqueInput
  }


  /**
   * user_profiles updateMany
   */
  export type user_profilesUpdateManyArgs = {
    /**
     * The data used to update user_profiles.
     * 
    **/
    data: XOR<user_profilesUpdateManyMutationInput, user_profilesUncheckedUpdateManyInput>
    /**
     * Filter which user_profiles to update
     * 
    **/
    where?: user_profilesWhereInput
  }


  /**
   * user_profiles upsert
   */
  export type user_profilesUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_profiles
     * 
    **/
    select?: user_profilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_profilesInclude | null
    /**
     * The filter to search for the user_profiles to update in case it exists.
     * 
    **/
    where: user_profilesWhereUniqueInput
    /**
     * In case the user_profiles found by the `where` argument doesn't exist, create a new user_profiles with this data.
     * 
    **/
    create: XOR<user_profilesCreateInput, user_profilesUncheckedCreateInput>
    /**
     * In case the user_profiles was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<user_profilesUpdateInput, user_profilesUncheckedUpdateInput>
  }


  /**
   * user_profiles delete
   */
  export type user_profilesDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_profiles
     * 
    **/
    select?: user_profilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_profilesInclude | null
    /**
     * Filter which user_profiles to delete.
     * 
    **/
    where: user_profilesWhereUniqueInput
  }


  /**
   * user_profiles deleteMany
   */
  export type user_profilesDeleteManyArgs = {
    /**
     * Filter which user_profiles to delete
     * 
    **/
    where?: user_profilesWhereInput
  }


  /**
   * user_profiles: findUniqueOrThrow
   */
  export type user_profilesFindUniqueOrThrowArgs = user_profilesFindUniqueArgsBase
      

  /**
   * user_profiles: findFirstOrThrow
   */
  export type user_profilesFindFirstOrThrowArgs = user_profilesFindFirstArgsBase
      

  /**
   * user_profiles without action
   */
  export type user_profilesArgs = {
    /**
     * Select specific fields to fetch from the user_profiles
     * 
    **/
    select?: user_profilesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_profilesInclude | null
  }



  /**
   * Model user_to_reaction
   */


  export type AggregateUser_to_reaction = {
    _count: User_to_reactionCountAggregateOutputType | null
    _avg: User_to_reactionAvgAggregateOutputType | null
    _sum: User_to_reactionSumAggregateOutputType | null
    _min: User_to_reactionMinAggregateOutputType | null
    _max: User_to_reactionMaxAggregateOutputType | null
  }

  export type User_to_reactionAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    reaction_id: number | null
  }

  export type User_to_reactionSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    reaction_id: number | null
  }

  export type User_to_reactionMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    reaction_id: number | null
  }

  export type User_to_reactionMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    reaction_id: number | null
  }

  export type User_to_reactionCountAggregateOutputType = {
    id: number
    user_id: number
    reaction_id: number
    _all: number
  }


  export type User_to_reactionAvgAggregateInputType = {
    id?: true
    user_id?: true
    reaction_id?: true
  }

  export type User_to_reactionSumAggregateInputType = {
    id?: true
    user_id?: true
    reaction_id?: true
  }

  export type User_to_reactionMinAggregateInputType = {
    id?: true
    user_id?: true
    reaction_id?: true
  }

  export type User_to_reactionMaxAggregateInputType = {
    id?: true
    user_id?: true
    reaction_id?: true
  }

  export type User_to_reactionCountAggregateInputType = {
    id?: true
    user_id?: true
    reaction_id?: true
    _all?: true
  }

  export type User_to_reactionAggregateArgs = {
    /**
     * Filter which user_to_reaction to aggregate.
     * 
    **/
    where?: user_to_reactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_to_reactions to fetch.
     * 
    **/
    orderBy?: Enumerable<user_to_reactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: user_to_reactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_to_reactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_to_reactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_to_reactions
    **/
    _count?: true | User_to_reactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_to_reactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_to_reactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_to_reactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_to_reactionMaxAggregateInputType
  }

  export type GetUser_to_reactionAggregateType<T extends User_to_reactionAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_to_reaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_to_reaction[P]>
      : GetScalarType<T[P], AggregateUser_to_reaction[P]>
  }




  export type User_to_reactionGroupByArgs = {
    where?: user_to_reactionWhereInput
    orderBy?: Enumerable<user_to_reactionOrderByWithAggregationInput>
    by: Array<User_to_reactionScalarFieldEnum>
    having?: user_to_reactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_to_reactionCountAggregateInputType | true
    _avg?: User_to_reactionAvgAggregateInputType
    _sum?: User_to_reactionSumAggregateInputType
    _min?: User_to_reactionMinAggregateInputType
    _max?: User_to_reactionMaxAggregateInputType
  }


  export type User_to_reactionGroupByOutputType = {
    id: number
    user_id: number
    reaction_id: number
    _count: User_to_reactionCountAggregateOutputType | null
    _avg: User_to_reactionAvgAggregateOutputType | null
    _sum: User_to_reactionSumAggregateOutputType | null
    _min: User_to_reactionMinAggregateOutputType | null
    _max: User_to_reactionMaxAggregateOutputType | null
  }

  type GetUser_to_reactionGroupByPayload<T extends User_to_reactionGroupByArgs> = PrismaPromise<
    Array<
      PickArray<User_to_reactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_to_reactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_to_reactionGroupByOutputType[P]>
            : GetScalarType<T[P], User_to_reactionGroupByOutputType[P]>
        }
      >
    >


  export type user_to_reactionSelect = {
    id?: boolean
    user_id?: boolean
    reaction_id?: boolean
    reactions?: boolean | reactionsArgs
    users?: boolean | usersArgs
  }

  export type user_to_reactionInclude = {
    reactions?: boolean | reactionsArgs
    users?: boolean | usersArgs
  }

  export type user_to_reactionGetPayload<
    S extends boolean | null | undefined | user_to_reactionArgs,
    U = keyof S
      > = S extends true
        ? user_to_reaction
    : S extends undefined
    ? never
    : S extends user_to_reactionArgs | user_to_reactionFindManyArgs
    ?'include' extends U
    ? user_to_reaction  & {
    [P in TrueKeys<S['include']>]:
        P extends 'reactions' ? reactionsGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'reactions' ? reactionsGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof user_to_reaction ? user_to_reaction[P] : never
  } 
    : user_to_reaction
  : user_to_reaction


  type user_to_reactionCountArgs = Merge<
    Omit<user_to_reactionFindManyArgs, 'select' | 'include'> & {
      select?: User_to_reactionCountAggregateInputType | true
    }
  >

  export interface user_to_reactionDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User_to_reaction that matches the filter.
     * @param {user_to_reactionFindUniqueArgs} args - Arguments to find a User_to_reaction
     * @example
     * // Get one User_to_reaction
     * const user_to_reaction = await prisma.user_to_reaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_to_reactionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_to_reactionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_to_reaction'> extends True ? CheckSelect<T, Prisma__user_to_reactionClient<user_to_reaction>, Prisma__user_to_reactionClient<user_to_reactionGetPayload<T>>> : CheckSelect<T, Prisma__user_to_reactionClient<user_to_reaction | null >, Prisma__user_to_reactionClient<user_to_reactionGetPayload<T> | null >>

    /**
     * Find the first User_to_reaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_to_reactionFindFirstArgs} args - Arguments to find a User_to_reaction
     * @example
     * // Get one User_to_reaction
     * const user_to_reaction = await prisma.user_to_reaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_to_reactionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_to_reactionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_to_reaction'> extends True ? CheckSelect<T, Prisma__user_to_reactionClient<user_to_reaction>, Prisma__user_to_reactionClient<user_to_reactionGetPayload<T>>> : CheckSelect<T, Prisma__user_to_reactionClient<user_to_reaction | null >, Prisma__user_to_reactionClient<user_to_reactionGetPayload<T> | null >>

    /**
     * Find zero or more User_to_reactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_to_reactionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_to_reactions
     * const user_to_reactions = await prisma.user_to_reaction.findMany()
     * 
     * // Get first 10 User_to_reactions
     * const user_to_reactions = await prisma.user_to_reaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_to_reactionWithIdOnly = await prisma.user_to_reaction.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_to_reactionFindManyArgs>(
      args?: SelectSubset<T, user_to_reactionFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<user_to_reaction>>, PrismaPromise<Array<user_to_reactionGetPayload<T>>>>

    /**
     * Create a User_to_reaction.
     * @param {user_to_reactionCreateArgs} args - Arguments to create a User_to_reaction.
     * @example
     * // Create one User_to_reaction
     * const User_to_reaction = await prisma.user_to_reaction.create({
     *   data: {
     *     // ... data to create a User_to_reaction
     *   }
     * })
     * 
    **/
    create<T extends user_to_reactionCreateArgs>(
      args: SelectSubset<T, user_to_reactionCreateArgs>
    ): CheckSelect<T, Prisma__user_to_reactionClient<user_to_reaction>, Prisma__user_to_reactionClient<user_to_reactionGetPayload<T>>>

    /**
     * Create many User_to_reactions.
     *     @param {user_to_reactionCreateManyArgs} args - Arguments to create many User_to_reactions.
     *     @example
     *     // Create many User_to_reactions
     *     const user_to_reaction = await prisma.user_to_reaction.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_to_reactionCreateManyArgs>(
      args?: SelectSubset<T, user_to_reactionCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_to_reaction.
     * @param {user_to_reactionDeleteArgs} args - Arguments to delete one User_to_reaction.
     * @example
     * // Delete one User_to_reaction
     * const User_to_reaction = await prisma.user_to_reaction.delete({
     *   where: {
     *     // ... filter to delete one User_to_reaction
     *   }
     * })
     * 
    **/
    delete<T extends user_to_reactionDeleteArgs>(
      args: SelectSubset<T, user_to_reactionDeleteArgs>
    ): CheckSelect<T, Prisma__user_to_reactionClient<user_to_reaction>, Prisma__user_to_reactionClient<user_to_reactionGetPayload<T>>>

    /**
     * Update one User_to_reaction.
     * @param {user_to_reactionUpdateArgs} args - Arguments to update one User_to_reaction.
     * @example
     * // Update one User_to_reaction
     * const user_to_reaction = await prisma.user_to_reaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_to_reactionUpdateArgs>(
      args: SelectSubset<T, user_to_reactionUpdateArgs>
    ): CheckSelect<T, Prisma__user_to_reactionClient<user_to_reaction>, Prisma__user_to_reactionClient<user_to_reactionGetPayload<T>>>

    /**
     * Delete zero or more User_to_reactions.
     * @param {user_to_reactionDeleteManyArgs} args - Arguments to filter User_to_reactions to delete.
     * @example
     * // Delete a few User_to_reactions
     * const { count } = await prisma.user_to_reaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_to_reactionDeleteManyArgs>(
      args?: SelectSubset<T, user_to_reactionDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_to_reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_to_reactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_to_reactions
     * const user_to_reaction = await prisma.user_to_reaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_to_reactionUpdateManyArgs>(
      args: SelectSubset<T, user_to_reactionUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_to_reaction.
     * @param {user_to_reactionUpsertArgs} args - Arguments to update or create a User_to_reaction.
     * @example
     * // Update or create a User_to_reaction
     * const user_to_reaction = await prisma.user_to_reaction.upsert({
     *   create: {
     *     // ... data to create a User_to_reaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_to_reaction we want to update
     *   }
     * })
    **/
    upsert<T extends user_to_reactionUpsertArgs>(
      args: SelectSubset<T, user_to_reactionUpsertArgs>
    ): CheckSelect<T, Prisma__user_to_reactionClient<user_to_reaction>, Prisma__user_to_reactionClient<user_to_reactionGetPayload<T>>>

    /**
     * Find one User_to_reaction that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {user_to_reactionFindUniqueOrThrowArgs} args - Arguments to find a User_to_reaction
     * @example
     * // Get one User_to_reaction
     * const user_to_reaction = await prisma.user_to_reaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_to_reactionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, user_to_reactionFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__user_to_reactionClient<user_to_reaction>, Prisma__user_to_reactionClient<user_to_reactionGetPayload<T>>>

    /**
     * Find the first User_to_reaction that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_to_reactionFindFirstOrThrowArgs} args - Arguments to find a User_to_reaction
     * @example
     * // Get one User_to_reaction
     * const user_to_reaction = await prisma.user_to_reaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_to_reactionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, user_to_reactionFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__user_to_reactionClient<user_to_reaction>, Prisma__user_to_reactionClient<user_to_reactionGetPayload<T>>>

    /**
     * Count the number of User_to_reactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_to_reactionCountArgs} args - Arguments to filter User_to_reactions to count.
     * @example
     * // Count the number of User_to_reactions
     * const count = await prisma.user_to_reaction.count({
     *   where: {
     *     // ... the filter for the User_to_reactions we want to count
     *   }
     * })
    **/
    count<T extends user_to_reactionCountArgs>(
      args?: Subset<T, user_to_reactionCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_to_reactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_to_reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_to_reactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_to_reactionAggregateArgs>(args: Subset<T, User_to_reactionAggregateArgs>): PrismaPromise<GetUser_to_reactionAggregateType<T>>

    /**
     * Group by User_to_reaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_to_reactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_to_reactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_to_reactionGroupByArgs['orderBy'] }
        : { orderBy?: User_to_reactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_to_reactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_to_reactionGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_to_reaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_to_reactionClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    reactions<T extends reactionsArgs = {}>(args?: Subset<T, reactionsArgs>): CheckSelect<T, Prisma__reactionsClient<reactions | null >, Prisma__reactionsClient<reactionsGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user_to_reaction base type for findUnique actions
   */
  export type user_to_reactionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user_to_reaction
     * 
    **/
    select?: user_to_reactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_to_reactionInclude | null
    /**
     * Filter, which user_to_reaction to fetch.
     * 
    **/
    where: user_to_reactionWhereUniqueInput
  }

  /**
   * user_to_reaction: findUnique
   */
  export interface user_to_reactionFindUniqueArgs extends user_to_reactionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_to_reaction base type for findFirst actions
   */
  export type user_to_reactionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user_to_reaction
     * 
    **/
    select?: user_to_reactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_to_reactionInclude | null
    /**
     * Filter, which user_to_reaction to fetch.
     * 
    **/
    where?: user_to_reactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_to_reactions to fetch.
     * 
    **/
    orderBy?: Enumerable<user_to_reactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_to_reactions.
     * 
    **/
    cursor?: user_to_reactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_to_reactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_to_reactions.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_to_reactions.
     * 
    **/
    distinct?: Enumerable<User_to_reactionScalarFieldEnum>
  }

  /**
   * user_to_reaction: findFirst
   */
  export interface user_to_reactionFindFirstArgs extends user_to_reactionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_to_reaction findMany
   */
  export type user_to_reactionFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_to_reaction
     * 
    **/
    select?: user_to_reactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_to_reactionInclude | null
    /**
     * Filter, which user_to_reactions to fetch.
     * 
    **/
    where?: user_to_reactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_to_reactions to fetch.
     * 
    **/
    orderBy?: Enumerable<user_to_reactionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_to_reactions.
     * 
    **/
    cursor?: user_to_reactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_to_reactions from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_to_reactions.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_to_reactionScalarFieldEnum>
  }


  /**
   * user_to_reaction create
   */
  export type user_to_reactionCreateArgs = {
    /**
     * Select specific fields to fetch from the user_to_reaction
     * 
    **/
    select?: user_to_reactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_to_reactionInclude | null
    /**
     * The data needed to create a user_to_reaction.
     * 
    **/
    data: XOR<user_to_reactionCreateInput, user_to_reactionUncheckedCreateInput>
  }


  /**
   * user_to_reaction createMany
   */
  export type user_to_reactionCreateManyArgs = {
    /**
     * The data used to create many user_to_reactions.
     * 
    **/
    data: Enumerable<user_to_reactionCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_to_reaction update
   */
  export type user_to_reactionUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_to_reaction
     * 
    **/
    select?: user_to_reactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_to_reactionInclude | null
    /**
     * The data needed to update a user_to_reaction.
     * 
    **/
    data: XOR<user_to_reactionUpdateInput, user_to_reactionUncheckedUpdateInput>
    /**
     * Choose, which user_to_reaction to update.
     * 
    **/
    where: user_to_reactionWhereUniqueInput
  }


  /**
   * user_to_reaction updateMany
   */
  export type user_to_reactionUpdateManyArgs = {
    /**
     * The data used to update user_to_reactions.
     * 
    **/
    data: XOR<user_to_reactionUpdateManyMutationInput, user_to_reactionUncheckedUpdateManyInput>
    /**
     * Filter which user_to_reactions to update
     * 
    **/
    where?: user_to_reactionWhereInput
  }


  /**
   * user_to_reaction upsert
   */
  export type user_to_reactionUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_to_reaction
     * 
    **/
    select?: user_to_reactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_to_reactionInclude | null
    /**
     * The filter to search for the user_to_reaction to update in case it exists.
     * 
    **/
    where: user_to_reactionWhereUniqueInput
    /**
     * In case the user_to_reaction found by the `where` argument doesn't exist, create a new user_to_reaction with this data.
     * 
    **/
    create: XOR<user_to_reactionCreateInput, user_to_reactionUncheckedCreateInput>
    /**
     * In case the user_to_reaction was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<user_to_reactionUpdateInput, user_to_reactionUncheckedUpdateInput>
  }


  /**
   * user_to_reaction delete
   */
  export type user_to_reactionDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_to_reaction
     * 
    **/
    select?: user_to_reactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_to_reactionInclude | null
    /**
     * Filter which user_to_reaction to delete.
     * 
    **/
    where: user_to_reactionWhereUniqueInput
  }


  /**
   * user_to_reaction deleteMany
   */
  export type user_to_reactionDeleteManyArgs = {
    /**
     * Filter which user_to_reactions to delete
     * 
    **/
    where?: user_to_reactionWhereInput
  }


  /**
   * user_to_reaction: findUniqueOrThrow
   */
  export type user_to_reactionFindUniqueOrThrowArgs = user_to_reactionFindUniqueArgsBase
      

  /**
   * user_to_reaction: findFirstOrThrow
   */
  export type user_to_reactionFindFirstOrThrowArgs = user_to_reactionFindFirstArgsBase
      

  /**
   * user_to_reaction without action
   */
  export type user_to_reactionArgs = {
    /**
     * Select specific fields to fetch from the user_to_reaction
     * 
    **/
    select?: user_to_reactionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_to_reactionInclude | null
  }



  /**
   * Model user_votes
   */


  export type AggregateUser_votes = {
    _count: User_votesCountAggregateOutputType | null
    _avg: User_votesAvgAggregateOutputType | null
    _sum: User_votesSumAggregateOutputType | null
    _min: User_votesMinAggregateOutputType | null
    _max: User_votesMaxAggregateOutputType | null
  }

  export type User_votesAvgAggregateOutputType = {
    id: number | null
    user_id: number | null
    user_vote: number | null
  }

  export type User_votesSumAggregateOutputType = {
    id: number | null
    user_id: number | null
    user_vote: number | null
  }

  export type User_votesMinAggregateOutputType = {
    id: number | null
    user_id: number | null
    user_vote: number | null
  }

  export type User_votesMaxAggregateOutputType = {
    id: number | null
    user_id: number | null
    user_vote: number | null
  }

  export type User_votesCountAggregateOutputType = {
    id: number
    user_id: number
    user_vote: number
    _all: number
  }


  export type User_votesAvgAggregateInputType = {
    id?: true
    user_id?: true
    user_vote?: true
  }

  export type User_votesSumAggregateInputType = {
    id?: true
    user_id?: true
    user_vote?: true
  }

  export type User_votesMinAggregateInputType = {
    id?: true
    user_id?: true
    user_vote?: true
  }

  export type User_votesMaxAggregateInputType = {
    id?: true
    user_id?: true
    user_vote?: true
  }

  export type User_votesCountAggregateInputType = {
    id?: true
    user_id?: true
    user_vote?: true
    _all?: true
  }

  export type User_votesAggregateArgs = {
    /**
     * Filter which user_votes to aggregate.
     * 
    **/
    where?: user_votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_votes to fetch.
     * 
    **/
    orderBy?: Enumerable<user_votesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: user_votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_votes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_votes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_votes
    **/
    _count?: true | User_votesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_votesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_votesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_votesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_votesMaxAggregateInputType
  }

  export type GetUser_votesAggregateType<T extends User_votesAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_votes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_votes[P]>
      : GetScalarType<T[P], AggregateUser_votes[P]>
  }




  export type User_votesGroupByArgs = {
    where?: user_votesWhereInput
    orderBy?: Enumerable<user_votesOrderByWithAggregationInput>
    by: Array<User_votesScalarFieldEnum>
    having?: user_votesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_votesCountAggregateInputType | true
    _avg?: User_votesAvgAggregateInputType
    _sum?: User_votesSumAggregateInputType
    _min?: User_votesMinAggregateInputType
    _max?: User_votesMaxAggregateInputType
  }


  export type User_votesGroupByOutputType = {
    id: number
    user_id: number
    user_vote: number
    _count: User_votesCountAggregateOutputType | null
    _avg: User_votesAvgAggregateOutputType | null
    _sum: User_votesSumAggregateOutputType | null
    _min: User_votesMinAggregateOutputType | null
    _max: User_votesMaxAggregateOutputType | null
  }

  type GetUser_votesGroupByPayload<T extends User_votesGroupByArgs> = PrismaPromise<
    Array<
      PickArray<User_votesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_votesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_votesGroupByOutputType[P]>
            : GetScalarType<T[P], User_votesGroupByOutputType[P]>
        }
      >
    >


  export type user_votesSelect = {
    id?: boolean
    user_id?: boolean
    user_vote?: boolean
    users?: boolean | usersArgs
    unverified_sightings?: boolean | unverified_sightingsFindManyArgs
    _count?: boolean | User_votesCountOutputTypeArgs
  }

  export type user_votesInclude = {
    users?: boolean | usersArgs
    unverified_sightings?: boolean | unverified_sightingsFindManyArgs
    _count?: boolean | User_votesCountOutputTypeArgs
  }

  export type user_votesGetPayload<
    S extends boolean | null | undefined | user_votesArgs,
    U = keyof S
      > = S extends true
        ? user_votes
    : S extends undefined
    ? never
    : S extends user_votesArgs | user_votesFindManyArgs
    ?'include' extends U
    ? user_votes  & {
    [P in TrueKeys<S['include']>]:
        P extends 'users' ? usersGetPayload<S['include'][P]> :
        P extends 'unverified_sightings' ? Array < unverified_sightingsGetPayload<S['include'][P]>>  :
        P extends '_count' ? User_votesCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'users' ? usersGetPayload<S['select'][P]> :
        P extends 'unverified_sightings' ? Array < unverified_sightingsGetPayload<S['select'][P]>>  :
        P extends '_count' ? User_votesCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof user_votes ? user_votes[P] : never
  } 
    : user_votes
  : user_votes


  type user_votesCountArgs = Merge<
    Omit<user_votesFindManyArgs, 'select' | 'include'> & {
      select?: User_votesCountAggregateInputType | true
    }
  >

  export interface user_votesDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one User_votes that matches the filter.
     * @param {user_votesFindUniqueArgs} args - Arguments to find a User_votes
     * @example
     * // Get one User_votes
     * const user_votes = await prisma.user_votes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends user_votesFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, user_votesFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user_votes'> extends True ? CheckSelect<T, Prisma__user_votesClient<user_votes>, Prisma__user_votesClient<user_votesGetPayload<T>>> : CheckSelect<T, Prisma__user_votesClient<user_votes | null >, Prisma__user_votesClient<user_votesGetPayload<T> | null >>

    /**
     * Find the first User_votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_votesFindFirstArgs} args - Arguments to find a User_votes
     * @example
     * // Get one User_votes
     * const user_votes = await prisma.user_votes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends user_votesFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, user_votesFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user_votes'> extends True ? CheckSelect<T, Prisma__user_votesClient<user_votes>, Prisma__user_votesClient<user_votesGetPayload<T>>> : CheckSelect<T, Prisma__user_votesClient<user_votes | null >, Prisma__user_votesClient<user_votesGetPayload<T> | null >>

    /**
     * Find zero or more User_votes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_votesFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_votes
     * const user_votes = await prisma.user_votes.findMany()
     * 
     * // Get first 10 User_votes
     * const user_votes = await prisma.user_votes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_votesWithIdOnly = await prisma.user_votes.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends user_votesFindManyArgs>(
      args?: SelectSubset<T, user_votesFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<user_votes>>, PrismaPromise<Array<user_votesGetPayload<T>>>>

    /**
     * Create a User_votes.
     * @param {user_votesCreateArgs} args - Arguments to create a User_votes.
     * @example
     * // Create one User_votes
     * const User_votes = await prisma.user_votes.create({
     *   data: {
     *     // ... data to create a User_votes
     *   }
     * })
     * 
    **/
    create<T extends user_votesCreateArgs>(
      args: SelectSubset<T, user_votesCreateArgs>
    ): CheckSelect<T, Prisma__user_votesClient<user_votes>, Prisma__user_votesClient<user_votesGetPayload<T>>>

    /**
     * Create many User_votes.
     *     @param {user_votesCreateManyArgs} args - Arguments to create many User_votes.
     *     @example
     *     // Create many User_votes
     *     const user_votes = await prisma.user_votes.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends user_votesCreateManyArgs>(
      args?: SelectSubset<T, user_votesCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a User_votes.
     * @param {user_votesDeleteArgs} args - Arguments to delete one User_votes.
     * @example
     * // Delete one User_votes
     * const User_votes = await prisma.user_votes.delete({
     *   where: {
     *     // ... filter to delete one User_votes
     *   }
     * })
     * 
    **/
    delete<T extends user_votesDeleteArgs>(
      args: SelectSubset<T, user_votesDeleteArgs>
    ): CheckSelect<T, Prisma__user_votesClient<user_votes>, Prisma__user_votesClient<user_votesGetPayload<T>>>

    /**
     * Update one User_votes.
     * @param {user_votesUpdateArgs} args - Arguments to update one User_votes.
     * @example
     * // Update one User_votes
     * const user_votes = await prisma.user_votes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends user_votesUpdateArgs>(
      args: SelectSubset<T, user_votesUpdateArgs>
    ): CheckSelect<T, Prisma__user_votesClient<user_votes>, Prisma__user_votesClient<user_votesGetPayload<T>>>

    /**
     * Delete zero or more User_votes.
     * @param {user_votesDeleteManyArgs} args - Arguments to filter User_votes to delete.
     * @example
     * // Delete a few User_votes
     * const { count } = await prisma.user_votes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends user_votesDeleteManyArgs>(
      args?: SelectSubset<T, user_votesDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_votesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_votes
     * const user_votes = await prisma.user_votes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends user_votesUpdateManyArgs>(
      args: SelectSubset<T, user_votesUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one User_votes.
     * @param {user_votesUpsertArgs} args - Arguments to update or create a User_votes.
     * @example
     * // Update or create a User_votes
     * const user_votes = await prisma.user_votes.upsert({
     *   create: {
     *     // ... data to create a User_votes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_votes we want to update
     *   }
     * })
    **/
    upsert<T extends user_votesUpsertArgs>(
      args: SelectSubset<T, user_votesUpsertArgs>
    ): CheckSelect<T, Prisma__user_votesClient<user_votes>, Prisma__user_votesClient<user_votesGetPayload<T>>>

    /**
     * Find one User_votes that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {user_votesFindUniqueOrThrowArgs} args - Arguments to find a User_votes
     * @example
     * // Get one User_votes
     * const user_votes = await prisma.user_votes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends user_votesFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, user_votesFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__user_votesClient<user_votes>, Prisma__user_votesClient<user_votesGetPayload<T>>>

    /**
     * Find the first User_votes that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_votesFindFirstOrThrowArgs} args - Arguments to find a User_votes
     * @example
     * // Get one User_votes
     * const user_votes = await prisma.user_votes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends user_votesFindFirstOrThrowArgs>(
      args?: SelectSubset<T, user_votesFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__user_votesClient<user_votes>, Prisma__user_votesClient<user_votesGetPayload<T>>>

    /**
     * Count the number of User_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_votesCountArgs} args - Arguments to filter User_votes to count.
     * @example
     * // Count the number of User_votes
     * const count = await prisma.user_votes.count({
     *   where: {
     *     // ... the filter for the User_votes we want to count
     *   }
     * })
    **/
    count<T extends user_votesCountArgs>(
      args?: Subset<T, user_votesCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_votesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_votesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_votesAggregateArgs>(args: Subset<T, User_votesAggregateArgs>): PrismaPromise<GetUser_votesAggregateType<T>>

    /**
     * Group by User_votes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_votesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends User_votesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: User_votesGroupByArgs['orderBy'] }
        : { orderBy?: User_votesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, User_votesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_votesGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_votes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__user_votesClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    unverified_sightings<T extends unverified_sightingsFindManyArgs = {}>(args?: Subset<T, unverified_sightingsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<unverified_sightings>>, PrismaPromise<Array<unverified_sightingsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * user_votes base type for findUnique actions
   */
  export type user_votesFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user_votes
     * 
    **/
    select?: user_votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_votesInclude | null
    /**
     * Filter, which user_votes to fetch.
     * 
    **/
    where: user_votesWhereUniqueInput
  }

  /**
   * user_votes: findUnique
   */
  export interface user_votesFindUniqueArgs extends user_votesFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_votes base type for findFirst actions
   */
  export type user_votesFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user_votes
     * 
    **/
    select?: user_votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_votesInclude | null
    /**
     * Filter, which user_votes to fetch.
     * 
    **/
    where?: user_votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_votes to fetch.
     * 
    **/
    orderBy?: Enumerable<user_votesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_votes.
     * 
    **/
    cursor?: user_votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_votes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_votes.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_votes.
     * 
    **/
    distinct?: Enumerable<User_votesScalarFieldEnum>
  }

  /**
   * user_votes: findFirst
   */
  export interface user_votesFindFirstArgs extends user_votesFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user_votes findMany
   */
  export type user_votesFindManyArgs = {
    /**
     * Select specific fields to fetch from the user_votes
     * 
    **/
    select?: user_votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_votesInclude | null
    /**
     * Filter, which user_votes to fetch.
     * 
    **/
    where?: user_votesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_votes to fetch.
     * 
    **/
    orderBy?: Enumerable<user_votesOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_votes.
     * 
    **/
    cursor?: user_votesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_votes from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_votes.
     * 
    **/
    skip?: number
    distinct?: Enumerable<User_votesScalarFieldEnum>
  }


  /**
   * user_votes create
   */
  export type user_votesCreateArgs = {
    /**
     * Select specific fields to fetch from the user_votes
     * 
    **/
    select?: user_votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_votesInclude | null
    /**
     * The data needed to create a user_votes.
     * 
    **/
    data: XOR<user_votesCreateInput, user_votesUncheckedCreateInput>
  }


  /**
   * user_votes createMany
   */
  export type user_votesCreateManyArgs = {
    /**
     * The data used to create many user_votes.
     * 
    **/
    data: Enumerable<user_votesCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * user_votes update
   */
  export type user_votesUpdateArgs = {
    /**
     * Select specific fields to fetch from the user_votes
     * 
    **/
    select?: user_votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_votesInclude | null
    /**
     * The data needed to update a user_votes.
     * 
    **/
    data: XOR<user_votesUpdateInput, user_votesUncheckedUpdateInput>
    /**
     * Choose, which user_votes to update.
     * 
    **/
    where: user_votesWhereUniqueInput
  }


  /**
   * user_votes updateMany
   */
  export type user_votesUpdateManyArgs = {
    /**
     * The data used to update user_votes.
     * 
    **/
    data: XOR<user_votesUpdateManyMutationInput, user_votesUncheckedUpdateManyInput>
    /**
     * Filter which user_votes to update
     * 
    **/
    where?: user_votesWhereInput
  }


  /**
   * user_votes upsert
   */
  export type user_votesUpsertArgs = {
    /**
     * Select specific fields to fetch from the user_votes
     * 
    **/
    select?: user_votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_votesInclude | null
    /**
     * The filter to search for the user_votes to update in case it exists.
     * 
    **/
    where: user_votesWhereUniqueInput
    /**
     * In case the user_votes found by the `where` argument doesn't exist, create a new user_votes with this data.
     * 
    **/
    create: XOR<user_votesCreateInput, user_votesUncheckedCreateInput>
    /**
     * In case the user_votes was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<user_votesUpdateInput, user_votesUncheckedUpdateInput>
  }


  /**
   * user_votes delete
   */
  export type user_votesDeleteArgs = {
    /**
     * Select specific fields to fetch from the user_votes
     * 
    **/
    select?: user_votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_votesInclude | null
    /**
     * Filter which user_votes to delete.
     * 
    **/
    where: user_votesWhereUniqueInput
  }


  /**
   * user_votes deleteMany
   */
  export type user_votesDeleteManyArgs = {
    /**
     * Filter which user_votes to delete
     * 
    **/
    where?: user_votesWhereInput
  }


  /**
   * user_votes: findUniqueOrThrow
   */
  export type user_votesFindUniqueOrThrowArgs = user_votesFindUniqueArgsBase
      

  /**
   * user_votes: findFirstOrThrow
   */
  export type user_votesFindFirstOrThrowArgs = user_votesFindFirstArgsBase
      

  /**
   * user_votes without action
   */
  export type user_votesArgs = {
    /**
     * Select specific fields to fetch from the user_votes
     * 
    **/
    select?: user_votesSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: user_votesInclude | null
  }



  /**
   * Model users
   */


  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    user_level_id: number | null
    user_profile_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: number | null
    user_level_id: number | null
    user_profile_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: number | null
    user_name: string | null
    email_address: string | null
    user_password: string | null
    trusted_user: boolean | null
    user_level_id: number | null
    user_profile_id: number | null
  }

  export type UsersMaxAggregateOutputType = {
    id: number | null
    user_name: string | null
    email_address: string | null
    user_password: string | null
    trusted_user: boolean | null
    user_level_id: number | null
    user_profile_id: number | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    user_name: number
    email_address: number
    user_password: number
    trusted_user: number
    user_level_id: number
    user_profile_id: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    user_level_id?: true
    user_profile_id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    user_level_id?: true
    user_profile_id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    user_name?: true
    email_address?: true
    user_password?: true
    trusted_user?: true
    user_level_id?: true
    user_profile_id?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    user_name?: true
    email_address?: true
    user_password?: true
    trusted_user?: true
    user_level_id?: true
    user_profile_id?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    user_name?: true
    email_address?: true
    user_password?: true
    trusted_user?: true
    user_level_id?: true
    user_profile_id?: true
    _all?: true
  }

  export type UsersAggregateArgs = {
    /**
     * Filter which users to aggregate.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type UsersGroupByArgs = {
    where?: usersWhereInput
    orderBy?: Enumerable<usersOrderByWithAggregationInput>
    by: Array<UsersScalarFieldEnum>
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }


  export type UsersGroupByOutputType = {
    id: number
    user_name: string
    email_address: string
    user_password: string
    trusted_user: boolean | null
    user_level_id: number
    user_profile_id: number
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends UsersGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect = {
    id?: boolean
    user_name?: boolean
    email_address?: boolean
    user_password?: boolean
    trusted_user?: boolean
    user_level_id?: boolean
    user_profile_id?: boolean
    user_levels?: boolean | user_levelsArgs
    user_profiles?: boolean | user_profilesArgs
    confirmed_sightings?: boolean | confirmed_sightingsFindManyArgs
    unverified_sightings?: boolean | unverified_sightingsFindManyArgs
    user_to_reaction?: boolean | user_to_reactionFindManyArgs
    user_votes?: boolean | user_votesFindManyArgs
    users_to_groups?: boolean | users_to_groupsFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersInclude = {
    user_levels?: boolean | user_levelsArgs
    user_profiles?: boolean | user_profilesArgs
    confirmed_sightings?: boolean | confirmed_sightingsFindManyArgs
    unverified_sightings?: boolean | unverified_sightingsFindManyArgs
    user_to_reaction?: boolean | user_to_reactionFindManyArgs
    user_votes?: boolean | user_votesFindManyArgs
    users_to_groups?: boolean | users_to_groupsFindManyArgs
    _count?: boolean | UsersCountOutputTypeArgs
  }

  export type usersGetPayload<
    S extends boolean | null | undefined | usersArgs,
    U = keyof S
      > = S extends true
        ? users
    : S extends undefined
    ? never
    : S extends usersArgs | usersFindManyArgs
    ?'include' extends U
    ? users  & {
    [P in TrueKeys<S['include']>]:
        P extends 'user_levels' ? user_levelsGetPayload<S['include'][P]> :
        P extends 'user_profiles' ? user_profilesGetPayload<S['include'][P]> :
        P extends 'confirmed_sightings' ? Array < confirmed_sightingsGetPayload<S['include'][P]>>  :
        P extends 'unverified_sightings' ? Array < unverified_sightingsGetPayload<S['include'][P]>>  :
        P extends 'user_to_reaction' ? Array < user_to_reactionGetPayload<S['include'][P]>>  :
        P extends 'user_votes' ? Array < user_votesGetPayload<S['include'][P]>>  :
        P extends 'users_to_groups' ? Array < users_to_groupsGetPayload<S['include'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'user_levels' ? user_levelsGetPayload<S['select'][P]> :
        P extends 'user_profiles' ? user_profilesGetPayload<S['select'][P]> :
        P extends 'confirmed_sightings' ? Array < confirmed_sightingsGetPayload<S['select'][P]>>  :
        P extends 'unverified_sightings' ? Array < unverified_sightingsGetPayload<S['select'][P]>>  :
        P extends 'user_to_reaction' ? Array < user_to_reactionGetPayload<S['select'][P]>>  :
        P extends 'user_votes' ? Array < user_votesGetPayload<S['select'][P]>>  :
        P extends 'users_to_groups' ? Array < users_to_groupsGetPayload<S['select'][P]>>  :
        P extends '_count' ? UsersCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof users ? users[P] : never
  } 
    : users
  : users


  type usersCountArgs = Merge<
    Omit<usersFindManyArgs, 'select' | 'include'> & {
      select?: UsersCountAggregateInputType | true
    }
  >

  export interface usersDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends usersFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, usersFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends usersFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, usersFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users'> extends True ? CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>> : CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends usersFindManyArgs>(
      args?: SelectSubset<T, usersFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<users>>, PrismaPromise<Array<usersGetPayload<T>>>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
    **/
    create<T extends usersCreateArgs>(
      args: SelectSubset<T, usersCreateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Create many Users.
     *     @param {usersCreateManyArgs} args - Arguments to create many Users.
     *     @example
     *     // Create many Users
     *     const users = await prisma.users.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends usersCreateManyArgs>(
      args?: SelectSubset<T, usersCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
    **/
    delete<T extends usersDeleteArgs>(
      args: SelectSubset<T, usersDeleteArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends usersUpdateArgs>(
      args: SelectSubset<T, usersUpdateArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends usersDeleteManyArgs>(
      args?: SelectSubset<T, usersDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends usersUpdateManyArgs>(
      args: SelectSubset<T, usersUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
    **/
    upsert<T extends usersUpsertArgs>(
      args: SelectSubset<T, usersUpsertArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Find one Users that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, usersFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Find the first Users that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(
      args?: SelectSubset<T, usersFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__usersClient<users>, Prisma__usersClient<usersGetPayload<T>>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsersGroupByArgs['orderBy'] }
        : { orderBy?: UsersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__usersClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    user_levels<T extends user_levelsArgs = {}>(args?: Subset<T, user_levelsArgs>): CheckSelect<T, Prisma__user_levelsClient<user_levels | null >, Prisma__user_levelsClient<user_levelsGetPayload<T> | null >>;

    user_profiles<T extends user_profilesArgs = {}>(args?: Subset<T, user_profilesArgs>): CheckSelect<T, Prisma__user_profilesClient<user_profiles | null >, Prisma__user_profilesClient<user_profilesGetPayload<T> | null >>;

    confirmed_sightings<T extends confirmed_sightingsFindManyArgs = {}>(args?: Subset<T, confirmed_sightingsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<confirmed_sightings>>, PrismaPromise<Array<confirmed_sightingsGetPayload<T>>>>;

    unverified_sightings<T extends unverified_sightingsFindManyArgs = {}>(args?: Subset<T, unverified_sightingsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<unverified_sightings>>, PrismaPromise<Array<unverified_sightingsGetPayload<T>>>>;

    user_to_reaction<T extends user_to_reactionFindManyArgs = {}>(args?: Subset<T, user_to_reactionFindManyArgs>): CheckSelect<T, PrismaPromise<Array<user_to_reaction>>, PrismaPromise<Array<user_to_reactionGetPayload<T>>>>;

    user_votes<T extends user_votesFindManyArgs = {}>(args?: Subset<T, user_votesFindManyArgs>): CheckSelect<T, PrismaPromise<Array<user_votes>>, PrismaPromise<Array<user_votesGetPayload<T>>>>;

    users_to_groups<T extends users_to_groupsFindManyArgs = {}>(args?: Subset<T, users_to_groupsFindManyArgs>): CheckSelect<T, PrismaPromise<Array<users_to_groups>>, PrismaPromise<Array<users_to_groupsGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * users base type for findUnique actions
   */
  export type usersFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where: usersWhereUniqueInput
  }

  /**
   * users: findUnique
   */
  export interface usersFindUniqueArgs extends usersFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users base type for findFirst actions
   */
  export type usersFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     * 
    **/
    distinct?: Enumerable<UsersScalarFieldEnum>
  }

  /**
   * users: findFirst
   */
  export interface usersFindFirstArgs extends usersFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users findMany
   */
  export type usersFindManyArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter, which users to fetch.
     * 
    **/
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     * 
    **/
    orderBy?: Enumerable<usersOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     * 
    **/
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UsersScalarFieldEnum>
  }


  /**
   * users create
   */
  export type usersCreateArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The data needed to create a users.
     * 
    **/
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }


  /**
   * users createMany
   */
  export type usersCreateManyArgs = {
    /**
     * The data used to create many users.
     * 
    **/
    data: Enumerable<usersCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users update
   */
  export type usersUpdateArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The data needed to update a users.
     * 
    **/
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users updateMany
   */
  export type usersUpdateManyArgs = {
    /**
     * The data used to update users.
     * 
    **/
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     * 
    **/
    where?: usersWhereInput
  }


  /**
   * users upsert
   */
  export type usersUpsertArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * The filter to search for the users to update in case it exists.
     * 
    **/
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     * 
    **/
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }


  /**
   * users delete
   */
  export type usersDeleteArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
    /**
     * Filter which users to delete.
     * 
    **/
    where: usersWhereUniqueInput
  }


  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs = {
    /**
     * Filter which users to delete
     * 
    **/
    where?: usersWhereInput
  }


  /**
   * users: findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs = usersFindUniqueArgsBase
      

  /**
   * users: findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs = usersFindFirstArgsBase
      

  /**
   * users without action
   */
  export type usersArgs = {
    /**
     * Select specific fields to fetch from the users
     * 
    **/
    select?: usersSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: usersInclude | null
  }



  /**
   * Model users_to_groups
   */


  export type AggregateUsers_to_groups = {
    _count: Users_to_groupsCountAggregateOutputType | null
    _avg: Users_to_groupsAvgAggregateOutputType | null
    _sum: Users_to_groupsSumAggregateOutputType | null
    _min: Users_to_groupsMinAggregateOutputType | null
    _max: Users_to_groupsMaxAggregateOutputType | null
  }

  export type Users_to_groupsAvgAggregateOutputType = {
    id: number | null
    group_id: number | null
    user_id: number | null
  }

  export type Users_to_groupsSumAggregateOutputType = {
    id: number | null
    group_id: number | null
    user_id: number | null
  }

  export type Users_to_groupsMinAggregateOutputType = {
    id: number | null
    group_id: number | null
    user_id: number | null
  }

  export type Users_to_groupsMaxAggregateOutputType = {
    id: number | null
    group_id: number | null
    user_id: number | null
  }

  export type Users_to_groupsCountAggregateOutputType = {
    id: number
    group_id: number
    user_id: number
    _all: number
  }


  export type Users_to_groupsAvgAggregateInputType = {
    id?: true
    group_id?: true
    user_id?: true
  }

  export type Users_to_groupsSumAggregateInputType = {
    id?: true
    group_id?: true
    user_id?: true
  }

  export type Users_to_groupsMinAggregateInputType = {
    id?: true
    group_id?: true
    user_id?: true
  }

  export type Users_to_groupsMaxAggregateInputType = {
    id?: true
    group_id?: true
    user_id?: true
  }

  export type Users_to_groupsCountAggregateInputType = {
    id?: true
    group_id?: true
    user_id?: true
    _all?: true
  }

  export type Users_to_groupsAggregateArgs = {
    /**
     * Filter which users_to_groups to aggregate.
     * 
    **/
    where?: users_to_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_to_groups to fetch.
     * 
    **/
    orderBy?: Enumerable<users_to_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: users_to_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_to_groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_to_groups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users_to_groups
    **/
    _count?: true | Users_to_groupsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Users_to_groupsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Users_to_groupsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Users_to_groupsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Users_to_groupsMaxAggregateInputType
  }

  export type GetUsers_to_groupsAggregateType<T extends Users_to_groupsAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers_to_groups]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers_to_groups[P]>
      : GetScalarType<T[P], AggregateUsers_to_groups[P]>
  }




  export type Users_to_groupsGroupByArgs = {
    where?: users_to_groupsWhereInput
    orderBy?: Enumerable<users_to_groupsOrderByWithAggregationInput>
    by: Array<Users_to_groupsScalarFieldEnum>
    having?: users_to_groupsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Users_to_groupsCountAggregateInputType | true
    _avg?: Users_to_groupsAvgAggregateInputType
    _sum?: Users_to_groupsSumAggregateInputType
    _min?: Users_to_groupsMinAggregateInputType
    _max?: Users_to_groupsMaxAggregateInputType
  }


  export type Users_to_groupsGroupByOutputType = {
    id: number
    group_id: number
    user_id: number
    _count: Users_to_groupsCountAggregateOutputType | null
    _avg: Users_to_groupsAvgAggregateOutputType | null
    _sum: Users_to_groupsSumAggregateOutputType | null
    _min: Users_to_groupsMinAggregateOutputType | null
    _max: Users_to_groupsMaxAggregateOutputType | null
  }

  type GetUsers_to_groupsGroupByPayload<T extends Users_to_groupsGroupByArgs> = PrismaPromise<
    Array<
      PickArray<Users_to_groupsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Users_to_groupsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Users_to_groupsGroupByOutputType[P]>
            : GetScalarType<T[P], Users_to_groupsGroupByOutputType[P]>
        }
      >
    >


  export type users_to_groupsSelect = {
    id?: boolean
    group_id?: boolean
    user_id?: boolean
    interest_groups?: boolean | interest_groupsArgs
    users?: boolean | usersArgs
  }

  export type users_to_groupsInclude = {
    interest_groups?: boolean | interest_groupsArgs
    users?: boolean | usersArgs
  }

  export type users_to_groupsGetPayload<
    S extends boolean | null | undefined | users_to_groupsArgs,
    U = keyof S
      > = S extends true
        ? users_to_groups
    : S extends undefined
    ? never
    : S extends users_to_groupsArgs | users_to_groupsFindManyArgs
    ?'include' extends U
    ? users_to_groups  & {
    [P in TrueKeys<S['include']>]:
        P extends 'interest_groups' ? interest_groupsGetPayload<S['include'][P]> :
        P extends 'users' ? usersGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'interest_groups' ? interest_groupsGetPayload<S['select'][P]> :
        P extends 'users' ? usersGetPayload<S['select'][P]> :  P extends keyof users_to_groups ? users_to_groups[P] : never
  } 
    : users_to_groups
  : users_to_groups


  type users_to_groupsCountArgs = Merge<
    Omit<users_to_groupsFindManyArgs, 'select' | 'include'> & {
      select?: Users_to_groupsCountAggregateInputType | true
    }
  >

  export interface users_to_groupsDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Users_to_groups that matches the filter.
     * @param {users_to_groupsFindUniqueArgs} args - Arguments to find a Users_to_groups
     * @example
     * // Get one Users_to_groups
     * const users_to_groups = await prisma.users_to_groups.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends users_to_groupsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, users_to_groupsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'users_to_groups'> extends True ? CheckSelect<T, Prisma__users_to_groupsClient<users_to_groups>, Prisma__users_to_groupsClient<users_to_groupsGetPayload<T>>> : CheckSelect<T, Prisma__users_to_groupsClient<users_to_groups | null >, Prisma__users_to_groupsClient<users_to_groupsGetPayload<T> | null >>

    /**
     * Find the first Users_to_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_to_groupsFindFirstArgs} args - Arguments to find a Users_to_groups
     * @example
     * // Get one Users_to_groups
     * const users_to_groups = await prisma.users_to_groups.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends users_to_groupsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, users_to_groupsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'users_to_groups'> extends True ? CheckSelect<T, Prisma__users_to_groupsClient<users_to_groups>, Prisma__users_to_groupsClient<users_to_groupsGetPayload<T>>> : CheckSelect<T, Prisma__users_to_groupsClient<users_to_groups | null >, Prisma__users_to_groupsClient<users_to_groupsGetPayload<T> | null >>

    /**
     * Find zero or more Users_to_groups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_to_groupsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users_to_groups
     * const users_to_groups = await prisma.users_to_groups.findMany()
     * 
     * // Get first 10 Users_to_groups
     * const users_to_groups = await prisma.users_to_groups.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const users_to_groupsWithIdOnly = await prisma.users_to_groups.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends users_to_groupsFindManyArgs>(
      args?: SelectSubset<T, users_to_groupsFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<users_to_groups>>, PrismaPromise<Array<users_to_groupsGetPayload<T>>>>

    /**
     * Create a Users_to_groups.
     * @param {users_to_groupsCreateArgs} args - Arguments to create a Users_to_groups.
     * @example
     * // Create one Users_to_groups
     * const Users_to_groups = await prisma.users_to_groups.create({
     *   data: {
     *     // ... data to create a Users_to_groups
     *   }
     * })
     * 
    **/
    create<T extends users_to_groupsCreateArgs>(
      args: SelectSubset<T, users_to_groupsCreateArgs>
    ): CheckSelect<T, Prisma__users_to_groupsClient<users_to_groups>, Prisma__users_to_groupsClient<users_to_groupsGetPayload<T>>>

    /**
     * Create many Users_to_groups.
     *     @param {users_to_groupsCreateManyArgs} args - Arguments to create many Users_to_groups.
     *     @example
     *     // Create many Users_to_groups
     *     const users_to_groups = await prisma.users_to_groups.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends users_to_groupsCreateManyArgs>(
      args?: SelectSubset<T, users_to_groupsCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Users_to_groups.
     * @param {users_to_groupsDeleteArgs} args - Arguments to delete one Users_to_groups.
     * @example
     * // Delete one Users_to_groups
     * const Users_to_groups = await prisma.users_to_groups.delete({
     *   where: {
     *     // ... filter to delete one Users_to_groups
     *   }
     * })
     * 
    **/
    delete<T extends users_to_groupsDeleteArgs>(
      args: SelectSubset<T, users_to_groupsDeleteArgs>
    ): CheckSelect<T, Prisma__users_to_groupsClient<users_to_groups>, Prisma__users_to_groupsClient<users_to_groupsGetPayload<T>>>

    /**
     * Update one Users_to_groups.
     * @param {users_to_groupsUpdateArgs} args - Arguments to update one Users_to_groups.
     * @example
     * // Update one Users_to_groups
     * const users_to_groups = await prisma.users_to_groups.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends users_to_groupsUpdateArgs>(
      args: SelectSubset<T, users_to_groupsUpdateArgs>
    ): CheckSelect<T, Prisma__users_to_groupsClient<users_to_groups>, Prisma__users_to_groupsClient<users_to_groupsGetPayload<T>>>

    /**
     * Delete zero or more Users_to_groups.
     * @param {users_to_groupsDeleteManyArgs} args - Arguments to filter Users_to_groups to delete.
     * @example
     * // Delete a few Users_to_groups
     * const { count } = await prisma.users_to_groups.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends users_to_groupsDeleteManyArgs>(
      args?: SelectSubset<T, users_to_groupsDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users_to_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_to_groupsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users_to_groups
     * const users_to_groups = await prisma.users_to_groups.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends users_to_groupsUpdateManyArgs>(
      args: SelectSubset<T, users_to_groupsUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Users_to_groups.
     * @param {users_to_groupsUpsertArgs} args - Arguments to update or create a Users_to_groups.
     * @example
     * // Update or create a Users_to_groups
     * const users_to_groups = await prisma.users_to_groups.upsert({
     *   create: {
     *     // ... data to create a Users_to_groups
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users_to_groups we want to update
     *   }
     * })
    **/
    upsert<T extends users_to_groupsUpsertArgs>(
      args: SelectSubset<T, users_to_groupsUpsertArgs>
    ): CheckSelect<T, Prisma__users_to_groupsClient<users_to_groups>, Prisma__users_to_groupsClient<users_to_groupsGetPayload<T>>>

    /**
     * Find one Users_to_groups that matches the filter or throw
     * `NotFoundError` if no matches were found.
     * @param {users_to_groupsFindUniqueOrThrowArgs} args - Arguments to find a Users_to_groups
     * @example
     * // Get one Users_to_groups
     * const users_to_groups = await prisma.users_to_groups.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends users_to_groupsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, users_to_groupsFindUniqueOrThrowArgs>
    ): CheckSelect<T, Prisma__users_to_groupsClient<users_to_groups>, Prisma__users_to_groupsClient<users_to_groupsGetPayload<T>>>

    /**
     * Find the first Users_to_groups that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_to_groupsFindFirstOrThrowArgs} args - Arguments to find a Users_to_groups
     * @example
     * // Get one Users_to_groups
     * const users_to_groups = await prisma.users_to_groups.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends users_to_groupsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, users_to_groupsFindFirstOrThrowArgs>
    ): CheckSelect<T, Prisma__users_to_groupsClient<users_to_groups>, Prisma__users_to_groupsClient<users_to_groupsGetPayload<T>>>

    /**
     * Count the number of Users_to_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {users_to_groupsCountArgs} args - Arguments to filter Users_to_groups to count.
     * @example
     * // Count the number of Users_to_groups
     * const count = await prisma.users_to_groups.count({
     *   where: {
     *     // ... the filter for the Users_to_groups we want to count
     *   }
     * })
    **/
    count<T extends users_to_groupsCountArgs>(
      args?: Subset<T, users_to_groupsCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Users_to_groupsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users_to_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_to_groupsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Users_to_groupsAggregateArgs>(args: Subset<T, Users_to_groupsAggregateArgs>): PrismaPromise<GetUsers_to_groupsAggregateType<T>>

    /**
     * Group by Users_to_groups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Users_to_groupsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Users_to_groupsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Users_to_groupsGroupByArgs['orderBy'] }
        : { orderBy?: Users_to_groupsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Users_to_groupsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsers_to_groupsGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for users_to_groups.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__users_to_groupsClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    interest_groups<T extends interest_groupsArgs = {}>(args?: Subset<T, interest_groupsArgs>): CheckSelect<T, Prisma__interest_groupsClient<interest_groups | null >, Prisma__interest_groupsClient<interest_groupsGetPayload<T> | null >>;

    users<T extends usersArgs = {}>(args?: Subset<T, usersArgs>): CheckSelect<T, Prisma__usersClient<users | null >, Prisma__usersClient<usersGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * users_to_groups base type for findUnique actions
   */
  export type users_to_groupsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the users_to_groups
     * 
    **/
    select?: users_to_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_to_groupsInclude | null
    /**
     * Filter, which users_to_groups to fetch.
     * 
    **/
    where: users_to_groupsWhereUniqueInput
  }

  /**
   * users_to_groups: findUnique
   */
  export interface users_to_groupsFindUniqueArgs extends users_to_groupsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users_to_groups base type for findFirst actions
   */
  export type users_to_groupsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the users_to_groups
     * 
    **/
    select?: users_to_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_to_groupsInclude | null
    /**
     * Filter, which users_to_groups to fetch.
     * 
    **/
    where?: users_to_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_to_groups to fetch.
     * 
    **/
    orderBy?: Enumerable<users_to_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users_to_groups.
     * 
    **/
    cursor?: users_to_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_to_groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_to_groups.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users_to_groups.
     * 
    **/
    distinct?: Enumerable<Users_to_groupsScalarFieldEnum>
  }

  /**
   * users_to_groups: findFirst
   */
  export interface users_to_groupsFindFirstArgs extends users_to_groupsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * users_to_groups findMany
   */
  export type users_to_groupsFindManyArgs = {
    /**
     * Select specific fields to fetch from the users_to_groups
     * 
    **/
    select?: users_to_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_to_groupsInclude | null
    /**
     * Filter, which users_to_groups to fetch.
     * 
    **/
    where?: users_to_groupsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users_to_groups to fetch.
     * 
    **/
    orderBy?: Enumerable<users_to_groupsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users_to_groups.
     * 
    **/
    cursor?: users_to_groupsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users_to_groups from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users_to_groups.
     * 
    **/
    skip?: number
    distinct?: Enumerable<Users_to_groupsScalarFieldEnum>
  }


  /**
   * users_to_groups create
   */
  export type users_to_groupsCreateArgs = {
    /**
     * Select specific fields to fetch from the users_to_groups
     * 
    **/
    select?: users_to_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_to_groupsInclude | null
    /**
     * The data needed to create a users_to_groups.
     * 
    **/
    data: XOR<users_to_groupsCreateInput, users_to_groupsUncheckedCreateInput>
  }


  /**
   * users_to_groups createMany
   */
  export type users_to_groupsCreateManyArgs = {
    /**
     * The data used to create many users_to_groups.
     * 
    **/
    data: Enumerable<users_to_groupsCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * users_to_groups update
   */
  export type users_to_groupsUpdateArgs = {
    /**
     * Select specific fields to fetch from the users_to_groups
     * 
    **/
    select?: users_to_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_to_groupsInclude | null
    /**
     * The data needed to update a users_to_groups.
     * 
    **/
    data: XOR<users_to_groupsUpdateInput, users_to_groupsUncheckedUpdateInput>
    /**
     * Choose, which users_to_groups to update.
     * 
    **/
    where: users_to_groupsWhereUniqueInput
  }


  /**
   * users_to_groups updateMany
   */
  export type users_to_groupsUpdateManyArgs = {
    /**
     * The data used to update users_to_groups.
     * 
    **/
    data: XOR<users_to_groupsUpdateManyMutationInput, users_to_groupsUncheckedUpdateManyInput>
    /**
     * Filter which users_to_groups to update
     * 
    **/
    where?: users_to_groupsWhereInput
  }


  /**
   * users_to_groups upsert
   */
  export type users_to_groupsUpsertArgs = {
    /**
     * Select specific fields to fetch from the users_to_groups
     * 
    **/
    select?: users_to_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_to_groupsInclude | null
    /**
     * The filter to search for the users_to_groups to update in case it exists.
     * 
    **/
    where: users_to_groupsWhereUniqueInput
    /**
     * In case the users_to_groups found by the `where` argument doesn't exist, create a new users_to_groups with this data.
     * 
    **/
    create: XOR<users_to_groupsCreateInput, users_to_groupsUncheckedCreateInput>
    /**
     * In case the users_to_groups was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<users_to_groupsUpdateInput, users_to_groupsUncheckedUpdateInput>
  }


  /**
   * users_to_groups delete
   */
  export type users_to_groupsDeleteArgs = {
    /**
     * Select specific fields to fetch from the users_to_groups
     * 
    **/
    select?: users_to_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_to_groupsInclude | null
    /**
     * Filter which users_to_groups to delete.
     * 
    **/
    where: users_to_groupsWhereUniqueInput
  }


  /**
   * users_to_groups deleteMany
   */
  export type users_to_groupsDeleteManyArgs = {
    /**
     * Filter which users_to_groups to delete
     * 
    **/
    where?: users_to_groupsWhereInput
  }


  /**
   * users_to_groups: findUniqueOrThrow
   */
  export type users_to_groupsFindUniqueOrThrowArgs = users_to_groupsFindUniqueArgsBase
      

  /**
   * users_to_groups: findFirstOrThrow
   */
  export type users_to_groupsFindFirstOrThrowArgs = users_to_groupsFindFirstArgsBase
      

  /**
   * users_to_groups without action
   */
  export type users_to_groupsArgs = {
    /**
     * Select specific fields to fetch from the users_to_groups
     * 
    **/
    select?: users_to_groupsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: users_to_groupsInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const Confirmed_sightingsScalarFieldEnum: {
    id: 'id',
    organism_id: 'organism_id',
    user_id: 'user_id',
    picture_url: 'picture_url',
    date: 'date',
    lat: 'lat',
    long: 'long'
  };

  export type Confirmed_sightingsScalarFieldEnum = (typeof Confirmed_sightingsScalarFieldEnum)[keyof typeof Confirmed_sightingsScalarFieldEnum]


  export const Flyway_schema_historyScalarFieldEnum: {
    installed_rank: 'installed_rank',
    version: 'version',
    description: 'description',
    type: 'type',
    script: 'script',
    checksum: 'checksum',
    installed_by: 'installed_by',
    installed_on: 'installed_on',
    execution_time: 'execution_time',
    success: 'success'
  };

  export type Flyway_schema_historyScalarFieldEnum = (typeof Flyway_schema_historyScalarFieldEnum)[keyof typeof Flyway_schema_historyScalarFieldEnum]


  export const Interest_groupsScalarFieldEnum: {
    id: 'id',
    group_name: 'group_name',
    description: 'description'
  };

  export type Interest_groupsScalarFieldEnum = (typeof Interest_groupsScalarFieldEnum)[keyof typeof Interest_groupsScalarFieldEnum]


  export const OrganismsScalarFieldEnum: {
    id: 'id',
    taxon_name: 'taxon_name',
    latin_name: 'latin_name',
    taxon_group_id: 'taxon_group_id',
    picture_url: 'picture_url',
    description: 'description'
  };

  export type OrganismsScalarFieldEnum = (typeof OrganismsScalarFieldEnum)[keyof typeof OrganismsScalarFieldEnum]


  export const ReactionsScalarFieldEnum: {
    id: 'id',
    reaction_name: 'reaction_name'
  };

  export type ReactionsScalarFieldEnum = (typeof ReactionsScalarFieldEnum)[keyof typeof ReactionsScalarFieldEnum]


  export const Taxon_groupsScalarFieldEnum: {
    id: 'id',
    taxon_group_name: 'taxon_group_name',
    description: 'description'
  };

  export type Taxon_groupsScalarFieldEnum = (typeof Taxon_groupsScalarFieldEnum)[keyof typeof Taxon_groupsScalarFieldEnum]


  export const Unverified_sightingsScalarFieldEnum: {
    id: 'id',
    organism_id: 'organism_id',
    user_id: 'user_id',
    picture_url: 'picture_url',
    date: 'date',
    lat: 'lat',
    long: 'long',
    user_vote_id: 'user_vote_id',
    reaction_id: 'reaction_id'
  };

  export type Unverified_sightingsScalarFieldEnum = (typeof Unverified_sightingsScalarFieldEnum)[keyof typeof Unverified_sightingsScalarFieldEnum]


  export const User_levelsScalarFieldEnum: {
    id: 'id',
    description: 'description'
  };

  export type User_levelsScalarFieldEnum = (typeof User_levelsScalarFieldEnum)[keyof typeof User_levelsScalarFieldEnum]


  export const User_profilesScalarFieldEnum: {
    id: 'id',
    profile_message: 'profile_message',
    profile_picture: 'profile_picture'
  };

  export type User_profilesScalarFieldEnum = (typeof User_profilesScalarFieldEnum)[keyof typeof User_profilesScalarFieldEnum]


  export const User_to_reactionScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    reaction_id: 'reaction_id'
  };

  export type User_to_reactionScalarFieldEnum = (typeof User_to_reactionScalarFieldEnum)[keyof typeof User_to_reactionScalarFieldEnum]


  export const User_votesScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    user_vote: 'user_vote'
  };

  export type User_votesScalarFieldEnum = (typeof User_votesScalarFieldEnum)[keyof typeof User_votesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    user_name: 'user_name',
    email_address: 'email_address',
    user_password: 'user_password',
    trusted_user: 'trusted_user',
    user_level_id: 'user_level_id',
    user_profile_id: 'user_profile_id'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const Users_to_groupsScalarFieldEnum: {
    id: 'id',
    group_id: 'group_id',
    user_id: 'user_id'
  };

  export type Users_to_groupsScalarFieldEnum = (typeof Users_to_groupsScalarFieldEnum)[keyof typeof Users_to_groupsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Deep Input Types
   */


  export type confirmed_sightingsWhereInput = {
    AND?: Enumerable<confirmed_sightingsWhereInput>
    OR?: Enumerable<confirmed_sightingsWhereInput>
    NOT?: Enumerable<confirmed_sightingsWhereInput>
    id?: IntFilter | number
    organism_id?: IntFilter | number
    user_id?: IntFilter | number
    picture_url?: StringFilter | string
    date?: DateTimeFilter | Date | string
    lat?: DecimalFilter | Decimal | DecimalJsLike | number | string
    long?: DecimalFilter | Decimal | DecimalJsLike | number | string
    organisms?: XOR<OrganismsRelationFilter, organismsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type confirmed_sightingsOrderByWithRelationInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    picture_url?: SortOrder
    date?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    organisms?: organismsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type confirmed_sightingsWhereUniqueInput = {
    id?: number
  }

  export type confirmed_sightingsOrderByWithAggregationInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    picture_url?: SortOrder
    date?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    _count?: confirmed_sightingsCountOrderByAggregateInput
    _avg?: confirmed_sightingsAvgOrderByAggregateInput
    _max?: confirmed_sightingsMaxOrderByAggregateInput
    _min?: confirmed_sightingsMinOrderByAggregateInput
    _sum?: confirmed_sightingsSumOrderByAggregateInput
  }

  export type confirmed_sightingsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<confirmed_sightingsScalarWhereWithAggregatesInput>
    OR?: Enumerable<confirmed_sightingsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<confirmed_sightingsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    organism_id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    picture_url?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    lat?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    long?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
  }

  export type flyway_schema_historyWhereInput = {
    AND?: Enumerable<flyway_schema_historyWhereInput>
    OR?: Enumerable<flyway_schema_historyWhereInput>
    NOT?: Enumerable<flyway_schema_historyWhereInput>
    installed_rank?: IntFilter | number
    version?: StringNullableFilter | string | null
    description?: StringFilter | string
    type?: StringFilter | string
    script?: StringFilter | string
    checksum?: IntNullableFilter | number | null
    installed_by?: StringFilter | string
    installed_on?: DateTimeFilter | Date | string
    execution_time?: IntFilter | number
    success?: BoolFilter | boolean
  }

  export type flyway_schema_historyOrderByWithRelationInput = {
    installed_rank?: SortOrder
    version?: SortOrder
    description?: SortOrder
    type?: SortOrder
    script?: SortOrder
    checksum?: SortOrder
    installed_by?: SortOrder
    installed_on?: SortOrder
    execution_time?: SortOrder
    success?: SortOrder
  }

  export type flyway_schema_historyWhereUniqueInput = {
    installed_rank?: number
  }

  export type flyway_schema_historyOrderByWithAggregationInput = {
    installed_rank?: SortOrder
    version?: SortOrder
    description?: SortOrder
    type?: SortOrder
    script?: SortOrder
    checksum?: SortOrder
    installed_by?: SortOrder
    installed_on?: SortOrder
    execution_time?: SortOrder
    success?: SortOrder
    _count?: flyway_schema_historyCountOrderByAggregateInput
    _avg?: flyway_schema_historyAvgOrderByAggregateInput
    _max?: flyway_schema_historyMaxOrderByAggregateInput
    _min?: flyway_schema_historyMinOrderByAggregateInput
    _sum?: flyway_schema_historySumOrderByAggregateInput
  }

  export type flyway_schema_historyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<flyway_schema_historyScalarWhereWithAggregatesInput>
    OR?: Enumerable<flyway_schema_historyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<flyway_schema_historyScalarWhereWithAggregatesInput>
    installed_rank?: IntWithAggregatesFilter | number
    version?: StringNullableWithAggregatesFilter | string | null
    description?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    script?: StringWithAggregatesFilter | string
    checksum?: IntNullableWithAggregatesFilter | number | null
    installed_by?: StringWithAggregatesFilter | string
    installed_on?: DateTimeWithAggregatesFilter | Date | string
    execution_time?: IntWithAggregatesFilter | number
    success?: BoolWithAggregatesFilter | boolean
  }

  export type interest_groupsWhereInput = {
    AND?: Enumerable<interest_groupsWhereInput>
    OR?: Enumerable<interest_groupsWhereInput>
    NOT?: Enumerable<interest_groupsWhereInput>
    id?: IntFilter | number
    group_name?: StringFilter | string
    description?: StringNullableFilter | string | null
    users_to_groups?: Users_to_groupsListRelationFilter
  }

  export type interest_groupsOrderByWithRelationInput = {
    id?: SortOrder
    group_name?: SortOrder
    description?: SortOrder
    users_to_groups?: users_to_groupsOrderByRelationAggregateInput
  }

  export type interest_groupsWhereUniqueInput = {
    id?: number
  }

  export type interest_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    group_name?: SortOrder
    description?: SortOrder
    _count?: interest_groupsCountOrderByAggregateInput
    _avg?: interest_groupsAvgOrderByAggregateInput
    _max?: interest_groupsMaxOrderByAggregateInput
    _min?: interest_groupsMinOrderByAggregateInput
    _sum?: interest_groupsSumOrderByAggregateInput
  }

  export type interest_groupsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<interest_groupsScalarWhereWithAggregatesInput>
    OR?: Enumerable<interest_groupsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<interest_groupsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    group_name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type organismsWhereInput = {
    AND?: Enumerable<organismsWhereInput>
    OR?: Enumerable<organismsWhereInput>
    NOT?: Enumerable<organismsWhereInput>
    id?: IntFilter | number
    taxon_name?: StringFilter | string
    latin_name?: StringFilter | string
    taxon_group_id?: IntFilter | number
    picture_url?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
    taxon_groups?: XOR<Taxon_groupsRelationFilter, taxon_groupsWhereInput>
    confirmed_sightings?: Confirmed_sightingsListRelationFilter
    unverified_sightings?: Unverified_sightingsListRelationFilter
  }

  export type organismsOrderByWithRelationInput = {
    id?: SortOrder
    taxon_name?: SortOrder
    latin_name?: SortOrder
    taxon_group_id?: SortOrder
    picture_url?: SortOrder
    description?: SortOrder
    taxon_groups?: taxon_groupsOrderByWithRelationInput
    confirmed_sightings?: confirmed_sightingsOrderByRelationAggregateInput
    unverified_sightings?: unverified_sightingsOrderByRelationAggregateInput
  }

  export type organismsWhereUniqueInput = {
    id?: number
  }

  export type organismsOrderByWithAggregationInput = {
    id?: SortOrder
    taxon_name?: SortOrder
    latin_name?: SortOrder
    taxon_group_id?: SortOrder
    picture_url?: SortOrder
    description?: SortOrder
    _count?: organismsCountOrderByAggregateInput
    _avg?: organismsAvgOrderByAggregateInput
    _max?: organismsMaxOrderByAggregateInput
    _min?: organismsMinOrderByAggregateInput
    _sum?: organismsSumOrderByAggregateInput
  }

  export type organismsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<organismsScalarWhereWithAggregatesInput>
    OR?: Enumerable<organismsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<organismsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    taxon_name?: StringWithAggregatesFilter | string
    latin_name?: StringWithAggregatesFilter | string
    taxon_group_id?: IntWithAggregatesFilter | number
    picture_url?: StringNullableWithAggregatesFilter | string | null
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type reactionsWhereInput = {
    AND?: Enumerable<reactionsWhereInput>
    OR?: Enumerable<reactionsWhereInput>
    NOT?: Enumerable<reactionsWhereInput>
    id?: IntFilter | number
    reaction_name?: StringFilter | string
    unverified_sightings?: Unverified_sightingsListRelationFilter
    user_to_reaction?: User_to_reactionListRelationFilter
  }

  export type reactionsOrderByWithRelationInput = {
    id?: SortOrder
    reaction_name?: SortOrder
    unverified_sightings?: unverified_sightingsOrderByRelationAggregateInput
    user_to_reaction?: user_to_reactionOrderByRelationAggregateInput
  }

  export type reactionsWhereUniqueInput = {
    id?: number
  }

  export type reactionsOrderByWithAggregationInput = {
    id?: SortOrder
    reaction_name?: SortOrder
    _count?: reactionsCountOrderByAggregateInput
    _avg?: reactionsAvgOrderByAggregateInput
    _max?: reactionsMaxOrderByAggregateInput
    _min?: reactionsMinOrderByAggregateInput
    _sum?: reactionsSumOrderByAggregateInput
  }

  export type reactionsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reactionsScalarWhereWithAggregatesInput>
    OR?: Enumerable<reactionsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reactionsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    reaction_name?: StringWithAggregatesFilter | string
  }

  export type taxon_groupsWhereInput = {
    AND?: Enumerable<taxon_groupsWhereInput>
    OR?: Enumerable<taxon_groupsWhereInput>
    NOT?: Enumerable<taxon_groupsWhereInput>
    id?: IntFilter | number
    taxon_group_name?: StringFilter | string
    description?: StringNullableFilter | string | null
    organisms?: OrganismsListRelationFilter
  }

  export type taxon_groupsOrderByWithRelationInput = {
    id?: SortOrder
    taxon_group_name?: SortOrder
    description?: SortOrder
    organisms?: organismsOrderByRelationAggregateInput
  }

  export type taxon_groupsWhereUniqueInput = {
    id?: number
  }

  export type taxon_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    taxon_group_name?: SortOrder
    description?: SortOrder
    _count?: taxon_groupsCountOrderByAggregateInput
    _avg?: taxon_groupsAvgOrderByAggregateInput
    _max?: taxon_groupsMaxOrderByAggregateInput
    _min?: taxon_groupsMinOrderByAggregateInput
    _sum?: taxon_groupsSumOrderByAggregateInput
  }

  export type taxon_groupsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<taxon_groupsScalarWhereWithAggregatesInput>
    OR?: Enumerable<taxon_groupsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<taxon_groupsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    taxon_group_name?: StringWithAggregatesFilter | string
    description?: StringNullableWithAggregatesFilter | string | null
  }

  export type unverified_sightingsWhereInput = {
    AND?: Enumerable<unverified_sightingsWhereInput>
    OR?: Enumerable<unverified_sightingsWhereInput>
    NOT?: Enumerable<unverified_sightingsWhereInput>
    id?: IntFilter | number
    organism_id?: IntFilter | number
    user_id?: IntFilter | number
    picture_url?: StringFilter | string
    date?: DateTimeFilter | Date | string
    lat?: DecimalFilter | Decimal | DecimalJsLike | number | string
    long?: DecimalFilter | Decimal | DecimalJsLike | number | string
    user_vote_id?: IntNullableFilter | number | null
    reaction_id?: IntNullableFilter | number | null
    organisms?: XOR<OrganismsRelationFilter, organismsWhereInput>
    reactions?: XOR<ReactionsRelationFilter, reactionsWhereInput> | null
    users?: XOR<UsersRelationFilter, usersWhereInput>
    user_votes?: XOR<User_votesRelationFilter, user_votesWhereInput> | null
  }

  export type unverified_sightingsOrderByWithRelationInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    picture_url?: SortOrder
    date?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    user_vote_id?: SortOrder
    reaction_id?: SortOrder
    organisms?: organismsOrderByWithRelationInput
    reactions?: reactionsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    user_votes?: user_votesOrderByWithRelationInput
  }

  export type unverified_sightingsWhereUniqueInput = {
    id?: number
  }

  export type unverified_sightingsOrderByWithAggregationInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    picture_url?: SortOrder
    date?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    user_vote_id?: SortOrder
    reaction_id?: SortOrder
    _count?: unverified_sightingsCountOrderByAggregateInput
    _avg?: unverified_sightingsAvgOrderByAggregateInput
    _max?: unverified_sightingsMaxOrderByAggregateInput
    _min?: unverified_sightingsMinOrderByAggregateInput
    _sum?: unverified_sightingsSumOrderByAggregateInput
  }

  export type unverified_sightingsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<unverified_sightingsScalarWhereWithAggregatesInput>
    OR?: Enumerable<unverified_sightingsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<unverified_sightingsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    organism_id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    picture_url?: StringWithAggregatesFilter | string
    date?: DateTimeWithAggregatesFilter | Date | string
    lat?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    long?: DecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    user_vote_id?: IntNullableWithAggregatesFilter | number | null
    reaction_id?: IntNullableWithAggregatesFilter | number | null
  }

  export type user_levelsWhereInput = {
    AND?: Enumerable<user_levelsWhereInput>
    OR?: Enumerable<user_levelsWhereInput>
    NOT?: Enumerable<user_levelsWhereInput>
    id?: IntFilter | number
    description?: StringFilter | string
    users?: UsersListRelationFilter
  }

  export type user_levelsOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    users?: usersOrderByRelationAggregateInput
  }

  export type user_levelsWhereUniqueInput = {
    id?: number
  }

  export type user_levelsOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    _count?: user_levelsCountOrderByAggregateInput
    _avg?: user_levelsAvgOrderByAggregateInput
    _max?: user_levelsMaxOrderByAggregateInput
    _min?: user_levelsMinOrderByAggregateInput
    _sum?: user_levelsSumOrderByAggregateInput
  }

  export type user_levelsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_levelsScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_levelsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_levelsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    description?: StringWithAggregatesFilter | string
  }

  export type user_profilesWhereInput = {
    AND?: Enumerable<user_profilesWhereInput>
    OR?: Enumerable<user_profilesWhereInput>
    NOT?: Enumerable<user_profilesWhereInput>
    id?: IntFilter | number
    profile_message?: StringNullableFilter | string | null
    profile_picture?: StringNullableFilter | string | null
    users?: UsersListRelationFilter
  }

  export type user_profilesOrderByWithRelationInput = {
    id?: SortOrder
    profile_message?: SortOrder
    profile_picture?: SortOrder
    users?: usersOrderByRelationAggregateInput
  }

  export type user_profilesWhereUniqueInput = {
    id?: number
  }

  export type user_profilesOrderByWithAggregationInput = {
    id?: SortOrder
    profile_message?: SortOrder
    profile_picture?: SortOrder
    _count?: user_profilesCountOrderByAggregateInput
    _avg?: user_profilesAvgOrderByAggregateInput
    _max?: user_profilesMaxOrderByAggregateInput
    _min?: user_profilesMinOrderByAggregateInput
    _sum?: user_profilesSumOrderByAggregateInput
  }

  export type user_profilesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_profilesScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_profilesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_profilesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    profile_message?: StringNullableWithAggregatesFilter | string | null
    profile_picture?: StringNullableWithAggregatesFilter | string | null
  }

  export type user_to_reactionWhereInput = {
    AND?: Enumerable<user_to_reactionWhereInput>
    OR?: Enumerable<user_to_reactionWhereInput>
    NOT?: Enumerable<user_to_reactionWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    reaction_id?: IntFilter | number
    reactions?: XOR<ReactionsRelationFilter, reactionsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type user_to_reactionOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    reaction_id?: SortOrder
    reactions?: reactionsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type user_to_reactionWhereUniqueInput = {
    id?: number
  }

  export type user_to_reactionOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    reaction_id?: SortOrder
    _count?: user_to_reactionCountOrderByAggregateInput
    _avg?: user_to_reactionAvgOrderByAggregateInput
    _max?: user_to_reactionMaxOrderByAggregateInput
    _min?: user_to_reactionMinOrderByAggregateInput
    _sum?: user_to_reactionSumOrderByAggregateInput
  }

  export type user_to_reactionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_to_reactionScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_to_reactionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_to_reactionScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    reaction_id?: IntWithAggregatesFilter | number
  }

  export type user_votesWhereInput = {
    AND?: Enumerable<user_votesWhereInput>
    OR?: Enumerable<user_votesWhereInput>
    NOT?: Enumerable<user_votesWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    user_vote?: IntFilter | number
    users?: XOR<UsersRelationFilter, usersWhereInput>
    unverified_sightings?: Unverified_sightingsListRelationFilter
  }

  export type user_votesOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_vote?: SortOrder
    users?: usersOrderByWithRelationInput
    unverified_sightings?: unverified_sightingsOrderByRelationAggregateInput
  }

  export type user_votesWhereUniqueInput = {
    id?: number
  }

  export type user_votesOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_vote?: SortOrder
    _count?: user_votesCountOrderByAggregateInput
    _avg?: user_votesAvgOrderByAggregateInput
    _max?: user_votesMaxOrderByAggregateInput
    _min?: user_votesMinOrderByAggregateInput
    _sum?: user_votesSumOrderByAggregateInput
  }

  export type user_votesScalarWhereWithAggregatesInput = {
    AND?: Enumerable<user_votesScalarWhereWithAggregatesInput>
    OR?: Enumerable<user_votesScalarWhereWithAggregatesInput>
    NOT?: Enumerable<user_votesScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
    user_vote?: IntWithAggregatesFilter | number
  }

  export type usersWhereInput = {
    AND?: Enumerable<usersWhereInput>
    OR?: Enumerable<usersWhereInput>
    NOT?: Enumerable<usersWhereInput>
    id?: IntFilter | number
    user_name?: StringFilter | string
    email_address?: StringFilter | string
    user_password?: StringFilter | string
    trusted_user?: BoolNullableFilter | boolean | null
    user_level_id?: IntFilter | number
    user_profile_id?: IntFilter | number
    user_levels?: XOR<User_levelsRelationFilter, user_levelsWhereInput>
    user_profiles?: XOR<User_profilesRelationFilter, user_profilesWhereInput>
    confirmed_sightings?: Confirmed_sightingsListRelationFilter
    unverified_sightings?: Unverified_sightingsListRelationFilter
    user_to_reaction?: User_to_reactionListRelationFilter
    user_votes?: User_votesListRelationFilter
    users_to_groups?: Users_to_groupsListRelationFilter
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    user_name?: SortOrder
    email_address?: SortOrder
    user_password?: SortOrder
    trusted_user?: SortOrder
    user_level_id?: SortOrder
    user_profile_id?: SortOrder
    user_levels?: user_levelsOrderByWithRelationInput
    user_profiles?: user_profilesOrderByWithRelationInput
    confirmed_sightings?: confirmed_sightingsOrderByRelationAggregateInput
    unverified_sightings?: unverified_sightingsOrderByRelationAggregateInput
    user_to_reaction?: user_to_reactionOrderByRelationAggregateInput
    user_votes?: user_votesOrderByRelationAggregateInput
    users_to_groups?: users_to_groupsOrderByRelationAggregateInput
  }

  export type usersWhereUniqueInput = {
    id?: number
    user_name?: string
    email_address?: string
  }

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    user_name?: SortOrder
    email_address?: SortOrder
    user_password?: SortOrder
    trusted_user?: SortOrder
    user_level_id?: SortOrder
    user_profile_id?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: Enumerable<usersScalarWhereWithAggregatesInput>
    OR?: Enumerable<usersScalarWhereWithAggregatesInput>
    NOT?: Enumerable<usersScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    user_name?: StringWithAggregatesFilter | string
    email_address?: StringWithAggregatesFilter | string
    user_password?: StringWithAggregatesFilter | string
    trusted_user?: BoolNullableWithAggregatesFilter | boolean | null
    user_level_id?: IntWithAggregatesFilter | number
    user_profile_id?: IntWithAggregatesFilter | number
  }

  export type users_to_groupsWhereInput = {
    AND?: Enumerable<users_to_groupsWhereInput>
    OR?: Enumerable<users_to_groupsWhereInput>
    NOT?: Enumerable<users_to_groupsWhereInput>
    id?: IntFilter | number
    group_id?: IntFilter | number
    user_id?: IntFilter | number
    interest_groups?: XOR<Interest_groupsRelationFilter, interest_groupsWhereInput>
    users?: XOR<UsersRelationFilter, usersWhereInput>
  }

  export type users_to_groupsOrderByWithRelationInput = {
    id?: SortOrder
    group_id?: SortOrder
    user_id?: SortOrder
    interest_groups?: interest_groupsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type users_to_groupsWhereUniqueInput = {
    id?: number
  }

  export type users_to_groupsOrderByWithAggregationInput = {
    id?: SortOrder
    group_id?: SortOrder
    user_id?: SortOrder
    _count?: users_to_groupsCountOrderByAggregateInput
    _avg?: users_to_groupsAvgOrderByAggregateInput
    _max?: users_to_groupsMaxOrderByAggregateInput
    _min?: users_to_groupsMinOrderByAggregateInput
    _sum?: users_to_groupsSumOrderByAggregateInput
  }

  export type users_to_groupsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<users_to_groupsScalarWhereWithAggregatesInput>
    OR?: Enumerable<users_to_groupsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<users_to_groupsScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    group_id?: IntWithAggregatesFilter | number
    user_id?: IntWithAggregatesFilter | number
  }

  export type confirmed_sightingsCreateInput = {
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    organisms: organismsCreateNestedOneWithoutConfirmed_sightingsInput
    users: usersCreateNestedOneWithoutConfirmed_sightingsInput
  }

  export type confirmed_sightingsUncheckedCreateInput = {
    id?: number
    organism_id: number
    user_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
  }

  export type confirmed_sightingsUpdateInput = {
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    organisms?: organismsUpdateOneRequiredWithoutConfirmed_sightingsNestedInput
    users?: usersUpdateOneRequiredWithoutConfirmed_sightingsNestedInput
  }

  export type confirmed_sightingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organism_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type confirmed_sightingsCreateManyInput = {
    id?: number
    organism_id: number
    user_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
  }

  export type confirmed_sightingsUpdateManyMutationInput = {
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type confirmed_sightingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organism_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type flyway_schema_historyCreateInput = {
    installed_rank: number
    version?: string | null
    description: string
    type: string
    script: string
    checksum?: number | null
    installed_by: string
    installed_on?: Date | string
    execution_time: number
    success: boolean
  }

  export type flyway_schema_historyUncheckedCreateInput = {
    installed_rank: number
    version?: string | null
    description: string
    type: string
    script: string
    checksum?: number | null
    installed_by: string
    installed_on?: Date | string
    execution_time: number
    success: boolean
  }

  export type flyway_schema_historyUpdateInput = {
    installed_rank?: IntFieldUpdateOperationsInput | number
    version?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    script?: StringFieldUpdateOperationsInput | string
    checksum?: NullableIntFieldUpdateOperationsInput | number | null
    installed_by?: StringFieldUpdateOperationsInput | string
    installed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    execution_time?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type flyway_schema_historyUncheckedUpdateInput = {
    installed_rank?: IntFieldUpdateOperationsInput | number
    version?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    script?: StringFieldUpdateOperationsInput | string
    checksum?: NullableIntFieldUpdateOperationsInput | number | null
    installed_by?: StringFieldUpdateOperationsInput | string
    installed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    execution_time?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type flyway_schema_historyCreateManyInput = {
    installed_rank: number
    version?: string | null
    description: string
    type: string
    script: string
    checksum?: number | null
    installed_by: string
    installed_on?: Date | string
    execution_time: number
    success: boolean
  }

  export type flyway_schema_historyUpdateManyMutationInput = {
    installed_rank?: IntFieldUpdateOperationsInput | number
    version?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    script?: StringFieldUpdateOperationsInput | string
    checksum?: NullableIntFieldUpdateOperationsInput | number | null
    installed_by?: StringFieldUpdateOperationsInput | string
    installed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    execution_time?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type flyway_schema_historyUncheckedUpdateManyInput = {
    installed_rank?: IntFieldUpdateOperationsInput | number
    version?: NullableStringFieldUpdateOperationsInput | string | null
    description?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    script?: StringFieldUpdateOperationsInput | string
    checksum?: NullableIntFieldUpdateOperationsInput | number | null
    installed_by?: StringFieldUpdateOperationsInput | string
    installed_on?: DateTimeFieldUpdateOperationsInput | Date | string
    execution_time?: IntFieldUpdateOperationsInput | number
    success?: BoolFieldUpdateOperationsInput | boolean
  }

  export type interest_groupsCreateInput = {
    group_name: string
    description?: string | null
    users_to_groups?: users_to_groupsCreateNestedManyWithoutInterest_groupsInput
  }

  export type interest_groupsUncheckedCreateInput = {
    id?: number
    group_name: string
    description?: string | null
    users_to_groups?: users_to_groupsUncheckedCreateNestedManyWithoutInterest_groupsInput
  }

  export type interest_groupsUpdateInput = {
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users_to_groups?: users_to_groupsUpdateManyWithoutInterest_groupsNestedInput
  }

  export type interest_groupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    users_to_groups?: users_to_groupsUncheckedUpdateManyWithoutInterest_groupsNestedInput
  }

  export type interest_groupsCreateManyInput = {
    id?: number
    group_name: string
    description?: string | null
  }

  export type interest_groupsUpdateManyMutationInput = {
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type interest_groupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organismsCreateInput = {
    taxon_name: string
    latin_name: string
    picture_url?: string | null
    description?: string | null
    taxon_groups: taxon_groupsCreateNestedOneWithoutOrganismsInput
    confirmed_sightings?: confirmed_sightingsCreateNestedManyWithoutOrganismsInput
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutOrganismsInput
  }

  export type organismsUncheckedCreateInput = {
    id?: number
    taxon_name: string
    latin_name: string
    taxon_group_id: number
    picture_url?: string | null
    description?: string | null
    confirmed_sightings?: confirmed_sightingsUncheckedCreateNestedManyWithoutOrganismsInput
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutOrganismsInput
  }

  export type organismsUpdateInput = {
    taxon_name?: StringFieldUpdateOperationsInput | string
    latin_name?: StringFieldUpdateOperationsInput | string
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taxon_groups?: taxon_groupsUpdateOneRequiredWithoutOrganismsNestedInput
    confirmed_sightings?: confirmed_sightingsUpdateManyWithoutOrganismsNestedInput
    unverified_sightings?: unverified_sightingsUpdateManyWithoutOrganismsNestedInput
  }

  export type organismsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taxon_name?: StringFieldUpdateOperationsInput | string
    latin_name?: StringFieldUpdateOperationsInput | string
    taxon_group_id?: IntFieldUpdateOperationsInput | number
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_sightings?: confirmed_sightingsUncheckedUpdateManyWithoutOrganismsNestedInput
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutOrganismsNestedInput
  }

  export type organismsCreateManyInput = {
    id?: number
    taxon_name: string
    latin_name: string
    taxon_group_id: number
    picture_url?: string | null
    description?: string | null
  }

  export type organismsUpdateManyMutationInput = {
    taxon_name?: StringFieldUpdateOperationsInput | string
    latin_name?: StringFieldUpdateOperationsInput | string
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type organismsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taxon_name?: StringFieldUpdateOperationsInput | string
    latin_name?: StringFieldUpdateOperationsInput | string
    taxon_group_id?: IntFieldUpdateOperationsInput | number
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reactionsCreateInput = {
    reaction_name: string
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutReactionsInput
    user_to_reaction?: user_to_reactionCreateNestedManyWithoutReactionsInput
  }

  export type reactionsUncheckedCreateInput = {
    id?: number
    reaction_name: string
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutReactionsInput
    user_to_reaction?: user_to_reactionUncheckedCreateNestedManyWithoutReactionsInput
  }

  export type reactionsUpdateInput = {
    reaction_name?: StringFieldUpdateOperationsInput | string
    unverified_sightings?: unverified_sightingsUpdateManyWithoutReactionsNestedInput
    user_to_reaction?: user_to_reactionUpdateManyWithoutReactionsNestedInput
  }

  export type reactionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction_name?: StringFieldUpdateOperationsInput | string
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutReactionsNestedInput
    user_to_reaction?: user_to_reactionUncheckedUpdateManyWithoutReactionsNestedInput
  }

  export type reactionsCreateManyInput = {
    id?: number
    reaction_name: string
  }

  export type reactionsUpdateManyMutationInput = {
    reaction_name?: StringFieldUpdateOperationsInput | string
  }

  export type reactionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction_name?: StringFieldUpdateOperationsInput | string
  }

  export type taxon_groupsCreateInput = {
    taxon_group_name: string
    description?: string | null
    organisms?: organismsCreateNestedManyWithoutTaxon_groupsInput
  }

  export type taxon_groupsUncheckedCreateInput = {
    id?: number
    taxon_group_name: string
    description?: string | null
    organisms?: organismsUncheckedCreateNestedManyWithoutTaxon_groupsInput
  }

  export type taxon_groupsUpdateInput = {
    taxon_group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisms?: organismsUpdateManyWithoutTaxon_groupsNestedInput
  }

  export type taxon_groupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    taxon_group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    organisms?: organismsUncheckedUpdateManyWithoutTaxon_groupsNestedInput
  }

  export type taxon_groupsCreateManyInput = {
    id?: number
    taxon_group_name: string
    description?: string | null
  }

  export type taxon_groupsUpdateManyMutationInput = {
    taxon_group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type taxon_groupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    taxon_group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type unverified_sightingsCreateInput = {
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    organisms: organismsCreateNestedOneWithoutUnverified_sightingsInput
    reactions?: reactionsCreateNestedOneWithoutUnverified_sightingsInput
    users: usersCreateNestedOneWithoutUnverified_sightingsInput
    user_votes?: user_votesCreateNestedOneWithoutUnverified_sightingsInput
  }

  export type unverified_sightingsUncheckedCreateInput = {
    id?: number
    organism_id: number
    user_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    user_vote_id?: number | null
    reaction_id?: number | null
  }

  export type unverified_sightingsUpdateInput = {
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    organisms?: organismsUpdateOneRequiredWithoutUnverified_sightingsNestedInput
    reactions?: reactionsUpdateOneWithoutUnverified_sightingsNestedInput
    users?: usersUpdateOneRequiredWithoutUnverified_sightingsNestedInput
    user_votes?: user_votesUpdateOneWithoutUnverified_sightingsNestedInput
  }

  export type unverified_sightingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    organism_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_vote_id?: NullableIntFieldUpdateOperationsInput | number | null
    reaction_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type unverified_sightingsCreateManyInput = {
    id?: number
    organism_id: number
    user_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    user_vote_id?: number | null
    reaction_id?: number | null
  }

  export type unverified_sightingsUpdateManyMutationInput = {
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type unverified_sightingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    organism_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_vote_id?: NullableIntFieldUpdateOperationsInput | number | null
    reaction_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type user_levelsCreateInput = {
    description: string
    users?: usersCreateNestedManyWithoutUser_levelsInput
  }

  export type user_levelsUncheckedCreateInput = {
    id?: number
    description: string
    users?: usersUncheckedCreateNestedManyWithoutUser_levelsInput
  }

  export type user_levelsUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateManyWithoutUser_levelsNestedInput
  }

  export type user_levelsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    users?: usersUncheckedUpdateManyWithoutUser_levelsNestedInput
  }

  export type user_levelsCreateManyInput = {
    id?: number
    description: string
  }

  export type user_levelsUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
  }

  export type user_levelsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type user_profilesCreateInput = {
    profile_message?: string | null
    profile_picture?: string | null
    users?: usersCreateNestedManyWithoutUser_profilesInput
  }

  export type user_profilesUncheckedCreateInput = {
    id?: number
    profile_message?: string | null
    profile_picture?: string | null
    users?: usersUncheckedCreateNestedManyWithoutUser_profilesInput
  }

  export type user_profilesUpdateInput = {
    profile_message?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUpdateManyWithoutUser_profilesNestedInput
  }

  export type user_profilesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    profile_message?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
    users?: usersUncheckedUpdateManyWithoutUser_profilesNestedInput
  }

  export type user_profilesCreateManyInput = {
    id?: number
    profile_message?: string | null
    profile_picture?: string | null
  }

  export type user_profilesUpdateManyMutationInput = {
    profile_message?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_profilesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    profile_message?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_to_reactionCreateInput = {
    reactions: reactionsCreateNestedOneWithoutUser_to_reactionInput
    users: usersCreateNestedOneWithoutUser_to_reactionInput
  }

  export type user_to_reactionUncheckedCreateInput = {
    id?: number
    user_id: number
    reaction_id: number
  }

  export type user_to_reactionUpdateInput = {
    reactions?: reactionsUpdateOneRequiredWithoutUser_to_reactionNestedInput
    users?: usersUpdateOneRequiredWithoutUser_to_reactionNestedInput
  }

  export type user_to_reactionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    reaction_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_to_reactionCreateManyInput = {
    id?: number
    user_id: number
    reaction_id: number
  }

  export type user_to_reactionUpdateManyMutationInput = {

  }

  export type user_to_reactionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    reaction_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_votesCreateInput = {
    user_vote: number
    users: usersCreateNestedOneWithoutUser_votesInput
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutUser_votesInput
  }

  export type user_votesUncheckedCreateInput = {
    id?: number
    user_id: number
    user_vote: number
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutUser_votesInput
  }

  export type user_votesUpdateInput = {
    user_vote?: IntFieldUpdateOperationsInput | number
    users?: usersUpdateOneRequiredWithoutUser_votesNestedInput
    unverified_sightings?: unverified_sightingsUpdateManyWithoutUser_votesNestedInput
  }

  export type user_votesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    user_vote?: IntFieldUpdateOperationsInput | number
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutUser_votesNestedInput
  }

  export type user_votesCreateManyInput = {
    id?: number
    user_id: number
    user_vote: number
  }

  export type user_votesUpdateManyMutationInput = {
    user_vote?: IntFieldUpdateOperationsInput | number
  }

  export type user_votesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    user_vote?: IntFieldUpdateOperationsInput | number
  }

  export type usersCreateInput = {
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_levels: user_levelsCreateNestedOneWithoutUsersInput
    user_profiles: user_profilesCreateNestedOneWithoutUsersInput
    confirmed_sightings?: confirmed_sightingsCreateNestedManyWithoutUsersInput
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionCreateNestedManyWithoutUsersInput
    user_votes?: user_votesCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: number
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_level_id: number
    user_profile_id: number
    confirmed_sightings?: confirmed_sightingsUncheckedCreateNestedManyWithoutUsersInput
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionUncheckedCreateNestedManyWithoutUsersInput
    user_votes?: user_votesUncheckedCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_levels?: user_levelsUpdateOneRequiredWithoutUsersNestedInput
    user_profiles?: user_profilesUpdateOneRequiredWithoutUsersNestedInput
    confirmed_sightings?: confirmed_sightingsUpdateManyWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_level_id?: IntFieldUpdateOperationsInput | number
    user_profile_id?: IntFieldUpdateOperationsInput | number
    confirmed_sightings?: confirmed_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUncheckedUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUncheckedUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id?: number
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_level_id: number
    user_profile_id: number
  }

  export type usersUpdateManyMutationInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_level_id?: IntFieldUpdateOperationsInput | number
    user_profile_id?: IntFieldUpdateOperationsInput | number
  }

  export type users_to_groupsCreateInput = {
    interest_groups: interest_groupsCreateNestedOneWithoutUsers_to_groupsInput
    users: usersCreateNestedOneWithoutUsers_to_groupsInput
  }

  export type users_to_groupsUncheckedCreateInput = {
    id?: number
    group_id: number
    user_id: number
  }

  export type users_to_groupsUpdateInput = {
    interest_groups?: interest_groupsUpdateOneRequiredWithoutUsers_to_groupsNestedInput
    users?: usersUpdateOneRequiredWithoutUsers_to_groupsNestedInput
  }

  export type users_to_groupsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type users_to_groupsCreateManyInput = {
    id?: number
    group_id: number
    user_id: number
  }

  export type users_to_groupsUpdateManyMutationInput = {

  }

  export type users_to_groupsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type DecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type OrganismsRelationFilter = {
    is?: organismsWhereInput
    isNot?: organismsWhereInput
  }

  export type UsersRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type confirmed_sightingsCountOrderByAggregateInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    picture_url?: SortOrder
    date?: SortOrder
    lat?: SortOrder
    long?: SortOrder
  }

  export type confirmed_sightingsAvgOrderByAggregateInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    lat?: SortOrder
    long?: SortOrder
  }

  export type confirmed_sightingsMaxOrderByAggregateInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    picture_url?: SortOrder
    date?: SortOrder
    lat?: SortOrder
    long?: SortOrder
  }

  export type confirmed_sightingsMinOrderByAggregateInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    picture_url?: SortOrder
    date?: SortOrder
    lat?: SortOrder
    long?: SortOrder
  }

  export type confirmed_sightingsSumOrderByAggregateInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    lat?: SortOrder
    long?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type DecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableFilter | string | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type flyway_schema_historyCountOrderByAggregateInput = {
    installed_rank?: SortOrder
    version?: SortOrder
    description?: SortOrder
    type?: SortOrder
    script?: SortOrder
    checksum?: SortOrder
    installed_by?: SortOrder
    installed_on?: SortOrder
    execution_time?: SortOrder
    success?: SortOrder
  }

  export type flyway_schema_historyAvgOrderByAggregateInput = {
    installed_rank?: SortOrder
    checksum?: SortOrder
    execution_time?: SortOrder
  }

  export type flyway_schema_historyMaxOrderByAggregateInput = {
    installed_rank?: SortOrder
    version?: SortOrder
    description?: SortOrder
    type?: SortOrder
    script?: SortOrder
    checksum?: SortOrder
    installed_by?: SortOrder
    installed_on?: SortOrder
    execution_time?: SortOrder
    success?: SortOrder
  }

  export type flyway_schema_historyMinOrderByAggregateInput = {
    installed_rank?: SortOrder
    version?: SortOrder
    description?: SortOrder
    type?: SortOrder
    script?: SortOrder
    checksum?: SortOrder
    installed_by?: SortOrder
    installed_on?: SortOrder
    execution_time?: SortOrder
    success?: SortOrder
  }

  export type flyway_schema_historySumOrderByAggregateInput = {
    installed_rank?: SortOrder
    checksum?: SortOrder
    execution_time?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type Users_to_groupsListRelationFilter = {
    every?: users_to_groupsWhereInput
    some?: users_to_groupsWhereInput
    none?: users_to_groupsWhereInput
  }

  export type users_to_groupsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type interest_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    group_name?: SortOrder
    description?: SortOrder
  }

  export type interest_groupsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type interest_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    group_name?: SortOrder
    description?: SortOrder
  }

  export type interest_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    group_name?: SortOrder
    description?: SortOrder
  }

  export type interest_groupsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Taxon_groupsRelationFilter = {
    is?: taxon_groupsWhereInput
    isNot?: taxon_groupsWhereInput
  }

  export type Confirmed_sightingsListRelationFilter = {
    every?: confirmed_sightingsWhereInput
    some?: confirmed_sightingsWhereInput
    none?: confirmed_sightingsWhereInput
  }

  export type Unverified_sightingsListRelationFilter = {
    every?: unverified_sightingsWhereInput
    some?: unverified_sightingsWhereInput
    none?: unverified_sightingsWhereInput
  }

  export type confirmed_sightingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type unverified_sightingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type organismsCountOrderByAggregateInput = {
    id?: SortOrder
    taxon_name?: SortOrder
    latin_name?: SortOrder
    taxon_group_id?: SortOrder
    picture_url?: SortOrder
    description?: SortOrder
  }

  export type organismsAvgOrderByAggregateInput = {
    id?: SortOrder
    taxon_group_id?: SortOrder
  }

  export type organismsMaxOrderByAggregateInput = {
    id?: SortOrder
    taxon_name?: SortOrder
    latin_name?: SortOrder
    taxon_group_id?: SortOrder
    picture_url?: SortOrder
    description?: SortOrder
  }

  export type organismsMinOrderByAggregateInput = {
    id?: SortOrder
    taxon_name?: SortOrder
    latin_name?: SortOrder
    taxon_group_id?: SortOrder
    picture_url?: SortOrder
    description?: SortOrder
  }

  export type organismsSumOrderByAggregateInput = {
    id?: SortOrder
    taxon_group_id?: SortOrder
  }

  export type User_to_reactionListRelationFilter = {
    every?: user_to_reactionWhereInput
    some?: user_to_reactionWhereInput
    none?: user_to_reactionWhereInput
  }

  export type user_to_reactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reactionsCountOrderByAggregateInput = {
    id?: SortOrder
    reaction_name?: SortOrder
  }

  export type reactionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type reactionsMaxOrderByAggregateInput = {
    id?: SortOrder
    reaction_name?: SortOrder
  }

  export type reactionsMinOrderByAggregateInput = {
    id?: SortOrder
    reaction_name?: SortOrder
  }

  export type reactionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OrganismsListRelationFilter = {
    every?: organismsWhereInput
    some?: organismsWhereInput
    none?: organismsWhereInput
  }

  export type organismsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type taxon_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    taxon_group_name?: SortOrder
    description?: SortOrder
  }

  export type taxon_groupsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type taxon_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    taxon_group_name?: SortOrder
    description?: SortOrder
  }

  export type taxon_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    taxon_group_name?: SortOrder
    description?: SortOrder
  }

  export type taxon_groupsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ReactionsRelationFilter = {
    is?: reactionsWhereInput
    isNot?: reactionsWhereInput
  }

  export type User_votesRelationFilter = {
    is?: user_votesWhereInput | null
    isNot?: user_votesWhereInput | null
  }

  export type unverified_sightingsCountOrderByAggregateInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    picture_url?: SortOrder
    date?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    user_vote_id?: SortOrder
    reaction_id?: SortOrder
  }

  export type unverified_sightingsAvgOrderByAggregateInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    user_vote_id?: SortOrder
    reaction_id?: SortOrder
  }

  export type unverified_sightingsMaxOrderByAggregateInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    picture_url?: SortOrder
    date?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    user_vote_id?: SortOrder
    reaction_id?: SortOrder
  }

  export type unverified_sightingsMinOrderByAggregateInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    picture_url?: SortOrder
    date?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    user_vote_id?: SortOrder
    reaction_id?: SortOrder
  }

  export type unverified_sightingsSumOrderByAggregateInput = {
    id?: SortOrder
    organism_id?: SortOrder
    user_id?: SortOrder
    lat?: SortOrder
    long?: SortOrder
    user_vote_id?: SortOrder
    reaction_id?: SortOrder
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_levelsCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type user_levelsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type user_levelsMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type user_levelsMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
  }

  export type user_levelsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type user_profilesCountOrderByAggregateInput = {
    id?: SortOrder
    profile_message?: SortOrder
    profile_picture?: SortOrder
  }

  export type user_profilesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type user_profilesMaxOrderByAggregateInput = {
    id?: SortOrder
    profile_message?: SortOrder
    profile_picture?: SortOrder
  }

  export type user_profilesMinOrderByAggregateInput = {
    id?: SortOrder
    profile_message?: SortOrder
    profile_picture?: SortOrder
  }

  export type user_profilesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type user_to_reactionCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    reaction_id?: SortOrder
  }

  export type user_to_reactionAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    reaction_id?: SortOrder
  }

  export type user_to_reactionMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    reaction_id?: SortOrder
  }

  export type user_to_reactionMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    reaction_id?: SortOrder
  }

  export type user_to_reactionSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    reaction_id?: SortOrder
  }

  export type user_votesCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_vote?: SortOrder
  }

  export type user_votesAvgOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_vote?: SortOrder
  }

  export type user_votesMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_vote?: SortOrder
  }

  export type user_votesMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_vote?: SortOrder
  }

  export type user_votesSumOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    user_vote?: SortOrder
  }

  export type BoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type User_levelsRelationFilter = {
    is?: user_levelsWhereInput
    isNot?: user_levelsWhereInput
  }

  export type User_profilesRelationFilter = {
    is?: user_profilesWhereInput
    isNot?: user_profilesWhereInput
  }

  export type User_votesListRelationFilter = {
    every?: user_votesWhereInput
    some?: user_votesWhereInput
    none?: user_votesWhereInput
  }

  export type user_votesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    user_name?: SortOrder
    email_address?: SortOrder
    user_password?: SortOrder
    trusted_user?: SortOrder
    user_level_id?: SortOrder
    user_profile_id?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    user_level_id?: SortOrder
    user_profile_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    user_name?: SortOrder
    email_address?: SortOrder
    user_password?: SortOrder
    trusted_user?: SortOrder
    user_level_id?: SortOrder
    user_profile_id?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    user_name?: SortOrder
    email_address?: SortOrder
    user_password?: SortOrder
    trusted_user?: SortOrder
    user_level_id?: SortOrder
    user_profile_id?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    user_level_id?: SortOrder
    user_profile_id?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type Interest_groupsRelationFilter = {
    is?: interest_groupsWhereInput
    isNot?: interest_groupsWhereInput
  }

  export type users_to_groupsCountOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    user_id?: SortOrder
  }

  export type users_to_groupsAvgOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    user_id?: SortOrder
  }

  export type users_to_groupsMaxOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    user_id?: SortOrder
  }

  export type users_to_groupsMinOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    user_id?: SortOrder
  }

  export type users_to_groupsSumOrderByAggregateInput = {
    id?: SortOrder
    group_id?: SortOrder
    user_id?: SortOrder
  }

  export type organismsCreateNestedOneWithoutConfirmed_sightingsInput = {
    create?: XOR<organismsCreateWithoutConfirmed_sightingsInput, organismsUncheckedCreateWithoutConfirmed_sightingsInput>
    connectOrCreate?: organismsCreateOrConnectWithoutConfirmed_sightingsInput
    connect?: organismsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutConfirmed_sightingsInput = {
    create?: XOR<usersCreateWithoutConfirmed_sightingsInput, usersUncheckedCreateWithoutConfirmed_sightingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutConfirmed_sightingsInput
    connect?: usersWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type organismsUpdateOneRequiredWithoutConfirmed_sightingsNestedInput = {
    create?: XOR<organismsCreateWithoutConfirmed_sightingsInput, organismsUncheckedCreateWithoutConfirmed_sightingsInput>
    connectOrCreate?: organismsCreateOrConnectWithoutConfirmed_sightingsInput
    upsert?: organismsUpsertWithoutConfirmed_sightingsInput
    connect?: organismsWhereUniqueInput
    update?: XOR<organismsUpdateWithoutConfirmed_sightingsInput, organismsUncheckedUpdateWithoutConfirmed_sightingsInput>
  }

  export type usersUpdateOneRequiredWithoutConfirmed_sightingsNestedInput = {
    create?: XOR<usersCreateWithoutConfirmed_sightingsInput, usersUncheckedCreateWithoutConfirmed_sightingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutConfirmed_sightingsInput
    upsert?: usersUpsertWithoutConfirmed_sightingsInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutConfirmed_sightingsInput, usersUncheckedUpdateWithoutConfirmed_sightingsInput>
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type users_to_groupsCreateNestedManyWithoutInterest_groupsInput = {
    create?: XOR<Enumerable<users_to_groupsCreateWithoutInterest_groupsInput>, Enumerable<users_to_groupsUncheckedCreateWithoutInterest_groupsInput>>
    connectOrCreate?: Enumerable<users_to_groupsCreateOrConnectWithoutInterest_groupsInput>
    createMany?: users_to_groupsCreateManyInterest_groupsInputEnvelope
    connect?: Enumerable<users_to_groupsWhereUniqueInput>
  }

  export type users_to_groupsUncheckedCreateNestedManyWithoutInterest_groupsInput = {
    create?: XOR<Enumerable<users_to_groupsCreateWithoutInterest_groupsInput>, Enumerable<users_to_groupsUncheckedCreateWithoutInterest_groupsInput>>
    connectOrCreate?: Enumerable<users_to_groupsCreateOrConnectWithoutInterest_groupsInput>
    createMany?: users_to_groupsCreateManyInterest_groupsInputEnvelope
    connect?: Enumerable<users_to_groupsWhereUniqueInput>
  }

  export type users_to_groupsUpdateManyWithoutInterest_groupsNestedInput = {
    create?: XOR<Enumerable<users_to_groupsCreateWithoutInterest_groupsInput>, Enumerable<users_to_groupsUncheckedCreateWithoutInterest_groupsInput>>
    connectOrCreate?: Enumerable<users_to_groupsCreateOrConnectWithoutInterest_groupsInput>
    upsert?: Enumerable<users_to_groupsUpsertWithWhereUniqueWithoutInterest_groupsInput>
    createMany?: users_to_groupsCreateManyInterest_groupsInputEnvelope
    set?: Enumerable<users_to_groupsWhereUniqueInput>
    disconnect?: Enumerable<users_to_groupsWhereUniqueInput>
    delete?: Enumerable<users_to_groupsWhereUniqueInput>
    connect?: Enumerable<users_to_groupsWhereUniqueInput>
    update?: Enumerable<users_to_groupsUpdateWithWhereUniqueWithoutInterest_groupsInput>
    updateMany?: Enumerable<users_to_groupsUpdateManyWithWhereWithoutInterest_groupsInput>
    deleteMany?: Enumerable<users_to_groupsScalarWhereInput>
  }

  export type users_to_groupsUncheckedUpdateManyWithoutInterest_groupsNestedInput = {
    create?: XOR<Enumerable<users_to_groupsCreateWithoutInterest_groupsInput>, Enumerable<users_to_groupsUncheckedCreateWithoutInterest_groupsInput>>
    connectOrCreate?: Enumerable<users_to_groupsCreateOrConnectWithoutInterest_groupsInput>
    upsert?: Enumerable<users_to_groupsUpsertWithWhereUniqueWithoutInterest_groupsInput>
    createMany?: users_to_groupsCreateManyInterest_groupsInputEnvelope
    set?: Enumerable<users_to_groupsWhereUniqueInput>
    disconnect?: Enumerable<users_to_groupsWhereUniqueInput>
    delete?: Enumerable<users_to_groupsWhereUniqueInput>
    connect?: Enumerable<users_to_groupsWhereUniqueInput>
    update?: Enumerable<users_to_groupsUpdateWithWhereUniqueWithoutInterest_groupsInput>
    updateMany?: Enumerable<users_to_groupsUpdateManyWithWhereWithoutInterest_groupsInput>
    deleteMany?: Enumerable<users_to_groupsScalarWhereInput>
  }

  export type taxon_groupsCreateNestedOneWithoutOrganismsInput = {
    create?: XOR<taxon_groupsCreateWithoutOrganismsInput, taxon_groupsUncheckedCreateWithoutOrganismsInput>
    connectOrCreate?: taxon_groupsCreateOrConnectWithoutOrganismsInput
    connect?: taxon_groupsWhereUniqueInput
  }

  export type confirmed_sightingsCreateNestedManyWithoutOrganismsInput = {
    create?: XOR<Enumerable<confirmed_sightingsCreateWithoutOrganismsInput>, Enumerable<confirmed_sightingsUncheckedCreateWithoutOrganismsInput>>
    connectOrCreate?: Enumerable<confirmed_sightingsCreateOrConnectWithoutOrganismsInput>
    createMany?: confirmed_sightingsCreateManyOrganismsInputEnvelope
    connect?: Enumerable<confirmed_sightingsWhereUniqueInput>
  }

  export type unverified_sightingsCreateNestedManyWithoutOrganismsInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutOrganismsInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutOrganismsInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutOrganismsInput>
    createMany?: unverified_sightingsCreateManyOrganismsInputEnvelope
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
  }

  export type confirmed_sightingsUncheckedCreateNestedManyWithoutOrganismsInput = {
    create?: XOR<Enumerable<confirmed_sightingsCreateWithoutOrganismsInput>, Enumerable<confirmed_sightingsUncheckedCreateWithoutOrganismsInput>>
    connectOrCreate?: Enumerable<confirmed_sightingsCreateOrConnectWithoutOrganismsInput>
    createMany?: confirmed_sightingsCreateManyOrganismsInputEnvelope
    connect?: Enumerable<confirmed_sightingsWhereUniqueInput>
  }

  export type unverified_sightingsUncheckedCreateNestedManyWithoutOrganismsInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutOrganismsInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutOrganismsInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutOrganismsInput>
    createMany?: unverified_sightingsCreateManyOrganismsInputEnvelope
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
  }

  export type taxon_groupsUpdateOneRequiredWithoutOrganismsNestedInput = {
    create?: XOR<taxon_groupsCreateWithoutOrganismsInput, taxon_groupsUncheckedCreateWithoutOrganismsInput>
    connectOrCreate?: taxon_groupsCreateOrConnectWithoutOrganismsInput
    upsert?: taxon_groupsUpsertWithoutOrganismsInput
    connect?: taxon_groupsWhereUniqueInput
    update?: XOR<taxon_groupsUpdateWithoutOrganismsInput, taxon_groupsUncheckedUpdateWithoutOrganismsInput>
  }

  export type confirmed_sightingsUpdateManyWithoutOrganismsNestedInput = {
    create?: XOR<Enumerable<confirmed_sightingsCreateWithoutOrganismsInput>, Enumerable<confirmed_sightingsUncheckedCreateWithoutOrganismsInput>>
    connectOrCreate?: Enumerable<confirmed_sightingsCreateOrConnectWithoutOrganismsInput>
    upsert?: Enumerable<confirmed_sightingsUpsertWithWhereUniqueWithoutOrganismsInput>
    createMany?: confirmed_sightingsCreateManyOrganismsInputEnvelope
    set?: Enumerable<confirmed_sightingsWhereUniqueInput>
    disconnect?: Enumerable<confirmed_sightingsWhereUniqueInput>
    delete?: Enumerable<confirmed_sightingsWhereUniqueInput>
    connect?: Enumerable<confirmed_sightingsWhereUniqueInput>
    update?: Enumerable<confirmed_sightingsUpdateWithWhereUniqueWithoutOrganismsInput>
    updateMany?: Enumerable<confirmed_sightingsUpdateManyWithWhereWithoutOrganismsInput>
    deleteMany?: Enumerable<confirmed_sightingsScalarWhereInput>
  }

  export type unverified_sightingsUpdateManyWithoutOrganismsNestedInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutOrganismsInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutOrganismsInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutOrganismsInput>
    upsert?: Enumerable<unverified_sightingsUpsertWithWhereUniqueWithoutOrganismsInput>
    createMany?: unverified_sightingsCreateManyOrganismsInputEnvelope
    set?: Enumerable<unverified_sightingsWhereUniqueInput>
    disconnect?: Enumerable<unverified_sightingsWhereUniqueInput>
    delete?: Enumerable<unverified_sightingsWhereUniqueInput>
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
    update?: Enumerable<unverified_sightingsUpdateWithWhereUniqueWithoutOrganismsInput>
    updateMany?: Enumerable<unverified_sightingsUpdateManyWithWhereWithoutOrganismsInput>
    deleteMany?: Enumerable<unverified_sightingsScalarWhereInput>
  }

  export type confirmed_sightingsUncheckedUpdateManyWithoutOrganismsNestedInput = {
    create?: XOR<Enumerable<confirmed_sightingsCreateWithoutOrganismsInput>, Enumerable<confirmed_sightingsUncheckedCreateWithoutOrganismsInput>>
    connectOrCreate?: Enumerable<confirmed_sightingsCreateOrConnectWithoutOrganismsInput>
    upsert?: Enumerable<confirmed_sightingsUpsertWithWhereUniqueWithoutOrganismsInput>
    createMany?: confirmed_sightingsCreateManyOrganismsInputEnvelope
    set?: Enumerable<confirmed_sightingsWhereUniqueInput>
    disconnect?: Enumerable<confirmed_sightingsWhereUniqueInput>
    delete?: Enumerable<confirmed_sightingsWhereUniqueInput>
    connect?: Enumerable<confirmed_sightingsWhereUniqueInput>
    update?: Enumerable<confirmed_sightingsUpdateWithWhereUniqueWithoutOrganismsInput>
    updateMany?: Enumerable<confirmed_sightingsUpdateManyWithWhereWithoutOrganismsInput>
    deleteMany?: Enumerable<confirmed_sightingsScalarWhereInput>
  }

  export type unverified_sightingsUncheckedUpdateManyWithoutOrganismsNestedInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutOrganismsInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutOrganismsInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutOrganismsInput>
    upsert?: Enumerable<unverified_sightingsUpsertWithWhereUniqueWithoutOrganismsInput>
    createMany?: unverified_sightingsCreateManyOrganismsInputEnvelope
    set?: Enumerable<unverified_sightingsWhereUniqueInput>
    disconnect?: Enumerable<unverified_sightingsWhereUniqueInput>
    delete?: Enumerable<unverified_sightingsWhereUniqueInput>
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
    update?: Enumerable<unverified_sightingsUpdateWithWhereUniqueWithoutOrganismsInput>
    updateMany?: Enumerable<unverified_sightingsUpdateManyWithWhereWithoutOrganismsInput>
    deleteMany?: Enumerable<unverified_sightingsScalarWhereInput>
  }

  export type unverified_sightingsCreateNestedManyWithoutReactionsInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutReactionsInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutReactionsInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutReactionsInput>
    createMany?: unverified_sightingsCreateManyReactionsInputEnvelope
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
  }

  export type user_to_reactionCreateNestedManyWithoutReactionsInput = {
    create?: XOR<Enumerable<user_to_reactionCreateWithoutReactionsInput>, Enumerable<user_to_reactionUncheckedCreateWithoutReactionsInput>>
    connectOrCreate?: Enumerable<user_to_reactionCreateOrConnectWithoutReactionsInput>
    createMany?: user_to_reactionCreateManyReactionsInputEnvelope
    connect?: Enumerable<user_to_reactionWhereUniqueInput>
  }

  export type unverified_sightingsUncheckedCreateNestedManyWithoutReactionsInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutReactionsInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutReactionsInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutReactionsInput>
    createMany?: unverified_sightingsCreateManyReactionsInputEnvelope
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
  }

  export type user_to_reactionUncheckedCreateNestedManyWithoutReactionsInput = {
    create?: XOR<Enumerable<user_to_reactionCreateWithoutReactionsInput>, Enumerable<user_to_reactionUncheckedCreateWithoutReactionsInput>>
    connectOrCreate?: Enumerable<user_to_reactionCreateOrConnectWithoutReactionsInput>
    createMany?: user_to_reactionCreateManyReactionsInputEnvelope
    connect?: Enumerable<user_to_reactionWhereUniqueInput>
  }

  export type unverified_sightingsUpdateManyWithoutReactionsNestedInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutReactionsInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutReactionsInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutReactionsInput>
    upsert?: Enumerable<unverified_sightingsUpsertWithWhereUniqueWithoutReactionsInput>
    createMany?: unverified_sightingsCreateManyReactionsInputEnvelope
    set?: Enumerable<unverified_sightingsWhereUniqueInput>
    disconnect?: Enumerable<unverified_sightingsWhereUniqueInput>
    delete?: Enumerable<unverified_sightingsWhereUniqueInput>
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
    update?: Enumerable<unverified_sightingsUpdateWithWhereUniqueWithoutReactionsInput>
    updateMany?: Enumerable<unverified_sightingsUpdateManyWithWhereWithoutReactionsInput>
    deleteMany?: Enumerable<unverified_sightingsScalarWhereInput>
  }

  export type user_to_reactionUpdateManyWithoutReactionsNestedInput = {
    create?: XOR<Enumerable<user_to_reactionCreateWithoutReactionsInput>, Enumerable<user_to_reactionUncheckedCreateWithoutReactionsInput>>
    connectOrCreate?: Enumerable<user_to_reactionCreateOrConnectWithoutReactionsInput>
    upsert?: Enumerable<user_to_reactionUpsertWithWhereUniqueWithoutReactionsInput>
    createMany?: user_to_reactionCreateManyReactionsInputEnvelope
    set?: Enumerable<user_to_reactionWhereUniqueInput>
    disconnect?: Enumerable<user_to_reactionWhereUniqueInput>
    delete?: Enumerable<user_to_reactionWhereUniqueInput>
    connect?: Enumerable<user_to_reactionWhereUniqueInput>
    update?: Enumerable<user_to_reactionUpdateWithWhereUniqueWithoutReactionsInput>
    updateMany?: Enumerable<user_to_reactionUpdateManyWithWhereWithoutReactionsInput>
    deleteMany?: Enumerable<user_to_reactionScalarWhereInput>
  }

  export type unverified_sightingsUncheckedUpdateManyWithoutReactionsNestedInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutReactionsInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutReactionsInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutReactionsInput>
    upsert?: Enumerable<unverified_sightingsUpsertWithWhereUniqueWithoutReactionsInput>
    createMany?: unverified_sightingsCreateManyReactionsInputEnvelope
    set?: Enumerable<unverified_sightingsWhereUniqueInput>
    disconnect?: Enumerable<unverified_sightingsWhereUniqueInput>
    delete?: Enumerable<unverified_sightingsWhereUniqueInput>
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
    update?: Enumerable<unverified_sightingsUpdateWithWhereUniqueWithoutReactionsInput>
    updateMany?: Enumerable<unverified_sightingsUpdateManyWithWhereWithoutReactionsInput>
    deleteMany?: Enumerable<unverified_sightingsScalarWhereInput>
  }

  export type user_to_reactionUncheckedUpdateManyWithoutReactionsNestedInput = {
    create?: XOR<Enumerable<user_to_reactionCreateWithoutReactionsInput>, Enumerable<user_to_reactionUncheckedCreateWithoutReactionsInput>>
    connectOrCreate?: Enumerable<user_to_reactionCreateOrConnectWithoutReactionsInput>
    upsert?: Enumerable<user_to_reactionUpsertWithWhereUniqueWithoutReactionsInput>
    createMany?: user_to_reactionCreateManyReactionsInputEnvelope
    set?: Enumerable<user_to_reactionWhereUniqueInput>
    disconnect?: Enumerable<user_to_reactionWhereUniqueInput>
    delete?: Enumerable<user_to_reactionWhereUniqueInput>
    connect?: Enumerable<user_to_reactionWhereUniqueInput>
    update?: Enumerable<user_to_reactionUpdateWithWhereUniqueWithoutReactionsInput>
    updateMany?: Enumerable<user_to_reactionUpdateManyWithWhereWithoutReactionsInput>
    deleteMany?: Enumerable<user_to_reactionScalarWhereInput>
  }

  export type organismsCreateNestedManyWithoutTaxon_groupsInput = {
    create?: XOR<Enumerable<organismsCreateWithoutTaxon_groupsInput>, Enumerable<organismsUncheckedCreateWithoutTaxon_groupsInput>>
    connectOrCreate?: Enumerable<organismsCreateOrConnectWithoutTaxon_groupsInput>
    createMany?: organismsCreateManyTaxon_groupsInputEnvelope
    connect?: Enumerable<organismsWhereUniqueInput>
  }

  export type organismsUncheckedCreateNestedManyWithoutTaxon_groupsInput = {
    create?: XOR<Enumerable<organismsCreateWithoutTaxon_groupsInput>, Enumerable<organismsUncheckedCreateWithoutTaxon_groupsInput>>
    connectOrCreate?: Enumerable<organismsCreateOrConnectWithoutTaxon_groupsInput>
    createMany?: organismsCreateManyTaxon_groupsInputEnvelope
    connect?: Enumerable<organismsWhereUniqueInput>
  }

  export type organismsUpdateManyWithoutTaxon_groupsNestedInput = {
    create?: XOR<Enumerable<organismsCreateWithoutTaxon_groupsInput>, Enumerable<organismsUncheckedCreateWithoutTaxon_groupsInput>>
    connectOrCreate?: Enumerable<organismsCreateOrConnectWithoutTaxon_groupsInput>
    upsert?: Enumerable<organismsUpsertWithWhereUniqueWithoutTaxon_groupsInput>
    createMany?: organismsCreateManyTaxon_groupsInputEnvelope
    set?: Enumerable<organismsWhereUniqueInput>
    disconnect?: Enumerable<organismsWhereUniqueInput>
    delete?: Enumerable<organismsWhereUniqueInput>
    connect?: Enumerable<organismsWhereUniqueInput>
    update?: Enumerable<organismsUpdateWithWhereUniqueWithoutTaxon_groupsInput>
    updateMany?: Enumerable<organismsUpdateManyWithWhereWithoutTaxon_groupsInput>
    deleteMany?: Enumerable<organismsScalarWhereInput>
  }

  export type organismsUncheckedUpdateManyWithoutTaxon_groupsNestedInput = {
    create?: XOR<Enumerable<organismsCreateWithoutTaxon_groupsInput>, Enumerable<organismsUncheckedCreateWithoutTaxon_groupsInput>>
    connectOrCreate?: Enumerable<organismsCreateOrConnectWithoutTaxon_groupsInput>
    upsert?: Enumerable<organismsUpsertWithWhereUniqueWithoutTaxon_groupsInput>
    createMany?: organismsCreateManyTaxon_groupsInputEnvelope
    set?: Enumerable<organismsWhereUniqueInput>
    disconnect?: Enumerable<organismsWhereUniqueInput>
    delete?: Enumerable<organismsWhereUniqueInput>
    connect?: Enumerable<organismsWhereUniqueInput>
    update?: Enumerable<organismsUpdateWithWhereUniqueWithoutTaxon_groupsInput>
    updateMany?: Enumerable<organismsUpdateManyWithWhereWithoutTaxon_groupsInput>
    deleteMany?: Enumerable<organismsScalarWhereInput>
  }

  export type organismsCreateNestedOneWithoutUnverified_sightingsInput = {
    create?: XOR<organismsCreateWithoutUnverified_sightingsInput, organismsUncheckedCreateWithoutUnverified_sightingsInput>
    connectOrCreate?: organismsCreateOrConnectWithoutUnverified_sightingsInput
    connect?: organismsWhereUniqueInput
  }

  export type reactionsCreateNestedOneWithoutUnverified_sightingsInput = {
    create?: XOR<reactionsCreateWithoutUnverified_sightingsInput, reactionsUncheckedCreateWithoutUnverified_sightingsInput>
    connectOrCreate?: reactionsCreateOrConnectWithoutUnverified_sightingsInput
    connect?: reactionsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUnverified_sightingsInput = {
    create?: XOR<usersCreateWithoutUnverified_sightingsInput, usersUncheckedCreateWithoutUnverified_sightingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUnverified_sightingsInput
    connect?: usersWhereUniqueInput
  }

  export type user_votesCreateNestedOneWithoutUnverified_sightingsInput = {
    create?: XOR<user_votesCreateWithoutUnverified_sightingsInput, user_votesUncheckedCreateWithoutUnverified_sightingsInput>
    connectOrCreate?: user_votesCreateOrConnectWithoutUnverified_sightingsInput
    connect?: user_votesWhereUniqueInput
  }

  export type organismsUpdateOneRequiredWithoutUnverified_sightingsNestedInput = {
    create?: XOR<organismsCreateWithoutUnverified_sightingsInput, organismsUncheckedCreateWithoutUnverified_sightingsInput>
    connectOrCreate?: organismsCreateOrConnectWithoutUnverified_sightingsInput
    upsert?: organismsUpsertWithoutUnverified_sightingsInput
    connect?: organismsWhereUniqueInput
    update?: XOR<organismsUpdateWithoutUnverified_sightingsInput, organismsUncheckedUpdateWithoutUnverified_sightingsInput>
  }

  export type reactionsUpdateOneWithoutUnverified_sightingsNestedInput = {
    create?: XOR<reactionsCreateWithoutUnverified_sightingsInput, reactionsUncheckedCreateWithoutUnverified_sightingsInput>
    connectOrCreate?: reactionsCreateOrConnectWithoutUnverified_sightingsInput
    upsert?: reactionsUpsertWithoutUnverified_sightingsInput
    disconnect?: boolean
    delete?: boolean
    connect?: reactionsWhereUniqueInput
    update?: XOR<reactionsUpdateWithoutUnverified_sightingsInput, reactionsUncheckedUpdateWithoutUnverified_sightingsInput>
  }

  export type usersUpdateOneRequiredWithoutUnverified_sightingsNestedInput = {
    create?: XOR<usersCreateWithoutUnverified_sightingsInput, usersUncheckedCreateWithoutUnverified_sightingsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUnverified_sightingsInput
    upsert?: usersUpsertWithoutUnverified_sightingsInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutUnverified_sightingsInput, usersUncheckedUpdateWithoutUnverified_sightingsInput>
  }

  export type user_votesUpdateOneWithoutUnverified_sightingsNestedInput = {
    create?: XOR<user_votesCreateWithoutUnverified_sightingsInput, user_votesUncheckedCreateWithoutUnverified_sightingsInput>
    connectOrCreate?: user_votesCreateOrConnectWithoutUnverified_sightingsInput
    upsert?: user_votesUpsertWithoutUnverified_sightingsInput
    disconnect?: boolean
    delete?: boolean
    connect?: user_votesWhereUniqueInput
    update?: XOR<user_votesUpdateWithoutUnverified_sightingsInput, user_votesUncheckedUpdateWithoutUnverified_sightingsInput>
  }

  export type usersCreateNestedManyWithoutUser_levelsInput = {
    create?: XOR<Enumerable<usersCreateWithoutUser_levelsInput>, Enumerable<usersUncheckedCreateWithoutUser_levelsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutUser_levelsInput>
    createMany?: usersCreateManyUser_levelsInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type usersUncheckedCreateNestedManyWithoutUser_levelsInput = {
    create?: XOR<Enumerable<usersCreateWithoutUser_levelsInput>, Enumerable<usersUncheckedCreateWithoutUser_levelsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutUser_levelsInput>
    createMany?: usersCreateManyUser_levelsInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type usersUpdateManyWithoutUser_levelsNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutUser_levelsInput>, Enumerable<usersUncheckedCreateWithoutUser_levelsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutUser_levelsInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutUser_levelsInput>
    createMany?: usersCreateManyUser_levelsInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutUser_levelsInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutUser_levelsInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type usersUncheckedUpdateManyWithoutUser_levelsNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutUser_levelsInput>, Enumerable<usersUncheckedCreateWithoutUser_levelsInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutUser_levelsInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutUser_levelsInput>
    createMany?: usersCreateManyUser_levelsInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutUser_levelsInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutUser_levelsInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type usersCreateNestedManyWithoutUser_profilesInput = {
    create?: XOR<Enumerable<usersCreateWithoutUser_profilesInput>, Enumerable<usersUncheckedCreateWithoutUser_profilesInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutUser_profilesInput>
    createMany?: usersCreateManyUser_profilesInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type usersUncheckedCreateNestedManyWithoutUser_profilesInput = {
    create?: XOR<Enumerable<usersCreateWithoutUser_profilesInput>, Enumerable<usersUncheckedCreateWithoutUser_profilesInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutUser_profilesInput>
    createMany?: usersCreateManyUser_profilesInputEnvelope
    connect?: Enumerable<usersWhereUniqueInput>
  }

  export type usersUpdateManyWithoutUser_profilesNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutUser_profilesInput>, Enumerable<usersUncheckedCreateWithoutUser_profilesInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutUser_profilesInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutUser_profilesInput>
    createMany?: usersCreateManyUser_profilesInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutUser_profilesInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutUser_profilesInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type usersUncheckedUpdateManyWithoutUser_profilesNestedInput = {
    create?: XOR<Enumerable<usersCreateWithoutUser_profilesInput>, Enumerable<usersUncheckedCreateWithoutUser_profilesInput>>
    connectOrCreate?: Enumerable<usersCreateOrConnectWithoutUser_profilesInput>
    upsert?: Enumerable<usersUpsertWithWhereUniqueWithoutUser_profilesInput>
    createMany?: usersCreateManyUser_profilesInputEnvelope
    set?: Enumerable<usersWhereUniqueInput>
    disconnect?: Enumerable<usersWhereUniqueInput>
    delete?: Enumerable<usersWhereUniqueInput>
    connect?: Enumerable<usersWhereUniqueInput>
    update?: Enumerable<usersUpdateWithWhereUniqueWithoutUser_profilesInput>
    updateMany?: Enumerable<usersUpdateManyWithWhereWithoutUser_profilesInput>
    deleteMany?: Enumerable<usersScalarWhereInput>
  }

  export type reactionsCreateNestedOneWithoutUser_to_reactionInput = {
    create?: XOR<reactionsCreateWithoutUser_to_reactionInput, reactionsUncheckedCreateWithoutUser_to_reactionInput>
    connectOrCreate?: reactionsCreateOrConnectWithoutUser_to_reactionInput
    connect?: reactionsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUser_to_reactionInput = {
    create?: XOR<usersCreateWithoutUser_to_reactionInput, usersUncheckedCreateWithoutUser_to_reactionInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_to_reactionInput
    connect?: usersWhereUniqueInput
  }

  export type reactionsUpdateOneRequiredWithoutUser_to_reactionNestedInput = {
    create?: XOR<reactionsCreateWithoutUser_to_reactionInput, reactionsUncheckedCreateWithoutUser_to_reactionInput>
    connectOrCreate?: reactionsCreateOrConnectWithoutUser_to_reactionInput
    upsert?: reactionsUpsertWithoutUser_to_reactionInput
    connect?: reactionsWhereUniqueInput
    update?: XOR<reactionsUpdateWithoutUser_to_reactionInput, reactionsUncheckedUpdateWithoutUser_to_reactionInput>
  }

  export type usersUpdateOneRequiredWithoutUser_to_reactionNestedInput = {
    create?: XOR<usersCreateWithoutUser_to_reactionInput, usersUncheckedCreateWithoutUser_to_reactionInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_to_reactionInput
    upsert?: usersUpsertWithoutUser_to_reactionInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutUser_to_reactionInput, usersUncheckedUpdateWithoutUser_to_reactionInput>
  }

  export type usersCreateNestedOneWithoutUser_votesInput = {
    create?: XOR<usersCreateWithoutUser_votesInput, usersUncheckedCreateWithoutUser_votesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_votesInput
    connect?: usersWhereUniqueInput
  }

  export type unverified_sightingsCreateNestedManyWithoutUser_votesInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutUser_votesInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutUser_votesInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutUser_votesInput>
    createMany?: unverified_sightingsCreateManyUser_votesInputEnvelope
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
  }

  export type unverified_sightingsUncheckedCreateNestedManyWithoutUser_votesInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutUser_votesInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutUser_votesInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutUser_votesInput>
    createMany?: unverified_sightingsCreateManyUser_votesInputEnvelope
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
  }

  export type usersUpdateOneRequiredWithoutUser_votesNestedInput = {
    create?: XOR<usersCreateWithoutUser_votesInput, usersUncheckedCreateWithoutUser_votesInput>
    connectOrCreate?: usersCreateOrConnectWithoutUser_votesInput
    upsert?: usersUpsertWithoutUser_votesInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutUser_votesInput, usersUncheckedUpdateWithoutUser_votesInput>
  }

  export type unverified_sightingsUpdateManyWithoutUser_votesNestedInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutUser_votesInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutUser_votesInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutUser_votesInput>
    upsert?: Enumerable<unverified_sightingsUpsertWithWhereUniqueWithoutUser_votesInput>
    createMany?: unverified_sightingsCreateManyUser_votesInputEnvelope
    set?: Enumerable<unverified_sightingsWhereUniqueInput>
    disconnect?: Enumerable<unverified_sightingsWhereUniqueInput>
    delete?: Enumerable<unverified_sightingsWhereUniqueInput>
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
    update?: Enumerable<unverified_sightingsUpdateWithWhereUniqueWithoutUser_votesInput>
    updateMany?: Enumerable<unverified_sightingsUpdateManyWithWhereWithoutUser_votesInput>
    deleteMany?: Enumerable<unverified_sightingsScalarWhereInput>
  }

  export type unverified_sightingsUncheckedUpdateManyWithoutUser_votesNestedInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutUser_votesInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutUser_votesInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutUser_votesInput>
    upsert?: Enumerable<unverified_sightingsUpsertWithWhereUniqueWithoutUser_votesInput>
    createMany?: unverified_sightingsCreateManyUser_votesInputEnvelope
    set?: Enumerable<unverified_sightingsWhereUniqueInput>
    disconnect?: Enumerable<unverified_sightingsWhereUniqueInput>
    delete?: Enumerable<unverified_sightingsWhereUniqueInput>
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
    update?: Enumerable<unverified_sightingsUpdateWithWhereUniqueWithoutUser_votesInput>
    updateMany?: Enumerable<unverified_sightingsUpdateManyWithWhereWithoutUser_votesInput>
    deleteMany?: Enumerable<unverified_sightingsScalarWhereInput>
  }

  export type user_levelsCreateNestedOneWithoutUsersInput = {
    create?: XOR<user_levelsCreateWithoutUsersInput, user_levelsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_levelsCreateOrConnectWithoutUsersInput
    connect?: user_levelsWhereUniqueInput
  }

  export type user_profilesCreateNestedOneWithoutUsersInput = {
    create?: XOR<user_profilesCreateWithoutUsersInput, user_profilesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_profilesCreateOrConnectWithoutUsersInput
    connect?: user_profilesWhereUniqueInput
  }

  export type confirmed_sightingsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<confirmed_sightingsCreateWithoutUsersInput>, Enumerable<confirmed_sightingsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<confirmed_sightingsCreateOrConnectWithoutUsersInput>
    createMany?: confirmed_sightingsCreateManyUsersInputEnvelope
    connect?: Enumerable<confirmed_sightingsWhereUniqueInput>
  }

  export type unverified_sightingsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutUsersInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutUsersInput>
    createMany?: unverified_sightingsCreateManyUsersInputEnvelope
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
  }

  export type user_to_reactionCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<user_to_reactionCreateWithoutUsersInput>, Enumerable<user_to_reactionUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<user_to_reactionCreateOrConnectWithoutUsersInput>
    createMany?: user_to_reactionCreateManyUsersInputEnvelope
    connect?: Enumerable<user_to_reactionWhereUniqueInput>
  }

  export type user_votesCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<user_votesCreateWithoutUsersInput>, Enumerable<user_votesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<user_votesCreateOrConnectWithoutUsersInput>
    createMany?: user_votesCreateManyUsersInputEnvelope
    connect?: Enumerable<user_votesWhereUniqueInput>
  }

  export type users_to_groupsCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<users_to_groupsCreateWithoutUsersInput>, Enumerable<users_to_groupsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<users_to_groupsCreateOrConnectWithoutUsersInput>
    createMany?: users_to_groupsCreateManyUsersInputEnvelope
    connect?: Enumerable<users_to_groupsWhereUniqueInput>
  }

  export type confirmed_sightingsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<confirmed_sightingsCreateWithoutUsersInput>, Enumerable<confirmed_sightingsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<confirmed_sightingsCreateOrConnectWithoutUsersInput>
    createMany?: confirmed_sightingsCreateManyUsersInputEnvelope
    connect?: Enumerable<confirmed_sightingsWhereUniqueInput>
  }

  export type unverified_sightingsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutUsersInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutUsersInput>
    createMany?: unverified_sightingsCreateManyUsersInputEnvelope
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
  }

  export type user_to_reactionUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<user_to_reactionCreateWithoutUsersInput>, Enumerable<user_to_reactionUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<user_to_reactionCreateOrConnectWithoutUsersInput>
    createMany?: user_to_reactionCreateManyUsersInputEnvelope
    connect?: Enumerable<user_to_reactionWhereUniqueInput>
  }

  export type user_votesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<user_votesCreateWithoutUsersInput>, Enumerable<user_votesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<user_votesCreateOrConnectWithoutUsersInput>
    createMany?: user_votesCreateManyUsersInputEnvelope
    connect?: Enumerable<user_votesWhereUniqueInput>
  }

  export type users_to_groupsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<Enumerable<users_to_groupsCreateWithoutUsersInput>, Enumerable<users_to_groupsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<users_to_groupsCreateOrConnectWithoutUsersInput>
    createMany?: users_to_groupsCreateManyUsersInputEnvelope
    connect?: Enumerable<users_to_groupsWhereUniqueInput>
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type user_levelsUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<user_levelsCreateWithoutUsersInput, user_levelsUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_levelsCreateOrConnectWithoutUsersInput
    upsert?: user_levelsUpsertWithoutUsersInput
    connect?: user_levelsWhereUniqueInput
    update?: XOR<user_levelsUpdateWithoutUsersInput, user_levelsUncheckedUpdateWithoutUsersInput>
  }

  export type user_profilesUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<user_profilesCreateWithoutUsersInput, user_profilesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: user_profilesCreateOrConnectWithoutUsersInput
    upsert?: user_profilesUpsertWithoutUsersInput
    connect?: user_profilesWhereUniqueInput
    update?: XOR<user_profilesUpdateWithoutUsersInput, user_profilesUncheckedUpdateWithoutUsersInput>
  }

  export type confirmed_sightingsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<confirmed_sightingsCreateWithoutUsersInput>, Enumerable<confirmed_sightingsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<confirmed_sightingsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<confirmed_sightingsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: confirmed_sightingsCreateManyUsersInputEnvelope
    set?: Enumerable<confirmed_sightingsWhereUniqueInput>
    disconnect?: Enumerable<confirmed_sightingsWhereUniqueInput>
    delete?: Enumerable<confirmed_sightingsWhereUniqueInput>
    connect?: Enumerable<confirmed_sightingsWhereUniqueInput>
    update?: Enumerable<confirmed_sightingsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<confirmed_sightingsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<confirmed_sightingsScalarWhereInput>
  }

  export type unverified_sightingsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutUsersInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<unverified_sightingsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: unverified_sightingsCreateManyUsersInputEnvelope
    set?: Enumerable<unverified_sightingsWhereUniqueInput>
    disconnect?: Enumerable<unverified_sightingsWhereUniqueInput>
    delete?: Enumerable<unverified_sightingsWhereUniqueInput>
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
    update?: Enumerable<unverified_sightingsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<unverified_sightingsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<unverified_sightingsScalarWhereInput>
  }

  export type user_to_reactionUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<user_to_reactionCreateWithoutUsersInput>, Enumerable<user_to_reactionUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<user_to_reactionCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<user_to_reactionUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: user_to_reactionCreateManyUsersInputEnvelope
    set?: Enumerable<user_to_reactionWhereUniqueInput>
    disconnect?: Enumerable<user_to_reactionWhereUniqueInput>
    delete?: Enumerable<user_to_reactionWhereUniqueInput>
    connect?: Enumerable<user_to_reactionWhereUniqueInput>
    update?: Enumerable<user_to_reactionUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<user_to_reactionUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<user_to_reactionScalarWhereInput>
  }

  export type user_votesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<user_votesCreateWithoutUsersInput>, Enumerable<user_votesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<user_votesCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<user_votesUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: user_votesCreateManyUsersInputEnvelope
    set?: Enumerable<user_votesWhereUniqueInput>
    disconnect?: Enumerable<user_votesWhereUniqueInput>
    delete?: Enumerable<user_votesWhereUniqueInput>
    connect?: Enumerable<user_votesWhereUniqueInput>
    update?: Enumerable<user_votesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<user_votesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<user_votesScalarWhereInput>
  }

  export type users_to_groupsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<users_to_groupsCreateWithoutUsersInput>, Enumerable<users_to_groupsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<users_to_groupsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<users_to_groupsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: users_to_groupsCreateManyUsersInputEnvelope
    set?: Enumerable<users_to_groupsWhereUniqueInput>
    disconnect?: Enumerable<users_to_groupsWhereUniqueInput>
    delete?: Enumerable<users_to_groupsWhereUniqueInput>
    connect?: Enumerable<users_to_groupsWhereUniqueInput>
    update?: Enumerable<users_to_groupsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<users_to_groupsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<users_to_groupsScalarWhereInput>
  }

  export type confirmed_sightingsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<confirmed_sightingsCreateWithoutUsersInput>, Enumerable<confirmed_sightingsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<confirmed_sightingsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<confirmed_sightingsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: confirmed_sightingsCreateManyUsersInputEnvelope
    set?: Enumerable<confirmed_sightingsWhereUniqueInput>
    disconnect?: Enumerable<confirmed_sightingsWhereUniqueInput>
    delete?: Enumerable<confirmed_sightingsWhereUniqueInput>
    connect?: Enumerable<confirmed_sightingsWhereUniqueInput>
    update?: Enumerable<confirmed_sightingsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<confirmed_sightingsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<confirmed_sightingsScalarWhereInput>
  }

  export type unverified_sightingsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<unverified_sightingsCreateWithoutUsersInput>, Enumerable<unverified_sightingsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<unverified_sightingsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<unverified_sightingsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: unverified_sightingsCreateManyUsersInputEnvelope
    set?: Enumerable<unverified_sightingsWhereUniqueInput>
    disconnect?: Enumerable<unverified_sightingsWhereUniqueInput>
    delete?: Enumerable<unverified_sightingsWhereUniqueInput>
    connect?: Enumerable<unverified_sightingsWhereUniqueInput>
    update?: Enumerable<unverified_sightingsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<unverified_sightingsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<unverified_sightingsScalarWhereInput>
  }

  export type user_to_reactionUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<user_to_reactionCreateWithoutUsersInput>, Enumerable<user_to_reactionUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<user_to_reactionCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<user_to_reactionUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: user_to_reactionCreateManyUsersInputEnvelope
    set?: Enumerable<user_to_reactionWhereUniqueInput>
    disconnect?: Enumerable<user_to_reactionWhereUniqueInput>
    delete?: Enumerable<user_to_reactionWhereUniqueInput>
    connect?: Enumerable<user_to_reactionWhereUniqueInput>
    update?: Enumerable<user_to_reactionUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<user_to_reactionUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<user_to_reactionScalarWhereInput>
  }

  export type user_votesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<user_votesCreateWithoutUsersInput>, Enumerable<user_votesUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<user_votesCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<user_votesUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: user_votesCreateManyUsersInputEnvelope
    set?: Enumerable<user_votesWhereUniqueInput>
    disconnect?: Enumerable<user_votesWhereUniqueInput>
    delete?: Enumerable<user_votesWhereUniqueInput>
    connect?: Enumerable<user_votesWhereUniqueInput>
    update?: Enumerable<user_votesUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<user_votesUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<user_votesScalarWhereInput>
  }

  export type users_to_groupsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<Enumerable<users_to_groupsCreateWithoutUsersInput>, Enumerable<users_to_groupsUncheckedCreateWithoutUsersInput>>
    connectOrCreate?: Enumerable<users_to_groupsCreateOrConnectWithoutUsersInput>
    upsert?: Enumerable<users_to_groupsUpsertWithWhereUniqueWithoutUsersInput>
    createMany?: users_to_groupsCreateManyUsersInputEnvelope
    set?: Enumerable<users_to_groupsWhereUniqueInput>
    disconnect?: Enumerable<users_to_groupsWhereUniqueInput>
    delete?: Enumerable<users_to_groupsWhereUniqueInput>
    connect?: Enumerable<users_to_groupsWhereUniqueInput>
    update?: Enumerable<users_to_groupsUpdateWithWhereUniqueWithoutUsersInput>
    updateMany?: Enumerable<users_to_groupsUpdateManyWithWhereWithoutUsersInput>
    deleteMany?: Enumerable<users_to_groupsScalarWhereInput>
  }

  export type interest_groupsCreateNestedOneWithoutUsers_to_groupsInput = {
    create?: XOR<interest_groupsCreateWithoutUsers_to_groupsInput, interest_groupsUncheckedCreateWithoutUsers_to_groupsInput>
    connectOrCreate?: interest_groupsCreateOrConnectWithoutUsers_to_groupsInput
    connect?: interest_groupsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutUsers_to_groupsInput = {
    create?: XOR<usersCreateWithoutUsers_to_groupsInput, usersUncheckedCreateWithoutUsers_to_groupsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUsers_to_groupsInput
    connect?: usersWhereUniqueInput
  }

  export type interest_groupsUpdateOneRequiredWithoutUsers_to_groupsNestedInput = {
    create?: XOR<interest_groupsCreateWithoutUsers_to_groupsInput, interest_groupsUncheckedCreateWithoutUsers_to_groupsInput>
    connectOrCreate?: interest_groupsCreateOrConnectWithoutUsers_to_groupsInput
    upsert?: interest_groupsUpsertWithoutUsers_to_groupsInput
    connect?: interest_groupsWhereUniqueInput
    update?: XOR<interest_groupsUpdateWithoutUsers_to_groupsInput, interest_groupsUncheckedUpdateWithoutUsers_to_groupsInput>
  }

  export type usersUpdateOneRequiredWithoutUsers_to_groupsNestedInput = {
    create?: XOR<usersCreateWithoutUsers_to_groupsInput, usersUncheckedCreateWithoutUsers_to_groupsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUsers_to_groupsInput
    upsert?: usersUpsertWithoutUsers_to_groupsInput
    connect?: usersWhereUniqueInput
    update?: XOR<usersUpdateWithoutUsers_to_groupsInput, usersUncheckedUpdateWithoutUsers_to_groupsInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedDecimalFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string>
    notIn?: Enumerable<Date> | Enumerable<string>
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedDecimalWithAggregatesFilter = {
    equals?: Decimal | DecimalJsLike | number | string
    in?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    notIn?: Enumerable<Decimal> | Enumerable<DecimalJsLike> | Enumerable<number> | Enumerable<string>
    lt?: Decimal | DecimalJsLike | number | string
    lte?: Decimal | DecimalJsLike | number | string
    gt?: Decimal | DecimalJsLike | number | string
    gte?: Decimal | DecimalJsLike | number | string
    not?: NestedDecimalWithAggregatesFilter | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter
    _avg?: NestedDecimalFilter
    _sum?: NestedDecimalFilter
    _min?: NestedDecimalFilter
    _max?: NestedDecimalFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type NestedBoolNullableFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableFilter | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter = {
    equals?: boolean | null
    not?: NestedBoolNullableWithAggregatesFilter | boolean | null
    _count?: NestedIntNullableFilter
    _min?: NestedBoolNullableFilter
    _max?: NestedBoolNullableFilter
  }

  export type organismsCreateWithoutConfirmed_sightingsInput = {
    taxon_name: string
    latin_name: string
    picture_url?: string | null
    description?: string | null
    taxon_groups: taxon_groupsCreateNestedOneWithoutOrganismsInput
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutOrganismsInput
  }

  export type organismsUncheckedCreateWithoutConfirmed_sightingsInput = {
    id?: number
    taxon_name: string
    latin_name: string
    taxon_group_id: number
    picture_url?: string | null
    description?: string | null
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutOrganismsInput
  }

  export type organismsCreateOrConnectWithoutConfirmed_sightingsInput = {
    where: organismsWhereUniqueInput
    create: XOR<organismsCreateWithoutConfirmed_sightingsInput, organismsUncheckedCreateWithoutConfirmed_sightingsInput>
  }

  export type usersCreateWithoutConfirmed_sightingsInput = {
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_levels: user_levelsCreateNestedOneWithoutUsersInput
    user_profiles: user_profilesCreateNestedOneWithoutUsersInput
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionCreateNestedManyWithoutUsersInput
    user_votes?: user_votesCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutConfirmed_sightingsInput = {
    id?: number
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_level_id: number
    user_profile_id: number
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionUncheckedCreateNestedManyWithoutUsersInput
    user_votes?: user_votesUncheckedCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutConfirmed_sightingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutConfirmed_sightingsInput, usersUncheckedCreateWithoutConfirmed_sightingsInput>
  }

  export type organismsUpsertWithoutConfirmed_sightingsInput = {
    update: XOR<organismsUpdateWithoutConfirmed_sightingsInput, organismsUncheckedUpdateWithoutConfirmed_sightingsInput>
    create: XOR<organismsCreateWithoutConfirmed_sightingsInput, organismsUncheckedCreateWithoutConfirmed_sightingsInput>
  }

  export type organismsUpdateWithoutConfirmed_sightingsInput = {
    taxon_name?: StringFieldUpdateOperationsInput | string
    latin_name?: StringFieldUpdateOperationsInput | string
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taxon_groups?: taxon_groupsUpdateOneRequiredWithoutOrganismsNestedInput
    unverified_sightings?: unverified_sightingsUpdateManyWithoutOrganismsNestedInput
  }

  export type organismsUncheckedUpdateWithoutConfirmed_sightingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    taxon_name?: StringFieldUpdateOperationsInput | string
    latin_name?: StringFieldUpdateOperationsInput | string
    taxon_group_id?: IntFieldUpdateOperationsInput | number
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutOrganismsNestedInput
  }

  export type usersUpsertWithoutConfirmed_sightingsInput = {
    update: XOR<usersUpdateWithoutConfirmed_sightingsInput, usersUncheckedUpdateWithoutConfirmed_sightingsInput>
    create: XOR<usersCreateWithoutConfirmed_sightingsInput, usersUncheckedCreateWithoutConfirmed_sightingsInput>
  }

  export type usersUpdateWithoutConfirmed_sightingsInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_levels?: user_levelsUpdateOneRequiredWithoutUsersNestedInput
    user_profiles?: user_profilesUpdateOneRequiredWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutConfirmed_sightingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_level_id?: IntFieldUpdateOperationsInput | number
    user_profile_id?: IntFieldUpdateOperationsInput | number
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUncheckedUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUncheckedUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type users_to_groupsCreateWithoutInterest_groupsInput = {
    users: usersCreateNestedOneWithoutUsers_to_groupsInput
  }

  export type users_to_groupsUncheckedCreateWithoutInterest_groupsInput = {
    id?: number
    user_id: number
  }

  export type users_to_groupsCreateOrConnectWithoutInterest_groupsInput = {
    where: users_to_groupsWhereUniqueInput
    create: XOR<users_to_groupsCreateWithoutInterest_groupsInput, users_to_groupsUncheckedCreateWithoutInterest_groupsInput>
  }

  export type users_to_groupsCreateManyInterest_groupsInputEnvelope = {
    data: Enumerable<users_to_groupsCreateManyInterest_groupsInput>
    skipDuplicates?: boolean
  }

  export type users_to_groupsUpsertWithWhereUniqueWithoutInterest_groupsInput = {
    where: users_to_groupsWhereUniqueInput
    update: XOR<users_to_groupsUpdateWithoutInterest_groupsInput, users_to_groupsUncheckedUpdateWithoutInterest_groupsInput>
    create: XOR<users_to_groupsCreateWithoutInterest_groupsInput, users_to_groupsUncheckedCreateWithoutInterest_groupsInput>
  }

  export type users_to_groupsUpdateWithWhereUniqueWithoutInterest_groupsInput = {
    where: users_to_groupsWhereUniqueInput
    data: XOR<users_to_groupsUpdateWithoutInterest_groupsInput, users_to_groupsUncheckedUpdateWithoutInterest_groupsInput>
  }

  export type users_to_groupsUpdateManyWithWhereWithoutInterest_groupsInput = {
    where: users_to_groupsScalarWhereInput
    data: XOR<users_to_groupsUpdateManyMutationInput, users_to_groupsUncheckedUpdateManyWithoutUsers_to_groupsInput>
  }

  export type users_to_groupsScalarWhereInput = {
    AND?: Enumerable<users_to_groupsScalarWhereInput>
    OR?: Enumerable<users_to_groupsScalarWhereInput>
    NOT?: Enumerable<users_to_groupsScalarWhereInput>
    id?: IntFilter | number
    group_id?: IntFilter | number
    user_id?: IntFilter | number
  }

  export type taxon_groupsCreateWithoutOrganismsInput = {
    taxon_group_name: string
    description?: string | null
  }

  export type taxon_groupsUncheckedCreateWithoutOrganismsInput = {
    id?: number
    taxon_group_name: string
    description?: string | null
  }

  export type taxon_groupsCreateOrConnectWithoutOrganismsInput = {
    where: taxon_groupsWhereUniqueInput
    create: XOR<taxon_groupsCreateWithoutOrganismsInput, taxon_groupsUncheckedCreateWithoutOrganismsInput>
  }

  export type confirmed_sightingsCreateWithoutOrganismsInput = {
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    users: usersCreateNestedOneWithoutConfirmed_sightingsInput
  }

  export type confirmed_sightingsUncheckedCreateWithoutOrganismsInput = {
    id?: number
    user_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
  }

  export type confirmed_sightingsCreateOrConnectWithoutOrganismsInput = {
    where: confirmed_sightingsWhereUniqueInput
    create: XOR<confirmed_sightingsCreateWithoutOrganismsInput, confirmed_sightingsUncheckedCreateWithoutOrganismsInput>
  }

  export type confirmed_sightingsCreateManyOrganismsInputEnvelope = {
    data: Enumerable<confirmed_sightingsCreateManyOrganismsInput>
    skipDuplicates?: boolean
  }

  export type unverified_sightingsCreateWithoutOrganismsInput = {
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    reactions?: reactionsCreateNestedOneWithoutUnverified_sightingsInput
    users: usersCreateNestedOneWithoutUnverified_sightingsInput
    user_votes?: user_votesCreateNestedOneWithoutUnverified_sightingsInput
  }

  export type unverified_sightingsUncheckedCreateWithoutOrganismsInput = {
    id?: number
    user_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    user_vote_id?: number | null
    reaction_id?: number | null
  }

  export type unverified_sightingsCreateOrConnectWithoutOrganismsInput = {
    where: unverified_sightingsWhereUniqueInput
    create: XOR<unverified_sightingsCreateWithoutOrganismsInput, unverified_sightingsUncheckedCreateWithoutOrganismsInput>
  }

  export type unverified_sightingsCreateManyOrganismsInputEnvelope = {
    data: Enumerable<unverified_sightingsCreateManyOrganismsInput>
    skipDuplicates?: boolean
  }

  export type taxon_groupsUpsertWithoutOrganismsInput = {
    update: XOR<taxon_groupsUpdateWithoutOrganismsInput, taxon_groupsUncheckedUpdateWithoutOrganismsInput>
    create: XOR<taxon_groupsCreateWithoutOrganismsInput, taxon_groupsUncheckedCreateWithoutOrganismsInput>
  }

  export type taxon_groupsUpdateWithoutOrganismsInput = {
    taxon_group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type taxon_groupsUncheckedUpdateWithoutOrganismsInput = {
    id?: IntFieldUpdateOperationsInput | number
    taxon_group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type confirmed_sightingsUpsertWithWhereUniqueWithoutOrganismsInput = {
    where: confirmed_sightingsWhereUniqueInput
    update: XOR<confirmed_sightingsUpdateWithoutOrganismsInput, confirmed_sightingsUncheckedUpdateWithoutOrganismsInput>
    create: XOR<confirmed_sightingsCreateWithoutOrganismsInput, confirmed_sightingsUncheckedCreateWithoutOrganismsInput>
  }

  export type confirmed_sightingsUpdateWithWhereUniqueWithoutOrganismsInput = {
    where: confirmed_sightingsWhereUniqueInput
    data: XOR<confirmed_sightingsUpdateWithoutOrganismsInput, confirmed_sightingsUncheckedUpdateWithoutOrganismsInput>
  }

  export type confirmed_sightingsUpdateManyWithWhereWithoutOrganismsInput = {
    where: confirmed_sightingsScalarWhereInput
    data: XOR<confirmed_sightingsUpdateManyMutationInput, confirmed_sightingsUncheckedUpdateManyWithoutConfirmed_sightingsInput>
  }

  export type confirmed_sightingsScalarWhereInput = {
    AND?: Enumerable<confirmed_sightingsScalarWhereInput>
    OR?: Enumerable<confirmed_sightingsScalarWhereInput>
    NOT?: Enumerable<confirmed_sightingsScalarWhereInput>
    id?: IntFilter | number
    organism_id?: IntFilter | number
    user_id?: IntFilter | number
    picture_url?: StringFilter | string
    date?: DateTimeFilter | Date | string
    lat?: DecimalFilter | Decimal | DecimalJsLike | number | string
    long?: DecimalFilter | Decimal | DecimalJsLike | number | string
  }

  export type unverified_sightingsUpsertWithWhereUniqueWithoutOrganismsInput = {
    where: unverified_sightingsWhereUniqueInput
    update: XOR<unverified_sightingsUpdateWithoutOrganismsInput, unverified_sightingsUncheckedUpdateWithoutOrganismsInput>
    create: XOR<unverified_sightingsCreateWithoutOrganismsInput, unverified_sightingsUncheckedCreateWithoutOrganismsInput>
  }

  export type unverified_sightingsUpdateWithWhereUniqueWithoutOrganismsInput = {
    where: unverified_sightingsWhereUniqueInput
    data: XOR<unverified_sightingsUpdateWithoutOrganismsInput, unverified_sightingsUncheckedUpdateWithoutOrganismsInput>
  }

  export type unverified_sightingsUpdateManyWithWhereWithoutOrganismsInput = {
    where: unverified_sightingsScalarWhereInput
    data: XOR<unverified_sightingsUpdateManyMutationInput, unverified_sightingsUncheckedUpdateManyWithoutUnverified_sightingsInput>
  }

  export type unverified_sightingsScalarWhereInput = {
    AND?: Enumerable<unverified_sightingsScalarWhereInput>
    OR?: Enumerable<unverified_sightingsScalarWhereInput>
    NOT?: Enumerable<unverified_sightingsScalarWhereInput>
    id?: IntFilter | number
    organism_id?: IntFilter | number
    user_id?: IntFilter | number
    picture_url?: StringFilter | string
    date?: DateTimeFilter | Date | string
    lat?: DecimalFilter | Decimal | DecimalJsLike | number | string
    long?: DecimalFilter | Decimal | DecimalJsLike | number | string
    user_vote_id?: IntNullableFilter | number | null
    reaction_id?: IntNullableFilter | number | null
  }

  export type unverified_sightingsCreateWithoutReactionsInput = {
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    organisms: organismsCreateNestedOneWithoutUnverified_sightingsInput
    users: usersCreateNestedOneWithoutUnverified_sightingsInput
    user_votes?: user_votesCreateNestedOneWithoutUnverified_sightingsInput
  }

  export type unverified_sightingsUncheckedCreateWithoutReactionsInput = {
    id?: number
    organism_id: number
    user_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    user_vote_id?: number | null
  }

  export type unverified_sightingsCreateOrConnectWithoutReactionsInput = {
    where: unverified_sightingsWhereUniqueInput
    create: XOR<unverified_sightingsCreateWithoutReactionsInput, unverified_sightingsUncheckedCreateWithoutReactionsInput>
  }

  export type unverified_sightingsCreateManyReactionsInputEnvelope = {
    data: Enumerable<unverified_sightingsCreateManyReactionsInput>
    skipDuplicates?: boolean
  }

  export type user_to_reactionCreateWithoutReactionsInput = {
    users: usersCreateNestedOneWithoutUser_to_reactionInput
  }

  export type user_to_reactionUncheckedCreateWithoutReactionsInput = {
    id?: number
    user_id: number
  }

  export type user_to_reactionCreateOrConnectWithoutReactionsInput = {
    where: user_to_reactionWhereUniqueInput
    create: XOR<user_to_reactionCreateWithoutReactionsInput, user_to_reactionUncheckedCreateWithoutReactionsInput>
  }

  export type user_to_reactionCreateManyReactionsInputEnvelope = {
    data: Enumerable<user_to_reactionCreateManyReactionsInput>
    skipDuplicates?: boolean
  }

  export type unverified_sightingsUpsertWithWhereUniqueWithoutReactionsInput = {
    where: unverified_sightingsWhereUniqueInput
    update: XOR<unverified_sightingsUpdateWithoutReactionsInput, unverified_sightingsUncheckedUpdateWithoutReactionsInput>
    create: XOR<unverified_sightingsCreateWithoutReactionsInput, unverified_sightingsUncheckedCreateWithoutReactionsInput>
  }

  export type unverified_sightingsUpdateWithWhereUniqueWithoutReactionsInput = {
    where: unverified_sightingsWhereUniqueInput
    data: XOR<unverified_sightingsUpdateWithoutReactionsInput, unverified_sightingsUncheckedUpdateWithoutReactionsInput>
  }

  export type unverified_sightingsUpdateManyWithWhereWithoutReactionsInput = {
    where: unverified_sightingsScalarWhereInput
    data: XOR<unverified_sightingsUpdateManyMutationInput, unverified_sightingsUncheckedUpdateManyWithoutUnverified_sightingsInput>
  }

  export type user_to_reactionUpsertWithWhereUniqueWithoutReactionsInput = {
    where: user_to_reactionWhereUniqueInput
    update: XOR<user_to_reactionUpdateWithoutReactionsInput, user_to_reactionUncheckedUpdateWithoutReactionsInput>
    create: XOR<user_to_reactionCreateWithoutReactionsInput, user_to_reactionUncheckedCreateWithoutReactionsInput>
  }

  export type user_to_reactionUpdateWithWhereUniqueWithoutReactionsInput = {
    where: user_to_reactionWhereUniqueInput
    data: XOR<user_to_reactionUpdateWithoutReactionsInput, user_to_reactionUncheckedUpdateWithoutReactionsInput>
  }

  export type user_to_reactionUpdateManyWithWhereWithoutReactionsInput = {
    where: user_to_reactionScalarWhereInput
    data: XOR<user_to_reactionUpdateManyMutationInput, user_to_reactionUncheckedUpdateManyWithoutUser_to_reactionInput>
  }

  export type user_to_reactionScalarWhereInput = {
    AND?: Enumerable<user_to_reactionScalarWhereInput>
    OR?: Enumerable<user_to_reactionScalarWhereInput>
    NOT?: Enumerable<user_to_reactionScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    reaction_id?: IntFilter | number
  }

  export type organismsCreateWithoutTaxon_groupsInput = {
    taxon_name: string
    latin_name: string
    picture_url?: string | null
    description?: string | null
    confirmed_sightings?: confirmed_sightingsCreateNestedManyWithoutOrganismsInput
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutOrganismsInput
  }

  export type organismsUncheckedCreateWithoutTaxon_groupsInput = {
    id?: number
    taxon_name: string
    latin_name: string
    picture_url?: string | null
    description?: string | null
    confirmed_sightings?: confirmed_sightingsUncheckedCreateNestedManyWithoutOrganismsInput
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutOrganismsInput
  }

  export type organismsCreateOrConnectWithoutTaxon_groupsInput = {
    where: organismsWhereUniqueInput
    create: XOR<organismsCreateWithoutTaxon_groupsInput, organismsUncheckedCreateWithoutTaxon_groupsInput>
  }

  export type organismsCreateManyTaxon_groupsInputEnvelope = {
    data: Enumerable<organismsCreateManyTaxon_groupsInput>
    skipDuplicates?: boolean
  }

  export type organismsUpsertWithWhereUniqueWithoutTaxon_groupsInput = {
    where: organismsWhereUniqueInput
    update: XOR<organismsUpdateWithoutTaxon_groupsInput, organismsUncheckedUpdateWithoutTaxon_groupsInput>
    create: XOR<organismsCreateWithoutTaxon_groupsInput, organismsUncheckedCreateWithoutTaxon_groupsInput>
  }

  export type organismsUpdateWithWhereUniqueWithoutTaxon_groupsInput = {
    where: organismsWhereUniqueInput
    data: XOR<organismsUpdateWithoutTaxon_groupsInput, organismsUncheckedUpdateWithoutTaxon_groupsInput>
  }

  export type organismsUpdateManyWithWhereWithoutTaxon_groupsInput = {
    where: organismsScalarWhereInput
    data: XOR<organismsUpdateManyMutationInput, organismsUncheckedUpdateManyWithoutOrganismsInput>
  }

  export type organismsScalarWhereInput = {
    AND?: Enumerable<organismsScalarWhereInput>
    OR?: Enumerable<organismsScalarWhereInput>
    NOT?: Enumerable<organismsScalarWhereInput>
    id?: IntFilter | number
    taxon_name?: StringFilter | string
    latin_name?: StringFilter | string
    taxon_group_id?: IntFilter | number
    picture_url?: StringNullableFilter | string | null
    description?: StringNullableFilter | string | null
  }

  export type organismsCreateWithoutUnverified_sightingsInput = {
    taxon_name: string
    latin_name: string
    picture_url?: string | null
    description?: string | null
    taxon_groups: taxon_groupsCreateNestedOneWithoutOrganismsInput
    confirmed_sightings?: confirmed_sightingsCreateNestedManyWithoutOrganismsInput
  }

  export type organismsUncheckedCreateWithoutUnverified_sightingsInput = {
    id?: number
    taxon_name: string
    latin_name: string
    taxon_group_id: number
    picture_url?: string | null
    description?: string | null
    confirmed_sightings?: confirmed_sightingsUncheckedCreateNestedManyWithoutOrganismsInput
  }

  export type organismsCreateOrConnectWithoutUnverified_sightingsInput = {
    where: organismsWhereUniqueInput
    create: XOR<organismsCreateWithoutUnverified_sightingsInput, organismsUncheckedCreateWithoutUnverified_sightingsInput>
  }

  export type reactionsCreateWithoutUnverified_sightingsInput = {
    reaction_name: string
    user_to_reaction?: user_to_reactionCreateNestedManyWithoutReactionsInput
  }

  export type reactionsUncheckedCreateWithoutUnverified_sightingsInput = {
    id?: number
    reaction_name: string
    user_to_reaction?: user_to_reactionUncheckedCreateNestedManyWithoutReactionsInput
  }

  export type reactionsCreateOrConnectWithoutUnverified_sightingsInput = {
    where: reactionsWhereUniqueInput
    create: XOR<reactionsCreateWithoutUnverified_sightingsInput, reactionsUncheckedCreateWithoutUnverified_sightingsInput>
  }

  export type usersCreateWithoutUnverified_sightingsInput = {
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_levels: user_levelsCreateNestedOneWithoutUsersInput
    user_profiles: user_profilesCreateNestedOneWithoutUsersInput
    confirmed_sightings?: confirmed_sightingsCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionCreateNestedManyWithoutUsersInput
    user_votes?: user_votesCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUnverified_sightingsInput = {
    id?: number
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_level_id: number
    user_profile_id: number
    confirmed_sightings?: confirmed_sightingsUncheckedCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionUncheckedCreateNestedManyWithoutUsersInput
    user_votes?: user_votesUncheckedCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUnverified_sightingsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUnverified_sightingsInput, usersUncheckedCreateWithoutUnverified_sightingsInput>
  }

  export type user_votesCreateWithoutUnverified_sightingsInput = {
    user_vote: number
    users: usersCreateNestedOneWithoutUser_votesInput
  }

  export type user_votesUncheckedCreateWithoutUnverified_sightingsInput = {
    id?: number
    user_id: number
    user_vote: number
  }

  export type user_votesCreateOrConnectWithoutUnverified_sightingsInput = {
    where: user_votesWhereUniqueInput
    create: XOR<user_votesCreateWithoutUnverified_sightingsInput, user_votesUncheckedCreateWithoutUnverified_sightingsInput>
  }

  export type organismsUpsertWithoutUnverified_sightingsInput = {
    update: XOR<organismsUpdateWithoutUnverified_sightingsInput, organismsUncheckedUpdateWithoutUnverified_sightingsInput>
    create: XOR<organismsCreateWithoutUnverified_sightingsInput, organismsUncheckedCreateWithoutUnverified_sightingsInput>
  }

  export type organismsUpdateWithoutUnverified_sightingsInput = {
    taxon_name?: StringFieldUpdateOperationsInput | string
    latin_name?: StringFieldUpdateOperationsInput | string
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taxon_groups?: taxon_groupsUpdateOneRequiredWithoutOrganismsNestedInput
    confirmed_sightings?: confirmed_sightingsUpdateManyWithoutOrganismsNestedInput
  }

  export type organismsUncheckedUpdateWithoutUnverified_sightingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    taxon_name?: StringFieldUpdateOperationsInput | string
    latin_name?: StringFieldUpdateOperationsInput | string
    taxon_group_id?: IntFieldUpdateOperationsInput | number
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_sightings?: confirmed_sightingsUncheckedUpdateManyWithoutOrganismsNestedInput
  }

  export type reactionsUpsertWithoutUnverified_sightingsInput = {
    update: XOR<reactionsUpdateWithoutUnverified_sightingsInput, reactionsUncheckedUpdateWithoutUnverified_sightingsInput>
    create: XOR<reactionsCreateWithoutUnverified_sightingsInput, reactionsUncheckedCreateWithoutUnverified_sightingsInput>
  }

  export type reactionsUpdateWithoutUnverified_sightingsInput = {
    reaction_name?: StringFieldUpdateOperationsInput | string
    user_to_reaction?: user_to_reactionUpdateManyWithoutReactionsNestedInput
  }

  export type reactionsUncheckedUpdateWithoutUnverified_sightingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction_name?: StringFieldUpdateOperationsInput | string
    user_to_reaction?: user_to_reactionUncheckedUpdateManyWithoutReactionsNestedInput
  }

  export type usersUpsertWithoutUnverified_sightingsInput = {
    update: XOR<usersUpdateWithoutUnverified_sightingsInput, usersUncheckedUpdateWithoutUnverified_sightingsInput>
    create: XOR<usersCreateWithoutUnverified_sightingsInput, usersUncheckedCreateWithoutUnverified_sightingsInput>
  }

  export type usersUpdateWithoutUnverified_sightingsInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_levels?: user_levelsUpdateOneRequiredWithoutUsersNestedInput
    user_profiles?: user_profilesUpdateOneRequiredWithoutUsersNestedInput
    confirmed_sightings?: confirmed_sightingsUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUnverified_sightingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_level_id?: IntFieldUpdateOperationsInput | number
    user_profile_id?: IntFieldUpdateOperationsInput | number
    confirmed_sightings?: confirmed_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUncheckedUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUncheckedUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type user_votesUpsertWithoutUnverified_sightingsInput = {
    update: XOR<user_votesUpdateWithoutUnverified_sightingsInput, user_votesUncheckedUpdateWithoutUnverified_sightingsInput>
    create: XOR<user_votesCreateWithoutUnverified_sightingsInput, user_votesUncheckedCreateWithoutUnverified_sightingsInput>
  }

  export type user_votesUpdateWithoutUnverified_sightingsInput = {
    user_vote?: IntFieldUpdateOperationsInput | number
    users?: usersUpdateOneRequiredWithoutUser_votesNestedInput
  }

  export type user_votesUncheckedUpdateWithoutUnverified_sightingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    user_vote?: IntFieldUpdateOperationsInput | number
  }

  export type usersCreateWithoutUser_levelsInput = {
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_profiles: user_profilesCreateNestedOneWithoutUsersInput
    confirmed_sightings?: confirmed_sightingsCreateNestedManyWithoutUsersInput
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionCreateNestedManyWithoutUsersInput
    user_votes?: user_votesCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_levelsInput = {
    id?: number
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_profile_id: number
    confirmed_sightings?: confirmed_sightingsUncheckedCreateNestedManyWithoutUsersInput
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionUncheckedCreateNestedManyWithoutUsersInput
    user_votes?: user_votesUncheckedCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_levelsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_levelsInput, usersUncheckedCreateWithoutUser_levelsInput>
  }

  export type usersCreateManyUser_levelsInputEnvelope = {
    data: Enumerable<usersCreateManyUser_levelsInput>
    skipDuplicates?: boolean
  }

  export type usersUpsertWithWhereUniqueWithoutUser_levelsInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutUser_levelsInput, usersUncheckedUpdateWithoutUser_levelsInput>
    create: XOR<usersCreateWithoutUser_levelsInput, usersUncheckedCreateWithoutUser_levelsInput>
  }

  export type usersUpdateWithWhereUniqueWithoutUser_levelsInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutUser_levelsInput, usersUncheckedUpdateWithoutUser_levelsInput>
  }

  export type usersUpdateManyWithWhereWithoutUser_levelsInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type usersScalarWhereInput = {
    AND?: Enumerable<usersScalarWhereInput>
    OR?: Enumerable<usersScalarWhereInput>
    NOT?: Enumerable<usersScalarWhereInput>
    id?: IntFilter | number
    user_name?: StringFilter | string
    email_address?: StringFilter | string
    user_password?: StringFilter | string
    trusted_user?: BoolNullableFilter | boolean | null
    user_level_id?: IntFilter | number
    user_profile_id?: IntFilter | number
  }

  export type usersCreateWithoutUser_profilesInput = {
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_levels: user_levelsCreateNestedOneWithoutUsersInput
    confirmed_sightings?: confirmed_sightingsCreateNestedManyWithoutUsersInput
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionCreateNestedManyWithoutUsersInput
    user_votes?: user_votesCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_profilesInput = {
    id?: number
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_level_id: number
    confirmed_sightings?: confirmed_sightingsUncheckedCreateNestedManyWithoutUsersInput
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionUncheckedCreateNestedManyWithoutUsersInput
    user_votes?: user_votesUncheckedCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_profilesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_profilesInput, usersUncheckedCreateWithoutUser_profilesInput>
  }

  export type usersCreateManyUser_profilesInputEnvelope = {
    data: Enumerable<usersCreateManyUser_profilesInput>
    skipDuplicates?: boolean
  }

  export type usersUpsertWithWhereUniqueWithoutUser_profilesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutUser_profilesInput, usersUncheckedUpdateWithoutUser_profilesInput>
    create: XOR<usersCreateWithoutUser_profilesInput, usersUncheckedCreateWithoutUser_profilesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutUser_profilesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutUser_profilesInput, usersUncheckedUpdateWithoutUser_profilesInput>
  }

  export type usersUpdateManyWithWhereWithoutUser_profilesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutUsersInput>
  }

  export type reactionsCreateWithoutUser_to_reactionInput = {
    reaction_name: string
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutReactionsInput
  }

  export type reactionsUncheckedCreateWithoutUser_to_reactionInput = {
    id?: number
    reaction_name: string
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutReactionsInput
  }

  export type reactionsCreateOrConnectWithoutUser_to_reactionInput = {
    where: reactionsWhereUniqueInput
    create: XOR<reactionsCreateWithoutUser_to_reactionInput, reactionsUncheckedCreateWithoutUser_to_reactionInput>
  }

  export type usersCreateWithoutUser_to_reactionInput = {
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_levels: user_levelsCreateNestedOneWithoutUsersInput
    user_profiles: user_profilesCreateNestedOneWithoutUsersInput
    confirmed_sightings?: confirmed_sightingsCreateNestedManyWithoutUsersInput
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutUsersInput
    user_votes?: user_votesCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_to_reactionInput = {
    id?: number
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_level_id: number
    user_profile_id: number
    confirmed_sightings?: confirmed_sightingsUncheckedCreateNestedManyWithoutUsersInput
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutUsersInput
    user_votes?: user_votesUncheckedCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_to_reactionInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_to_reactionInput, usersUncheckedCreateWithoutUser_to_reactionInput>
  }

  export type reactionsUpsertWithoutUser_to_reactionInput = {
    update: XOR<reactionsUpdateWithoutUser_to_reactionInput, reactionsUncheckedUpdateWithoutUser_to_reactionInput>
    create: XOR<reactionsCreateWithoutUser_to_reactionInput, reactionsUncheckedCreateWithoutUser_to_reactionInput>
  }

  export type reactionsUpdateWithoutUser_to_reactionInput = {
    reaction_name?: StringFieldUpdateOperationsInput | string
    unverified_sightings?: unverified_sightingsUpdateManyWithoutReactionsNestedInput
  }

  export type reactionsUncheckedUpdateWithoutUser_to_reactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction_name?: StringFieldUpdateOperationsInput | string
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutReactionsNestedInput
  }

  export type usersUpsertWithoutUser_to_reactionInput = {
    update: XOR<usersUpdateWithoutUser_to_reactionInput, usersUncheckedUpdateWithoutUser_to_reactionInput>
    create: XOR<usersCreateWithoutUser_to_reactionInput, usersUncheckedCreateWithoutUser_to_reactionInput>
  }

  export type usersUpdateWithoutUser_to_reactionInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_levels?: user_levelsUpdateOneRequiredWithoutUsersNestedInput
    user_profiles?: user_profilesUpdateOneRequiredWithoutUsersNestedInput
    confirmed_sightings?: confirmed_sightingsUpdateManyWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_to_reactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_level_id?: IntFieldUpdateOperationsInput | number
    user_profile_id?: IntFieldUpdateOperationsInput | number
    confirmed_sightings?: confirmed_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUncheckedUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutUser_votesInput = {
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_levels: user_levelsCreateNestedOneWithoutUsersInput
    user_profiles: user_profilesCreateNestedOneWithoutUsersInput
    confirmed_sightings?: confirmed_sightingsCreateNestedManyWithoutUsersInput
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUser_votesInput = {
    id?: number
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_level_id: number
    user_profile_id: number
    confirmed_sightings?: confirmed_sightingsUncheckedCreateNestedManyWithoutUsersInput
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionUncheckedCreateNestedManyWithoutUsersInput
    users_to_groups?: users_to_groupsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUser_votesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUser_votesInput, usersUncheckedCreateWithoutUser_votesInput>
  }

  export type unverified_sightingsCreateWithoutUser_votesInput = {
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    organisms: organismsCreateNestedOneWithoutUnverified_sightingsInput
    reactions?: reactionsCreateNestedOneWithoutUnverified_sightingsInput
    users: usersCreateNestedOneWithoutUnverified_sightingsInput
  }

  export type unverified_sightingsUncheckedCreateWithoutUser_votesInput = {
    id?: number
    organism_id: number
    user_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    reaction_id?: number | null
  }

  export type unverified_sightingsCreateOrConnectWithoutUser_votesInput = {
    where: unverified_sightingsWhereUniqueInput
    create: XOR<unverified_sightingsCreateWithoutUser_votesInput, unverified_sightingsUncheckedCreateWithoutUser_votesInput>
  }

  export type unverified_sightingsCreateManyUser_votesInputEnvelope = {
    data: Enumerable<unverified_sightingsCreateManyUser_votesInput>
    skipDuplicates?: boolean
  }

  export type usersUpsertWithoutUser_votesInput = {
    update: XOR<usersUpdateWithoutUser_votesInput, usersUncheckedUpdateWithoutUser_votesInput>
    create: XOR<usersCreateWithoutUser_votesInput, usersUncheckedCreateWithoutUser_votesInput>
  }

  export type usersUpdateWithoutUser_votesInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_levels?: user_levelsUpdateOneRequiredWithoutUsersNestedInput
    user_profiles?: user_profilesUpdateOneRequiredWithoutUsersNestedInput
    confirmed_sightings?: confirmed_sightingsUpdateManyWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_votesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_level_id?: IntFieldUpdateOperationsInput | number
    user_profile_id?: IntFieldUpdateOperationsInput | number
    confirmed_sightings?: confirmed_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUncheckedUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type unverified_sightingsUpsertWithWhereUniqueWithoutUser_votesInput = {
    where: unverified_sightingsWhereUniqueInput
    update: XOR<unverified_sightingsUpdateWithoutUser_votesInput, unverified_sightingsUncheckedUpdateWithoutUser_votesInput>
    create: XOR<unverified_sightingsCreateWithoutUser_votesInput, unverified_sightingsUncheckedCreateWithoutUser_votesInput>
  }

  export type unverified_sightingsUpdateWithWhereUniqueWithoutUser_votesInput = {
    where: unverified_sightingsWhereUniqueInput
    data: XOR<unverified_sightingsUpdateWithoutUser_votesInput, unverified_sightingsUncheckedUpdateWithoutUser_votesInput>
  }

  export type unverified_sightingsUpdateManyWithWhereWithoutUser_votesInput = {
    where: unverified_sightingsScalarWhereInput
    data: XOR<unverified_sightingsUpdateManyMutationInput, unverified_sightingsUncheckedUpdateManyWithoutUnverified_sightingsInput>
  }

  export type user_levelsCreateWithoutUsersInput = {
    description: string
  }

  export type user_levelsUncheckedCreateWithoutUsersInput = {
    id?: number
    description: string
  }

  export type user_levelsCreateOrConnectWithoutUsersInput = {
    where: user_levelsWhereUniqueInput
    create: XOR<user_levelsCreateWithoutUsersInput, user_levelsUncheckedCreateWithoutUsersInput>
  }

  export type user_profilesCreateWithoutUsersInput = {
    profile_message?: string | null
    profile_picture?: string | null
  }

  export type user_profilesUncheckedCreateWithoutUsersInput = {
    id?: number
    profile_message?: string | null
    profile_picture?: string | null
  }

  export type user_profilesCreateOrConnectWithoutUsersInput = {
    where: user_profilesWhereUniqueInput
    create: XOR<user_profilesCreateWithoutUsersInput, user_profilesUncheckedCreateWithoutUsersInput>
  }

  export type confirmed_sightingsCreateWithoutUsersInput = {
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    organisms: organismsCreateNestedOneWithoutConfirmed_sightingsInput
  }

  export type confirmed_sightingsUncheckedCreateWithoutUsersInput = {
    id?: number
    organism_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
  }

  export type confirmed_sightingsCreateOrConnectWithoutUsersInput = {
    where: confirmed_sightingsWhereUniqueInput
    create: XOR<confirmed_sightingsCreateWithoutUsersInput, confirmed_sightingsUncheckedCreateWithoutUsersInput>
  }

  export type confirmed_sightingsCreateManyUsersInputEnvelope = {
    data: Enumerable<confirmed_sightingsCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type unverified_sightingsCreateWithoutUsersInput = {
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    organisms: organismsCreateNestedOneWithoutUnverified_sightingsInput
    reactions?: reactionsCreateNestedOneWithoutUnverified_sightingsInput
    user_votes?: user_votesCreateNestedOneWithoutUnverified_sightingsInput
  }

  export type unverified_sightingsUncheckedCreateWithoutUsersInput = {
    id?: number
    organism_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    user_vote_id?: number | null
    reaction_id?: number | null
  }

  export type unverified_sightingsCreateOrConnectWithoutUsersInput = {
    where: unverified_sightingsWhereUniqueInput
    create: XOR<unverified_sightingsCreateWithoutUsersInput, unverified_sightingsUncheckedCreateWithoutUsersInput>
  }

  export type unverified_sightingsCreateManyUsersInputEnvelope = {
    data: Enumerable<unverified_sightingsCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type user_to_reactionCreateWithoutUsersInput = {
    reactions: reactionsCreateNestedOneWithoutUser_to_reactionInput
  }

  export type user_to_reactionUncheckedCreateWithoutUsersInput = {
    id?: number
    reaction_id: number
  }

  export type user_to_reactionCreateOrConnectWithoutUsersInput = {
    where: user_to_reactionWhereUniqueInput
    create: XOR<user_to_reactionCreateWithoutUsersInput, user_to_reactionUncheckedCreateWithoutUsersInput>
  }

  export type user_to_reactionCreateManyUsersInputEnvelope = {
    data: Enumerable<user_to_reactionCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type user_votesCreateWithoutUsersInput = {
    user_vote: number
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutUser_votesInput
  }

  export type user_votesUncheckedCreateWithoutUsersInput = {
    id?: number
    user_vote: number
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutUser_votesInput
  }

  export type user_votesCreateOrConnectWithoutUsersInput = {
    where: user_votesWhereUniqueInput
    create: XOR<user_votesCreateWithoutUsersInput, user_votesUncheckedCreateWithoutUsersInput>
  }

  export type user_votesCreateManyUsersInputEnvelope = {
    data: Enumerable<user_votesCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type users_to_groupsCreateWithoutUsersInput = {
    interest_groups: interest_groupsCreateNestedOneWithoutUsers_to_groupsInput
  }

  export type users_to_groupsUncheckedCreateWithoutUsersInput = {
    id?: number
    group_id: number
  }

  export type users_to_groupsCreateOrConnectWithoutUsersInput = {
    where: users_to_groupsWhereUniqueInput
    create: XOR<users_to_groupsCreateWithoutUsersInput, users_to_groupsUncheckedCreateWithoutUsersInput>
  }

  export type users_to_groupsCreateManyUsersInputEnvelope = {
    data: Enumerable<users_to_groupsCreateManyUsersInput>
    skipDuplicates?: boolean
  }

  export type user_levelsUpsertWithoutUsersInput = {
    update: XOR<user_levelsUpdateWithoutUsersInput, user_levelsUncheckedUpdateWithoutUsersInput>
    create: XOR<user_levelsCreateWithoutUsersInput, user_levelsUncheckedCreateWithoutUsersInput>
  }

  export type user_levelsUpdateWithoutUsersInput = {
    description?: StringFieldUpdateOperationsInput | string
  }

  export type user_levelsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
  }

  export type user_profilesUpsertWithoutUsersInput = {
    update: XOR<user_profilesUpdateWithoutUsersInput, user_profilesUncheckedUpdateWithoutUsersInput>
    create: XOR<user_profilesCreateWithoutUsersInput, user_profilesUncheckedCreateWithoutUsersInput>
  }

  export type user_profilesUpdateWithoutUsersInput = {
    profile_message?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type user_profilesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    profile_message?: NullableStringFieldUpdateOperationsInput | string | null
    profile_picture?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type confirmed_sightingsUpsertWithWhereUniqueWithoutUsersInput = {
    where: confirmed_sightingsWhereUniqueInput
    update: XOR<confirmed_sightingsUpdateWithoutUsersInput, confirmed_sightingsUncheckedUpdateWithoutUsersInput>
    create: XOR<confirmed_sightingsCreateWithoutUsersInput, confirmed_sightingsUncheckedCreateWithoutUsersInput>
  }

  export type confirmed_sightingsUpdateWithWhereUniqueWithoutUsersInput = {
    where: confirmed_sightingsWhereUniqueInput
    data: XOR<confirmed_sightingsUpdateWithoutUsersInput, confirmed_sightingsUncheckedUpdateWithoutUsersInput>
  }

  export type confirmed_sightingsUpdateManyWithWhereWithoutUsersInput = {
    where: confirmed_sightingsScalarWhereInput
    data: XOR<confirmed_sightingsUpdateManyMutationInput, confirmed_sightingsUncheckedUpdateManyWithoutConfirmed_sightingsInput>
  }

  export type unverified_sightingsUpsertWithWhereUniqueWithoutUsersInput = {
    where: unverified_sightingsWhereUniqueInput
    update: XOR<unverified_sightingsUpdateWithoutUsersInput, unverified_sightingsUncheckedUpdateWithoutUsersInput>
    create: XOR<unverified_sightingsCreateWithoutUsersInput, unverified_sightingsUncheckedCreateWithoutUsersInput>
  }

  export type unverified_sightingsUpdateWithWhereUniqueWithoutUsersInput = {
    where: unverified_sightingsWhereUniqueInput
    data: XOR<unverified_sightingsUpdateWithoutUsersInput, unverified_sightingsUncheckedUpdateWithoutUsersInput>
  }

  export type unverified_sightingsUpdateManyWithWhereWithoutUsersInput = {
    where: unverified_sightingsScalarWhereInput
    data: XOR<unverified_sightingsUpdateManyMutationInput, unverified_sightingsUncheckedUpdateManyWithoutUnverified_sightingsInput>
  }

  export type user_to_reactionUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_to_reactionWhereUniqueInput
    update: XOR<user_to_reactionUpdateWithoutUsersInput, user_to_reactionUncheckedUpdateWithoutUsersInput>
    create: XOR<user_to_reactionCreateWithoutUsersInput, user_to_reactionUncheckedCreateWithoutUsersInput>
  }

  export type user_to_reactionUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_to_reactionWhereUniqueInput
    data: XOR<user_to_reactionUpdateWithoutUsersInput, user_to_reactionUncheckedUpdateWithoutUsersInput>
  }

  export type user_to_reactionUpdateManyWithWhereWithoutUsersInput = {
    where: user_to_reactionScalarWhereInput
    data: XOR<user_to_reactionUpdateManyMutationInput, user_to_reactionUncheckedUpdateManyWithoutUser_to_reactionInput>
  }

  export type user_votesUpsertWithWhereUniqueWithoutUsersInput = {
    where: user_votesWhereUniqueInput
    update: XOR<user_votesUpdateWithoutUsersInput, user_votesUncheckedUpdateWithoutUsersInput>
    create: XOR<user_votesCreateWithoutUsersInput, user_votesUncheckedCreateWithoutUsersInput>
  }

  export type user_votesUpdateWithWhereUniqueWithoutUsersInput = {
    where: user_votesWhereUniqueInput
    data: XOR<user_votesUpdateWithoutUsersInput, user_votesUncheckedUpdateWithoutUsersInput>
  }

  export type user_votesUpdateManyWithWhereWithoutUsersInput = {
    where: user_votesScalarWhereInput
    data: XOR<user_votesUpdateManyMutationInput, user_votesUncheckedUpdateManyWithoutUser_votesInput>
  }

  export type user_votesScalarWhereInput = {
    AND?: Enumerable<user_votesScalarWhereInput>
    OR?: Enumerable<user_votesScalarWhereInput>
    NOT?: Enumerable<user_votesScalarWhereInput>
    id?: IntFilter | number
    user_id?: IntFilter | number
    user_vote?: IntFilter | number
  }

  export type users_to_groupsUpsertWithWhereUniqueWithoutUsersInput = {
    where: users_to_groupsWhereUniqueInput
    update: XOR<users_to_groupsUpdateWithoutUsersInput, users_to_groupsUncheckedUpdateWithoutUsersInput>
    create: XOR<users_to_groupsCreateWithoutUsersInput, users_to_groupsUncheckedCreateWithoutUsersInput>
  }

  export type users_to_groupsUpdateWithWhereUniqueWithoutUsersInput = {
    where: users_to_groupsWhereUniqueInput
    data: XOR<users_to_groupsUpdateWithoutUsersInput, users_to_groupsUncheckedUpdateWithoutUsersInput>
  }

  export type users_to_groupsUpdateManyWithWhereWithoutUsersInput = {
    where: users_to_groupsScalarWhereInput
    data: XOR<users_to_groupsUpdateManyMutationInput, users_to_groupsUncheckedUpdateManyWithoutUsers_to_groupsInput>
  }

  export type interest_groupsCreateWithoutUsers_to_groupsInput = {
    group_name: string
    description?: string | null
  }

  export type interest_groupsUncheckedCreateWithoutUsers_to_groupsInput = {
    id?: number
    group_name: string
    description?: string | null
  }

  export type interest_groupsCreateOrConnectWithoutUsers_to_groupsInput = {
    where: interest_groupsWhereUniqueInput
    create: XOR<interest_groupsCreateWithoutUsers_to_groupsInput, interest_groupsUncheckedCreateWithoutUsers_to_groupsInput>
  }

  export type usersCreateWithoutUsers_to_groupsInput = {
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_levels: user_levelsCreateNestedOneWithoutUsersInput
    user_profiles: user_profilesCreateNestedOneWithoutUsersInput
    confirmed_sightings?: confirmed_sightingsCreateNestedManyWithoutUsersInput
    unverified_sightings?: unverified_sightingsCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionCreateNestedManyWithoutUsersInput
    user_votes?: user_votesCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUsers_to_groupsInput = {
    id?: number
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_level_id: number
    user_profile_id: number
    confirmed_sightings?: confirmed_sightingsUncheckedCreateNestedManyWithoutUsersInput
    unverified_sightings?: unverified_sightingsUncheckedCreateNestedManyWithoutUsersInput
    user_to_reaction?: user_to_reactionUncheckedCreateNestedManyWithoutUsersInput
    user_votes?: user_votesUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUsers_to_groupsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUsers_to_groupsInput, usersUncheckedCreateWithoutUsers_to_groupsInput>
  }

  export type interest_groupsUpsertWithoutUsers_to_groupsInput = {
    update: XOR<interest_groupsUpdateWithoutUsers_to_groupsInput, interest_groupsUncheckedUpdateWithoutUsers_to_groupsInput>
    create: XOR<interest_groupsCreateWithoutUsers_to_groupsInput, interest_groupsUncheckedCreateWithoutUsers_to_groupsInput>
  }

  export type interest_groupsUpdateWithoutUsers_to_groupsInput = {
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type interest_groupsUncheckedUpdateWithoutUsers_to_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersUpsertWithoutUsers_to_groupsInput = {
    update: XOR<usersUpdateWithoutUsers_to_groupsInput, usersUncheckedUpdateWithoutUsers_to_groupsInput>
    create: XOR<usersCreateWithoutUsers_to_groupsInput, usersUncheckedCreateWithoutUsers_to_groupsInput>
  }

  export type usersUpdateWithoutUsers_to_groupsInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_levels?: user_levelsUpdateOneRequiredWithoutUsersNestedInput
    user_profiles?: user_profilesUpdateOneRequiredWithoutUsersNestedInput
    confirmed_sightings?: confirmed_sightingsUpdateManyWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUsers_to_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_level_id?: IntFieldUpdateOperationsInput | number
    user_profile_id?: IntFieldUpdateOperationsInput | number
    confirmed_sightings?: confirmed_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUncheckedUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type users_to_groupsCreateManyInterest_groupsInput = {
    id?: number
    user_id: number
  }

  export type users_to_groupsUpdateWithoutInterest_groupsInput = {
    users?: usersUpdateOneRequiredWithoutUsers_to_groupsNestedInput
  }

  export type users_to_groupsUncheckedUpdateWithoutInterest_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type users_to_groupsUncheckedUpdateManyWithoutUsers_to_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type confirmed_sightingsCreateManyOrganismsInput = {
    id?: number
    user_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
  }

  export type unverified_sightingsCreateManyOrganismsInput = {
    id?: number
    user_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    user_vote_id?: number | null
    reaction_id?: number | null
  }

  export type confirmed_sightingsUpdateWithoutOrganismsInput = {
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    users?: usersUpdateOneRequiredWithoutConfirmed_sightingsNestedInput
  }

  export type confirmed_sightingsUncheckedUpdateWithoutOrganismsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type confirmed_sightingsUncheckedUpdateManyWithoutConfirmed_sightingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type unverified_sightingsUpdateWithoutOrganismsInput = {
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reactions?: reactionsUpdateOneWithoutUnverified_sightingsNestedInput
    users?: usersUpdateOneRequiredWithoutUnverified_sightingsNestedInput
    user_votes?: user_votesUpdateOneWithoutUnverified_sightingsNestedInput
  }

  export type unverified_sightingsUncheckedUpdateWithoutOrganismsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_vote_id?: NullableIntFieldUpdateOperationsInput | number | null
    reaction_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type unverified_sightingsUncheckedUpdateManyWithoutUnverified_sightingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_vote_id?: NullableIntFieldUpdateOperationsInput | number | null
    reaction_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type unverified_sightingsCreateManyReactionsInput = {
    id?: number
    organism_id: number
    user_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    user_vote_id?: number | null
  }

  export type user_to_reactionCreateManyReactionsInput = {
    id?: number
    user_id: number
  }

  export type unverified_sightingsUpdateWithoutReactionsInput = {
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    organisms?: organismsUpdateOneRequiredWithoutUnverified_sightingsNestedInput
    users?: usersUpdateOneRequiredWithoutUnverified_sightingsNestedInput
    user_votes?: user_votesUpdateOneWithoutUnverified_sightingsNestedInput
  }

  export type unverified_sightingsUncheckedUpdateWithoutReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    organism_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_vote_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type user_to_reactionUpdateWithoutReactionsInput = {
    users?: usersUpdateOneRequiredWithoutUser_to_reactionNestedInput
  }

  export type user_to_reactionUncheckedUpdateWithoutReactionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_to_reactionUncheckedUpdateManyWithoutUser_to_reactionInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
  }

  export type organismsCreateManyTaxon_groupsInput = {
    id?: number
    taxon_name: string
    latin_name: string
    picture_url?: string | null
    description?: string | null
  }

  export type organismsUpdateWithoutTaxon_groupsInput = {
    taxon_name?: StringFieldUpdateOperationsInput | string
    latin_name?: StringFieldUpdateOperationsInput | string
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_sightings?: confirmed_sightingsUpdateManyWithoutOrganismsNestedInput
    unverified_sightings?: unverified_sightingsUpdateManyWithoutOrganismsNestedInput
  }

  export type organismsUncheckedUpdateWithoutTaxon_groupsInput = {
    id?: IntFieldUpdateOperationsInput | number
    taxon_name?: StringFieldUpdateOperationsInput | string
    latin_name?: StringFieldUpdateOperationsInput | string
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    confirmed_sightings?: confirmed_sightingsUncheckedUpdateManyWithoutOrganismsNestedInput
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutOrganismsNestedInput
  }

  export type organismsUncheckedUpdateManyWithoutOrganismsInput = {
    id?: IntFieldUpdateOperationsInput | number
    taxon_name?: StringFieldUpdateOperationsInput | string
    latin_name?: StringFieldUpdateOperationsInput | string
    picture_url?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type usersCreateManyUser_levelsInput = {
    id?: number
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_profile_id: number
  }

  export type usersUpdateWithoutUser_levelsInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_profiles?: user_profilesUpdateOneRequiredWithoutUsersNestedInput
    confirmed_sightings?: confirmed_sightingsUpdateManyWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_levelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_profile_id?: IntFieldUpdateOperationsInput | number
    confirmed_sightings?: confirmed_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUncheckedUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUncheckedUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_profile_id?: IntFieldUpdateOperationsInput | number
  }

  export type usersCreateManyUser_profilesInput = {
    id?: number
    user_name: string
    email_address: string
    user_password: string
    trusted_user?: boolean | null
    user_level_id: number
  }

  export type usersUpdateWithoutUser_profilesInput = {
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_levels?: user_levelsUpdateOneRequiredWithoutUsersNestedInput
    confirmed_sightings?: confirmed_sightingsUpdateManyWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUser_profilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_name?: StringFieldUpdateOperationsInput | string
    email_address?: StringFieldUpdateOperationsInput | string
    user_password?: StringFieldUpdateOperationsInput | string
    trusted_user?: NullableBoolFieldUpdateOperationsInput | boolean | null
    user_level_id?: IntFieldUpdateOperationsInput | number
    confirmed_sightings?: confirmed_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutUsersNestedInput
    user_to_reaction?: user_to_reactionUncheckedUpdateManyWithoutUsersNestedInput
    user_votes?: user_votesUncheckedUpdateManyWithoutUsersNestedInput
    users_to_groups?: users_to_groupsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type unverified_sightingsCreateManyUser_votesInput = {
    id?: number
    organism_id: number
    user_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    reaction_id?: number | null
  }

  export type unverified_sightingsUpdateWithoutUser_votesInput = {
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    organisms?: organismsUpdateOneRequiredWithoutUnverified_sightingsNestedInput
    reactions?: reactionsUpdateOneWithoutUnverified_sightingsNestedInput
    users?: usersUpdateOneRequiredWithoutUnverified_sightingsNestedInput
  }

  export type unverified_sightingsUncheckedUpdateWithoutUser_votesInput = {
    id?: IntFieldUpdateOperationsInput | number
    organism_id?: IntFieldUpdateOperationsInput | number
    user_id?: IntFieldUpdateOperationsInput | number
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reaction_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type confirmed_sightingsCreateManyUsersInput = {
    id?: number
    organism_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
  }

  export type unverified_sightingsCreateManyUsersInput = {
    id?: number
    organism_id: number
    picture_url: string
    date: Date | string
    lat: Decimal | DecimalJsLike | number | string
    long: Decimal | DecimalJsLike | number | string
    user_vote_id?: number | null
    reaction_id?: number | null
  }

  export type user_to_reactionCreateManyUsersInput = {
    id?: number
    reaction_id: number
  }

  export type user_votesCreateManyUsersInput = {
    id?: number
    user_vote: number
  }

  export type users_to_groupsCreateManyUsersInput = {
    id?: number
    group_id: number
  }

  export type confirmed_sightingsUpdateWithoutUsersInput = {
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    organisms?: organismsUpdateOneRequiredWithoutConfirmed_sightingsNestedInput
  }

  export type confirmed_sightingsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    organism_id?: IntFieldUpdateOperationsInput | number
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
  }

  export type unverified_sightingsUpdateWithoutUsersInput = {
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    organisms?: organismsUpdateOneRequiredWithoutUnverified_sightingsNestedInput
    reactions?: reactionsUpdateOneWithoutUnverified_sightingsNestedInput
    user_votes?: user_votesUpdateOneWithoutUnverified_sightingsNestedInput
  }

  export type unverified_sightingsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    organism_id?: IntFieldUpdateOperationsInput | number
    picture_url?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    lat?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    long?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    user_vote_id?: NullableIntFieldUpdateOperationsInput | number | null
    reaction_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type user_to_reactionUpdateWithoutUsersInput = {
    reactions?: reactionsUpdateOneRequiredWithoutUser_to_reactionNestedInput
  }

  export type user_to_reactionUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    reaction_id?: IntFieldUpdateOperationsInput | number
  }

  export type user_votesUpdateWithoutUsersInput = {
    user_vote?: IntFieldUpdateOperationsInput | number
    unverified_sightings?: unverified_sightingsUpdateManyWithoutUser_votesNestedInput
  }

  export type user_votesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_vote?: IntFieldUpdateOperationsInput | number
    unverified_sightings?: unverified_sightingsUncheckedUpdateManyWithoutUser_votesNestedInput
  }

  export type user_votesUncheckedUpdateManyWithoutUser_votesInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_vote?: IntFieldUpdateOperationsInput | number
  }

  export type users_to_groupsUpdateWithoutUsersInput = {
    interest_groups?: interest_groupsUpdateOneRequiredWithoutUsers_to_groupsNestedInput
  }

  export type users_to_groupsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    group_id?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}